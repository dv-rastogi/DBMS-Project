Name,Language,Content
Advertisement,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

template<int SZ> struct DSU {
    int par[SZ], sz[SZ];
    DSU() {
        F0R(i,SZ) par[i] = -1, sz[i] = 1;
    }
    
    int get(int x) { // path compression
        if (par[x] != x) par[x] = get(par[x]);
        return par[x];
    }
    
    bool unite(int x, int y) { // union-by-rank
        x = get(x), y = get(y);
        if (x == y) return 0;
        if (sz[x] < sz[y]) swap(x,y);
        sz[x] += sz[y], par[y] = x;
        return 1;
    }
};

DSU<500000> D;
int n;
vector<pii> v;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n;
    F0R(i,n) {
        int h; cin >> h;
        v.pb({h,i});
    }
    sort(v.rbegin(),v.rend());
    
    ll ans = 0;
    for (auto a: v) {
        D.par[a.s] = a.s;
        if (a.s > 0 && D.par[a.s-1] != -1) D.unite(a.s,a.s-1);
        if (a.s < n-1 && D.par[a.s+1] != -1) D.unite(a.s,a.s+1);
        ans = max(ans,a.f*(ll)D.sz[D.get(a.s)]);
    }
    cout << ans;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Advertisement,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vi x(n+2);
    rep(i, 1, n+1) cin >> x[i];
    vi L(n+2), R(n+2);
    vi s(1);
    rep(i, 1, n+1) {
        while (x[i]<=x[s.back()])
            s.pop_back();
        L[i]=s.back();
        s.push_back(i);
    }
    s.assign(1, n+1);
    for(int i=n; i>0; i--) {
        while (x[i]<=x[s.back()])
            s.pop_back();
        R[i]=s.back();
        s.push_back(i);
    }
    ll ans=0;
    rep(i, 1, n+1)
    ans=max(ans, 1LL*x[i]*(R[i]-L[i]-1));
    cout << ans << '\n';
    return 0;
}
"
Advertisement,Java,"// https://cses.fi/problemset/task/1142
// Advertisement
import java.io.*;
import java.util.*;

public class CSES1142 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] aa = new int[1 + n + 1];
        for (int i = 1; i <= n; i++)
            aa[i] = Integer.parseInt(st.nextToken());
        int[] stack = new int[1 + n];
        int cnt = 0;
        stack[cnt++] = 0;
        int[] ll = new int[1 + n];
        for (int i = 1; i <= n; i++) {
            while (cnt > 0 && aa[stack[cnt - 1]] >= aa[i])
                cnt--;
            ll[i] = stack[cnt - 1];
            stack[cnt++] = i;
        }
        cnt = 0;
        stack[cnt++] = n + 1;
        int[] rr = new int[1 + n];
        for (int i = n; i >= 1; i--) {
            while (cnt > 0 && aa[stack[cnt - 1]] >= aa[i])
                cnt--;
            rr[i] = stack[cnt - 1];
            stack[cnt++] = i;
        }
        long ans = 0;
        for (int i = 1; i <= n; i++)
            ans = Math.max(ans, (long) (rr[i] - ll[i] - 1) * aa[i]);
        System.out.println(ans);
    }
}
"
Advertisement,C++,"/*
 https://cses.fi/problemset/task/1142
 Advertisement
 */
#include <stdio.h>

#define N    500000

int main() {
    static int aa[1 + N + 1], stack[1 + N], ll[1 + N], rr[1 + N];
    int n, i, cnt;
    long long ans;
    
    scanf(""%d"", &n);
    for (i = 1; i <= n; i++)
        scanf(""%d"", &aa[i]);
    cnt = 0;
    stack[cnt++] = 0;
    for (i = 1; i <= n; i++) {
        while (cnt && aa[stack[cnt - 1]] >= aa[i])
            cnt--;
        ll[i] = stack[cnt - 1];
        stack[cnt++] = i;
    }
    cnt = 0;
    stack[cnt++] = n + 1;
    for (i = n; i >= 1; i--) {
        while (cnt && aa[stack[cnt - 1]] >= aa[i])
            cnt--;
        rr[i] = stack[cnt - 1];
        stack[cnt++] = i;
    }
    ans = 0;
    for (i = 1; i <= n; i++) {
        long long x = (long long) (rr[i] - ll[i] - 1) * aa[i];
        
        if (ans < x)
            ans = x;
    }
    printf(""%lld\n"", ans);
    return 0;
}
"
Area of Rectangles,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<class T, int SZ> struct LazySegTree {
    T lazy[2*SZ]; // set SZ to a power of 2
    pi mn[2*SZ];
    
    LazySegTree() {
        memset (mn,0,sizeof mn);
        memset (lazy,0,sizeof lazy);
    }
    
    void push(int ind, int L, int R) {
        mn[ind].f += lazy[ind];
        if (L != R) lazy[2*ind] += lazy[ind], lazy[2*ind+1] += lazy[ind];
        lazy[ind] = 0;
    }
    
    pi comb(pi a, pi b) {
        if (a.f != b.f) return min(a,b);
        return {a.f,a.s+b.s};
    }
    
    void pull(int ind) {
        mn[ind] = comb(mn[2*ind],mn[2*ind+1]);
    }
    
    void build() {
        FOR(i,SZ,2*SZ) mn[i] = {0,1};
        FORd(i,1,SZ) pull(i);
    }
    
    void upd(int lo, int hi, ll inc, int ind = 1, int L = 0, int R = SZ-1) {
        push(ind,L,R);
        if (hi < L || R < lo) return;
        if (lo <= L && R <= hi) {
            lazy[ind] = inc;
            push(ind,L,R);
            return;
        }
        
        int M = (L+R)/2;
        upd(lo,hi,inc,2*ind,L,M); upd(lo,hi,inc,2*ind+1,M+1,R);
        pull(ind);
    }
};

LazySegTree<int,1<<21> L;
int n;

int main() {
    setIO(); re(n);
    vector<array<int,4>> mod;
    F0R(i,n) {
        int x1,y1,x2,y2; re(x1,y1,x2,y2);
        x1 += 1000000;
        x2 += 1000000;
        y1 += 1000000;
        y2 += 1000000;
        mod.pb({x1,1,y1,y2-1});
        mod.pb({x2,-1,y1,y2-1});
    }
    sort(all(mod));
    int ind = 0;
    ll ans = 0;
    L.build();
    // ps(1<<21,L.mn[1].s);
    F0R(x,2000000) {
        while (ind < sz(mod) && mod[ind][0] == x) {
            L.upd(mod[ind][2],mod[ind][3],mod[ind][1]);
            ind ++;
        }
        ans += (1<<21)-L.mn[1].s;
    }
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Area of Rectangles,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

const int inf = 1e9;
struct Node {
    Node *l = 0, *r = 0;
    int lo, hi, madd = 0, val = 0;
    Node(int lo,int hi):lo(lo),hi(hi){} // Large interval of 0
    void add(int L, int R, int x) {
        if (R <= lo || hi <= L) return;
        if (L <= lo && hi <= R)
            madd += x;
        else
            push(), l->add(L, R, x), r->add(L, R, x);
        if (madd) val=hi-lo;
        else val=(l? l->val:0)+(r? r->val:0);
    }
    void push() {
        if (!l) {
            int mid = lo + (hi - lo)/2;
            l = new Node(lo, mid); r = new Node(mid, hi);
        }
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    map<int, vector<array<int, 3>>> e;
    rep(i, 0, n) {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        e[x1].push_back({y1, y2, 1});
        e[x2].push_back({y1, y2, -1});
    }
    Node *tr = new Node(-inf, inf);
    ll x=-inf, ans=0;
    trav(a, e) trav(p, a.second) {
        ans+=(a.first-x)*tr->val;
        tr->add(p[0], p[1], p[2]);
        x=a.first;
    }
    cout << ans << '\n';
    return 0;
}
"
Area of Rectangles,Java,"// https://cses.fi/problemset/task/1741
// Area of Rectangles
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1741 extends PrintWriter {
    CSES1741() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            boolean minus = c == '-'; if (minus) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return minus ? -a : a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1741 o = new CSES1741(); o.main(); o.flush();
    }
    
    static final int Z = 1000000, A = 1 << 21;
    static class V {
        int y, l, r;
        boolean add;
        V(int y, int l, int r, boolean add) {
            this.y = y; this.l = l; this.r = r; this.add = add;
        }
    }
    int[] tr, zz;
    void update(int k, int l, int r, int ql, int qr, int x) {
        if (qr <= l || r <= ql)
            return;
        int k1 = k * 2 + 1, k2 = k * 2 + 2;
        if (ql <= l && r <= qr)
            zz[k] += x;
        else {
            int m = (l + r) / 2;
            update(k1, l, m, ql, qr, x);
            update(k2, m, r, ql, qr, x);
        }
        tr[k] = zz[k] > 0 ? r - l : r - l == 1 ? 0 : tr[k1] + tr[k2];
    }
    void main() {
        int n = sc.nextInt();
        V[] vv = new V[n * 2];
        int m = 0;
        for (int i = 0; i < n; i++) {
            int x1 = sc.nextInt() + Z;
            int y1 = sc.nextInt() + Z;
            int x2 = sc.nextInt() + Z;
            int y2 = sc.nextInt() + Z;
            vv[m++] = new V(y1, x1, x2, true);
            vv[m++] = new V(y2, x1, x2, false);
        }
        Arrays.sort(vv, (u, v) -> u.y - v.y);
        tr = new int[A * 2];
        zz = new int[A * 2];
        int y = -1;
        long ans = 0;
        for (int h = 0; h < m; h++) {
            V v = vv[h];
            if (y != -1)
                ans += (long) (v.y - y) * tr[0];
            y = v.y;
            update(0, 0, A, v.l, v.r, v.add ? 1 : -1);
        }
        println(ans);
    }
}
"
Area of Rectangles,C++,"/*
 https://cses.fi/problemset/task/1741
 Area of Rectangles
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    100000
#define Z    1000000
#define A    (1 << 21)

struct V {
    int y, l, r, add;
} vv[N * 2];

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

int compare(const void *a, const void *b) {
    struct V *u = (struct V *) a;
    struct V *v = (struct V *) b;
    
    return u->y - v->y;
}

int tr[A * 2], zz[A * 2];

void update(int k, int l, int r, int ql, int qr, int x) {
    int k1, k2;
    
    if (qr <= l || r <= ql)
        return;
    k1 = k * 2 + 1;
    k2 = k * 2 + 2;
    if (ql <= l && r <= qr)
        zz[k] += x;
    else {
        int m = (l + r) / 2;
        
        update(k1, l, m, ql, qr, x);
        update(k2, m, r, ql, qr, x);
    }
    tr[k] = zz[k] ? r - l : r - l == 1 ? 0 : tr[k1] + tr[k2];
}

int main() {
    int n, m, h, i, j, x1, y1, x2, y2, y;
    long long ans;
    struct V tmp;
    
    init_rand();
    scanf(""%d"", &n);
    m = 0;
    for (i = 0; i < n; i++) {
        struct V *v;
        
        scanf(""%d%d%d%d"", &x1, &y1, &x2, &y2), x1 += Z, y1 += Z, x2 += Z, y2 += Z;
        v = &vv[m++];
        v->y = y1, v->l = x1, v->r = x2, v->add = 1;
        v = &vv[m++];
        v->y = y2, v->l = x1, v->r = x2, v->add = 0;
    }
    for (j = 0; j < m; j++) {
        i = rand_(j + 1);
        tmp = vv[i], vv[i] = vv[j], vv[j] = tmp;
    }
    qsort(vv, m, sizeof *vv, compare);
    y = -1;
    ans = 0;
    for (h = 0; h < m; h++) {
        struct V *v = &vv[h];
        
        if (y != -1)
            ans += (long long) (v->y - y) * tr[0];
        y = v->y;
        update(0, 0, A, v->l, v->r, v->add ? 1 : -1);
    }
    printf(""%lld\n"", ans);
    return 0;
}
"
Bit Inversions,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

string s;
int m;
multiset<int> ans,ret;

void modify(int x) {
    if (x == 0 || x == sz(s)) return;
    if (ans.count(x)) {
        auto it = ans.find(x);
        int a = *prev(it), b = *next(it);
        ret.erase(ret.find(x-a)), ret.erase(ret.find(b-x));
        ret.insert(b-a);
        ans.erase(it);
    } else {
        ans.insert(x);
        auto it = ans.find(x);
        int a = *prev(it), b = *next(it);
        ret.erase(ret.find(b-a));
        ret.insert(x-a), ret.insert(b-x);
    }
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> s >> m;
    ans.insert(0);
    ans.insert(sz(s));
    F0R(i,sz(s)-1) if (s[i] != s[i+1]) ans.insert(i+1);
    for (auto it = ans.begin(); next(it) != ans.end(); it ++)
        ret.insert(*next(it)-*it);
    
    F0R(i,m) {
        int x; cin >> x;
        modify(x-1); modify(x);
        cout << *ret.rbegin() << "" "";
    }
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Bit Inversions,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

set<int> b;
multiset<int> d;

void rem(int x) {
    auto p=b.find(x);
    int L=*prev(p), R=*next(p);
    d.erase(d.find(x-L));
    d.erase(d.find(R-x));
    d.insert(R-L);
    b.erase(x);
}

void add(int x) {
    auto p=b.insert(x).first;
    int L=*prev(p), R=*next(p);
    if (d.find(R-L)==d.end()) cout << ""??\n"" << endl;
    d.erase(d.find(R-L));
    d.insert(x-L);
    d.insert(R-x);
    b.insert(x);
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    string s;
    cin >> s;
    int n=sz(s);
    vi x(n+2);
    x[0]=x[n+1]=-1;
    rep(i, 0, n) x[i+1]=s[i]-'0';
    rep(i, 0, n+1) if (x[i]!=x[i+1]) {
        if (sz(b)) d.insert(i-*b.rbegin());
        b.insert(i);
    }
    int q;
    cin >> q;
    while (q--) {
        int a;
        cin >> a;
        if (x[a]==x[a+1]) add(a);
        if (x[a]==x[a-1]) add(a-1);
        x[a]^=1;
        if (x[a]==x[a+1]) rem(a);
        if (x[a]==x[a-1]) rem(a-1);
        cout << *d.rbegin() << "" \n""[q==0];
    }
    return 0;
}
"
Bit Inversions,Java,"// practice with rainboy
// https://cses.fi/problemset/task/1188
// Bit Inversions
import java.io.*;
import java.util.*;

public class CSES1188 {
    static char[] cc;
    static int[] pp, qq, tr;
    static void pull(int k, int l, int r) {
        int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        pp[k] = pp[k1];
        if (pp[k1] == m - l && cc[l] == cc[m])
            pp[k] += pp[k2];
        qq[k] = qq[k2];
        if (qq[k2] == r - m && cc[r - 1] == cc[m - 1])
            qq[k] += qq[k1];
        tr[k] = Math.max(tr[k1], tr[k2]);
        if (cc[m - 1] == cc[m])
            tr[k] = Math.max(tr[k], qq[k1] + pp[k2]);
    }
    static void build(int k, int l, int r) {
        if (r - l == 1) {
            pp[k] = qq[k] = tr[k] = 1;
            return;
        }
        int m = (l + r) / 2;
        build(k * 2 + 1, l, m);
        build(k * 2 + 2, m, r);
        pull(k, l, r);
    }
    static void update(int k, int l, int r, int i) {
        if (r - l == 1) {
            cc[i] = cc[i] == '0' ? '1' : '0';
            return;
        }
        int m = (l + r) / 2;
        if (i < m)
            update(k * 2 + 1, l, m, i);
        else
            update(k * 2 + 2, m, r, i);
        pull(k, l, r);
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        cc = br.readLine().toCharArray();
        int n = cc.length;
        int m = 1;
        while (m < n)
            m *= 2;
        pp = new int[m * 2];
        qq = new int[m * 2];
        tr = new int[m * 2];
        build(0, 0, n);
        m = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        StringBuilder sb = new StringBuilder();
        while (m-- > 0) {
            int i = Integer.parseInt(st.nextToken()) - 1;
            update(0, 0, n, i);
            sb.append(tr[0] + "" "");
        }
        System.out.println(sb);
    }
}
"
Bit Inversions,C++,"/*
 practice with Dukkha
 https://cses.fi/problemset/task/1188
 Bit Inversions
 */
#include <stdio.h>
#include <string.h>

#define N    200000
#define M    (1 << 18)    /* M = pow2(ceil(log2(N))) */

int max(int a, int b) { return a > b ? a : b; }

char cc[N + 1];
int pp[M * 2], qq[M * 2], tr[M * 2];

void pull(int k, int l, int r) {
    int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
    
    pp[k] = pp[k1];
    if (pp[k1] == m - l && cc[l] == cc[m])
        pp[k] += pp[k2];
    qq[k] = qq[k2];
    if (qq[k2] == r - m && cc[r - 1] == cc[m - 1])
        qq[k] += qq[k1];
    tr[k] = max(tr[k1], tr[k2]);
    if (cc[m - 1] == cc[m])
        tr[k] = max(tr[k], qq[k1] + pp[k2]);
}

void build(int k, int l, int r) {
    int m;
    
    if (r - l == 1) {
        pp[k] = qq[k] = tr[k] = 1;
        return;
    }
    m = (l + r) / 2;
    build(k * 2 + 1, l, m);
    build(k * 2 + 2, m, r);
    pull(k, l, r);
}

void update(int k, int l, int r, int i) {
    int m;
    
    if (r - l == 1) {
        cc[i] = cc[i] == '0' ? '1' : '0';
        return;
    }
    m = (l + r) / 2;
    if (i < m)
        update(k * 2 + 1, l, m, i);
    else
        update(k * 2 + 2, m, r, i);
    pull(k, l, r);
}

int main() {
    int n, m;
    
    scanf(""%s%d"", cc, &m);
    n = strlen(cc);
    build(0, 0, n);
    while (m--) {
        int i;
        
        scanf(""%d"", &i), i--;
        update(0, 0, n, i);
        printf(""%d "", tr[0]);
    }
    printf(""\n"");
    return 0;
}
"
Bit Problem,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,ans[MX][3], dp[1<<20];
vi x;

void sos(vi v) {
    F0R(i,1<<20) dp[i] = 0;
    trav(t,v) dp[t]++;
    F0R(j,20) F0R(i,1<<20) if (i&(1<<j)) dp[i] += dp[i^(1<<j)];
}

int main() {
    setIO(); re(n); x.resz(n); re(x);
    sos(x);
    F0R(i,n) {
        int t = x[i];
        ans[i][0] = dp[t];
        ans[i][2] = n-dp[((1<<20)-1)^t];
    }
    vi X = x; trav(t,X) t ^= ((1<<20)-1);
    sos(X);
    F0R(i,n) {
        int t = x[i];
        ans[i][1] = dp[((1<<20)-1)^t];
    }
    F0R(i,n) {
        F0R(j,3) pr(ans[i][j],' ');
        ps();
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Bit Problem,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int B=20;
    constexpr int M=1<<B;
    auto rev=[&](int a) {
        return (~a)&(M-1);
    };
    int n;
    cin >> n;
    vi x(n), a(M), b(M);
    rep(i, 0, n) {
        cin >> x[i];
        a[x[i]]++;
        b[rev(x[i])]++;
    }
    rep(j, 0, B) rep(i, 0, M)
    if (i&(1<<j)) {
        a[i]+=a[i^(1<<j)];
        b[i]+=b[i^(1<<j)];
    }
    trav(i, x) {
        cout << a[i] << "" "" << b[rev(i)] << "" "";
        cout << (n-a[rev(i)]) << '\n';
    }
    return 0;
}
"
Bit Problem,Java,"// https://cses.fi/problemset/task/1654
// Bit Problem
// practice with rainboy
import java.io.*;

public class CSES1654 extends PrintWriter {
    CSES1654() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1654 c = new CSES1654(); c.main(); c.flush();
    }
    
    static final int K = 20, A = 1 << K;
    void main() {
        int n = sc.nextInt();
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = sc.nextInt();
        int[] dp = new int[A];
        int[] dq = new int[A];
        for (int i = 0; i < n; i++) {
            int a = aa[i];
            dp[a]++;
            dq[a]++;
        }
        for (int h = 0; h < K; h++)
            for (int a = 0; a < A; a++)
                if ((a & 1 << h) != 0)
                    dp[a] += dp[a ^ 1 << h];
                else
                    dq[a] += dq[a ^ 1 << h];
        for (int i = 0; i < n; i++) {
            int a = aa[i];
            println(dp[a] + "" "" + dq[a] + "" "" + (n - dp[a ^ A - 1]));
        }
    }
}
"
Bit Problem,C++,"/*
 https://cses.fi/problemset/task/1654
 Bit Problem
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define K    20    /* K = ceil(log2(A)) */
#define A    (1 << K)

int main() {
    static int aa[N], dp[A], dq[A];
    int n, h, i, a;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    for (i = 0; i < n; i++) {
        a = aa[i];
        dp[a]++;
        dq[a]++;
    }
    for (h = 0; h < K; h++)
        for (a = 0; a < A; a++)
            if (a & 1 << h)
                dp[a] += dp[a ^ 1 << h];
            else
                dq[a] += dq[a ^ 1 << h];
    for (i = 0; i < n; i++) {
        a = aa[i];
        printf(""%d %d %d\n"", dp[a], dq[a], n - dp[a ^ A - 1]);
    }
    return 0;
}
"
Book Shop II,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int n,x,h[100],s[100], k[100], bes[100001];

void ad(int a, int b) {
    F0Rd(j,x-a+1) bes[j+a] = max(bes[j+a],bes[j]+b);
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> x;
    F0R(i,n) cin >> h[i];
    F0R(i,n) cin >> s[i];
    F0R(i,n) cin >> k[i];
    F0R(i,n) {
        int t = 1;
        while (k[i] >= t) {
            ad(t*h[i],t*s[i]);
            k[i] -= t; t *= 2;
        }
        if (k[i] > 0) ad(k[i]*h[i],k[i]*s[i]);
    }
    cout << bes[x];
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Book Shop II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, x;
    cin >> n >> x;
    vi h(n), s(n), c(n);
    rep(i, 0, n) cin >> h[i];
    rep(i, 0, n) cin >> s[i];
    rep(i, 0, n) cin >> c[i];
    vi dp(x+1);
    vector<pii> q(x+1);
    rep(i, 0, n) rep(j, 0, min(x+1, h[i])) {
        int L=0, R=0;
        for(int k=j, u=0; k<=x; k+=h[i], u++) {
            pii p(dp[k]-u*s[i], u);
            while(R>L && q[R-1]<p) R--;
            q[R++]=p;
            if(q[L].second==u-c[i]-1) L++;
            dp[k]=q[L].first+u*s[i];
        }
    }
    cout << *max_element(all(dp)) << '\n';
    return 0;
}
"
Book Shop II,C++,"// https://cses.fi/problemset/task/1159
// Book Shop II
// practice with rainboy
#include <iostream>

using namespace std;

const int X = 100000, N = 100;

int dp_[X + 1], dq_[X + 1], *dp = dp_, *dq = dq_;

int hh[N], ss[N], kk[N];

int main() {
    int n, x;
    scanf(""%d%d"", &n, &x);
    for (int i = 0; i < n; i++)
        scanf(""%d"", &hh[i]);
    for (int i = 0; i < n; i++)
        scanf(""%d"", &ss[i]);
    for (int i = 0; i < n; i++)
        scanf(""%d"", &kk[i]);
    for (int i = 0; i < n; i++) {
        int h = hh[i], s = ss[i], k = kk[i];
        for (int r = 0; r < h; r++) {
            static int qq[X + 1];
            int head = 0, cnt = 0;
            for (int v = r; v <= x; v += h) {
                int y = dp[v] - v / h * s, u, k_;
                while (cnt) {
                    u = qq[head + cnt - 1];
                    if (y < dp[u] - u / h * s)
                        break;
                    cnt--;
                }
                qq[head + cnt++] = v;
                u = qq[head];
                k_ = (v - u) / h;
                dq[v] = dp[u] + k_ * s;
                if (k_ == k)
                    head++, cnt--;
            }
        }
        auto tmp = dp; dp = dq; dq = tmp;
    }
    printf(""%d\n"", dp[x]);
    return 0;
}
"
Book Shop II,C++,"/*
 https://cses.fi/problemset/task/1159
 Book Shop II
 practice with Dukkha
 */
#include <stdio.h>

#define N    100
#define X    100000

int dp_[X + 1], dq_[X + 1], *dp = dp_, *dq = dq_, hh[N], ss[N], kk[N];

int main() {
    int n, x, i;
    
    scanf(""%d%d"", &n, &x);
    for (i = 0; i < n; i++)
        scanf(""%d"", &hh[i]);
    for (i = 0; i < n; i++)
        scanf(""%d"", &ss[i]);
    for (i = 0; i < n; i++)
        scanf(""%d"", &kk[i]);
    for (i = 0; i < n; i++) {
        int *tmp, h = hh[i], s = ss[i], k = kk[i], k_, r, u, v;
        
        for (r = 0; r < h; r++) {
            static int qq[X + 1];
            int head = 0, cnt = 0;
            
            for (v = r; v <= x; v += h) {
                int y = dp[v] - v / h * s;
                
                while (cnt) {
                    u = qq[head + cnt - 1];
                    if (y < dp[u] - u / h * s)
                        break;
                    cnt--;
                }
                qq[head + cnt++] = v;
                u = qq[head];
                k_ = (v - u) / h;
                dq[v] = dp[u] + k_ * s;
                if (k_ == k)
                    head++, cnt--;
            }
        }
        tmp = dp, dp = dq, dq = tmp;
    }
    printf(""%d\n"", dp[x]);
    return 0;
}
"
Chess Tournament,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n;
priority_queue<pi> pq;
vpi game;

int main() {
    setIO(); re(n);
    FOR(i,1,n+1) {
        int x; re(x);
        if (x) pq.push({x,i});
    }
    while (sz(pq)) {
        auto a = pq.top(); pq.pop();
        vpi v;
        F0R(i,a.f) {
            if (!sz(pq)) {
                ps(""IMPOSSIBLE"");
                exit(0);
            }
            v.pb(pq.top()); pq.pop();
        }
        trav(t,v) {
            game.pb({a.s,t.s});
            if (t.f > 1) pq.push({t.f-1,t.s});
        }
    }
    ps(sz(game));
    trav(t,game) ps(t.f,t.s);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Chess Tournament,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vi x(n+1);
    set<pii, greater<pii>> e;
    rep(i, 1, n+1) {
        cin >> x[i];
        if (x[i]<0) {
            cout << ""IMPOSSIBLE\n"";
            return 0;
        }
        if (x[i]>0) e.insert({x[i], i});
    }
    vector<pii> ans;
    while (sz(e)) {
        auto p=e.begin();
        int g=p->first, w=p->second;
        vi op;
        rep(i, 0, g) {
            p++;
            if(p==end(e)) {
                cout << ""IMPOSSIBLE\n"";
                return 0;
            }
            op.push_back(p->second);
        }
        e.erase({x[w], w});
        trav(i, op) {
            ans.push_back({w, i});
            e.erase({x[i], i});
            x[i]--;
            if (x[i]>0) e.insert({x[i], i});
        }
    }
    cout << sz(ans) << '\n';
    trav(p, ans) cout << p.first << "" "" << p.second << '\n';
    return 0;
}
"
Chess Tournament,Java,"// https://cses.fi/problemset/task/1697
// Chess Tournament
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1697 extends PrintWriter {
    CSES1697() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1697 c = new CSES1697(); c.main(); c.flush();
    }
    
    static class V {
        V next;
        int i;
        V(int i) {
            this.i = i;
        }
    }
    static class L {
        L next;
        V head, tail;
        int d, k;
        L(int d) {
            this.d = d;
        }
        void push(V v) {
            if (k == 0)
                head = tail = v;
            else {
                v.next = head; head = v;
            }
            k++;
        }
        V pop() {
            V v = head;
            head = head.next;
            if (head == null)
                tail = null;
            k--;
            return v;
        }
    }
    L cut(L a, int k) {
        L b = new L(a.d);
        b.k = k; a.k -= k;
        b.tail = b.head = a.head;
        while (--k > 0)
            b.tail = b.tail.next;
        a.head = b.tail.next; b.tail.next = null;
        if (a.head == null)
            a.tail = null;
        L c = a.next; a.next = b; b.next = c;
        return b;
    }
    void join(L a) {
        L b = a.next;
        while (b != null && a.d == b.d) {
            if (b.k > 0) {
                a.k += b.k;
                a.tail.next = b.head;
                a.tail = b.tail;
            }
            b = b.next;
        }
        a.next = b;
    }
    int[] ee;
    int m;
    void add(int i, L l) {
        for (V v = l.head; v != null; v = v.next) {
            ee[m++] = i; ee[m++] = v.i;
        }
    }
    void main() {
        int n = sc.nextInt();
        L[] ll = new L[n];
        V[] vv = new V[n];
        m = 0;
        for (int i = 0; i < n; i++) {
            int d = sc.nextInt();
            if (d >= n) {
                println(""IMPOSSIBLE"");
                return;
            }
            m += d;
            if (ll[d] == null)
                ll[d] = new L(d);
            ll[d].push(vv[i] = new V(i + 1));
        }
        ee = new int[m];
        m = 0;
        L l = null;
        for (int d = 0; d < n; d++)
            if (ll[d] != null) {
                ll[d].next = l; l = ll[d];
            }
        L l_ = l;
        while ((l = l_) != null) {
            if (l.k == 0) {
                l_ = l.next;
                continue;
            }
            int i = l.pop().i, d = l.d;
            while (d > 0) {
                if (l == null || l.d == 0) {
                    println(""IMPOSSIBLE"");
                    return;
                }
                if (l.k > 0) {
                    join(l);
                    if (l.k > d)
                        l = cut(l, d);
                    add(i, l); l.d--; d -= l.k;
                }
                l = l.next;
            }
        }
        println(m / 2);
        while (m > 0) {
            println(ee[m - 1] + "" "" + ee[m - 2]);
            m -= 2;
        }
    }
}
"
Chess Tournament,C++,"/*
 https://cses.fi/problemset/task/1697
 Chess Tournament
 practice with Dukkha
 */
#include <stdio.h>

#define N    100000
#define M    200000

struct V {
    struct V *next;
    int i;
} vv[N];

struct L {
    struct L *next;
    struct V *head, *tail;
    int d, k;
} ll[N + 1];

void push(struct L *l, struct V *v) {
    if (l->k == 0)
        l->head = l->tail = v;
    else
        v->next = l->head, l->head = v;
    l->k++;
}

struct V *pop(struct L *l) {
    struct V *v = l->head;
    
    l->head = l->head->next;
    if (l->head == NULL)
        l->tail = NULL;
    l->k--;
    return v;
}

struct L *cut(struct L *a, int k) {
    static struct L l91[N], *b = l91;
    struct L *c;
    
    b->d = a->d;
    b->k = k; a->k -= k;
    b->tail = b->head = a->head;
    while (--k)
        b->tail = b->tail->next;
    a->head = b->tail->next; b->tail->next = NULL;
    if (a->head == NULL)
        a->tail = NULL;
    c = a->next; a->next = b; b->next = c;
    return b++;
}

void join(struct L *a) {
    struct L *b = a->next;
    
    while (b && a->d == b->d) {
        if (b->k) {
            a->k += b->k;
            a->tail->next = b->head;
            a->tail = b->tail;
        }
        b = b->next;
    }
    a->next = b;
}

int ee[M], m;

void add(int i, struct L *l) {
    struct V *v;
    
    for (v = l->head; v; v = v->next)
        ee[m++] = i, ee[m++] = v->i;
}

int main() {
    int n, i, d;
    struct L *l, *l_;
    
    scanf(""%d"", &n);
    for (d = 0; d <= n; d++)
        ll[d].d = d;
    for (i = 0; i < n; i++) {
        int d;
        
        scanf(""%d"", &d);
        if (d >= n) {
            printf(""IMPOSSIBLE\n"");
            return 0;
        }
        vv[i].i = i + 1;
        push(&ll[d], &vv[i]);
    }
    l = NULL;
    for (d = 0; d < n; d++)
        if (ll[d].k)
            ll[d].next = l, l = &ll[d];
    l_ = l;
    while ((l = l_)) {
        if (l->k == 0) {
            l_ = l->next;
            continue;
        }
        i = pop(l)->i, d = l->d;
        while (d > 0) {
            if (l == NULL || l->d == 0) {
                printf(""IMPOSSIBLE\n"");
                return 0;
            }
            if (l->k) {
                join(l);
                if (l->k > d)
                    l = cut(l, d);
                add(i, l); l->d--; d -= l->k;
            }
            l = l->next;
        }
    }
    printf(""%d\n"", m / 2);
    while (m) {
        printf(""%d %d\n"", ee[m - 1], ee[m - 2]);
        m -= 2;
    }
    return 0;
}
"
Coding Company,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,x;
array<mi,10001> dp[51], DP[51];

void process(int x) {
    F0R(i,51) F0R(j,10001) if ((int)dp[i][j]) {
        if (i+1 <= 50) DP[i+1][j-x] += dp[i][j];
        DP[i][j] += (i+1)*dp[i][j];
        if (i) DP[i-1][j+x] += i*dp[i][j];
    }
    F0R(i,51) {
        swap(dp[i],DP[i]);
        F0R(j,10001) DP[i][j] = 0;
    }
}

int main() {
    setIO(); re(n,x);
    vi t(n); re(t); sort(all(t));
    dp[0][5000] = 1;
    // ps(t);
    trav(a,t) process(a);
    mi ret(0);
    FOR(i,5000,5000+x+1) ret += dp[0][i];
    ps(ret);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Coding Company,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr int N=101;
constexpr int X=5001;
constexpr int P=1e9+7;
int dp[2][N][X], t[N];

void add(int &a, int b) {
    a+=b;
    if(a>=P) a-=P;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, x;
    cin >> n >> x;
    rep(i, 0, n) cin >> t[i];
    sort(t, t+n);
    int c=0, p=1;
    dp[p][0][0]=1;
    rep(i, 0, n) {
        rep(y, 0, x+1) rep(k, 0, i+1)
        dp[c][k][y]=0;
        rep(k, 0, i+1) {
            int d=(i? k*(t[i]-t[i-1]) : 0);
            rep(y, 0, x+1-d) if (dp[p][k][y]) {
                int val=dp[p][k][y];
                add(dp[c][k][y+d], val);
                add(dp[c][k+1][y+d], val);
                val=1LL*val*k%P;
                if (k) add(dp[c][k-1][y+d], val);
                add(dp[c][k][y+d], val);
            }
        }
        swap(c, p);
    }
    int ans=0;
    rep(y, 0, x+1) add(ans, dp[p][0][y]);
    cout << ans << '\n';
    return 0;
}
"
Coding Company,Java,"// https://cses.fi/problemset/task/1665
// Coding Company
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1665 extends PrintWriter {
    CSES1665() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1665 o = new CSES1665(); o.main(); o.flush();
    }
    
    static final int MD = 1000000007;
    void main() {
        int n = sc.nextInt();
        int x = sc.nextInt();
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = sc.nextInt();
        aa = Arrays.stream(aa).boxed().sorted((a, b) -> b - a).mapToInt($->$).toArray();
        int h = n / 2, y = 0;
        for (int i = 0; i < h; i++)
            y += aa[i];
        int[][] dp = new int[h + 1][y + 1];
        int[][] dq = new int[h + 1][y + 1];
        dp[0][0] = 1;
        for (int i = 0; i < n; i++) {
            for (int t = 0; t <= h; t++)
                for (int b = 0; b <= y; b++)
                    dq[t][b] = 0;
            int a = aa[i];
            for (int t = 0; t <= h; t++)
                for (int b = 0; b <= y; b++) {
                    int p = dp[t][b];
                    if (p == 0)
                        continue;
                    if (t + 1 <= h)
                        dq[t + 1][b + a] = (dq[t + 1][b + a] + p) % MD;
                    if (t - 1 >= 0)
                        dq[t - 1][b - a] = (int) ((dq[t - 1][b - a] + (long) p * t) % MD);
                    dq[t][b] = (int) ((dq[t][b] + (long) p * (t + 1)) % MD);
                }
            int[][] tmp = dp; dp = dq; dq = tmp;
        }
        int sum = 0;
        for (int b = 0; b <= x && b <= y; b++)
            sum = (sum + dp[0][b]) % MD;
        println(sum);
    }
}
"
Coding Company,C++,"/*
 https://cses.fi/problemset/task/1665
 Coding Company
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>

#define N    100
#define Y    5000
#define MD    1000000007

int compare(const void *a, const void *b) {
    int ia = *(int *) a;
    int ib = *(int *) b;
    
    return ib - ia;
}

int main() {
    static int aa[N], dp[N / 2 + 1][Y + 1], dq[N / 2 + 1][Y + 1];
    int n, h, x, i, t, a, b, p, sum;
    
    scanf(""%d%d"", &n, &x);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    qsort(aa, n, sizeof *aa, compare);
    h = n / 2;
    dp[0][0] = 1;
    for (i = 0; i < n; i++) {
        for (t = 0; t <= h; t++)
            for (b = 0; b <= Y; b++)
                dq[t][b] = 0;
        a = aa[i];
        for (t = 0; t <= h; t++)
            for (b = 0; b <= Y; b++) {
                p = dp[t][b];
                if (p == 0)
                    continue;
                if (t + 1 <= h)
                    dq[t + 1][b + a] = (dq[t + 1][b + a] + p) % MD;
                if (t - 1 >= 0)
                    dq[t - 1][b - a] = (dq[t - 1][b - a] + (long long) p * t) % MD;
                dq[t][b] = (dq[t][b] + (long long) p * (t + 1)) % MD;
            }
        for (t = 0; t <= h; t++)
            for (b = 0; b <= Y; b++)
                dp[t][b] = dq[t][b];
    }
    sum = 0;
    for (b = 0; b <= x; b++)
        sum = (sum + dp[0][b]) % MD;
    printf(""%d\n"", sum);
    return 0;
}
"
Coin Grid,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<int SZ> struct Dinic {
    struct Edge { int v, rev; ll flow, cap; };
    
    vector<Edge> adj[SZ];
    
    void addEdge(int u, int v, ll cap) {
        Edge a{v, sz(adj[v]), 0, cap}, b{u, sz(adj[u]), 0, 0};
        adj[u].pb(a), adj[v].pb(b);
    }
    
    int ST, EN, level[SZ], ind[SZ];
    
    bool bfs() { // level = shortest distance from source
        // after computing flow, edges {u,v} such that level[u] \neq -1, level[v] = -1 are part of min cut
        F0R(i,SZ) level[i] = -1, ind[i] = 0;
        level[ST] = 0;
        
        queue<int> q; q.push(ST);
        while (sz(q)) {
            int u = q.front(); q.pop();
            trav(e,adj[u]) if (level[e.v] < 0 && e.flow < e.cap) {
                level[e.v] = level[u] + 1;
                q.push(e.v);
            }
        }
        
        return level[EN] >= 0;
    }
    
    ll sendFlow(int s, ll flow) {
        if (s == EN) return flow;
        
        for (  ; ind[s] < sz(adj[s]); ind[s] ++) {
            Edge& e = adj[s][ind[s]];
            
            if (level[e.v] != level[s]+1 || e.flow == e.cap) continue;
            ll f = sendFlow(e.v, min(flow, e.cap - e.flow));
            
            if (f) { // saturate at least one edge
                e.flow += f; adj[e.v][e.rev].flow -= f;
                return f;
            }
        }
        
        return 0;
    }
    
    ll maxFlow(int _ST, int _EN) {
        ST = _ST, EN = _EN;
        if (ST == EN) return -1;
        ll tot = 0;
        while (bfs()) while (auto flow = sendFlow(ST, LLONG_MAX)) tot += flow;
        return tot;
    }
};

Dinic<202> D;
int n;

int main() {
    setIO();  re(n);
    F0R(i,n) {
        D.addEdge(0,i+1,1);
        D.addEdge(i+1+n,2*n+1,1);
        F0R(j,n) {
            char c; re(c);
            if (c == 'o') {
                D.addEdge(i+1,j+1+n,MOD);
            }
        }
    }
    ps(D.maxFlow(0,2*n+1));
    D.bfs();
    trav(t,D.adj[0]) if (D.level[t.v] < 0) ps(1,t.v);
    FOR(i,n+1,2*n+1) trav(t,D.adj[i]) if (t.v == 2*n+1 && D.level[i] >= 0) ps(2,i-n);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Coin Grid,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

bool find(int j, vector<vi>& g, vi& btoa, vi& vis) {
    if (btoa[j] == -1) return 1;
    vis[j] = 1; int di = btoa[j];
    trav(e, g[di])
    if (!vis[e] && find(e, g, btoa, vis)) {
        btoa[e] = di;
        return 1;
    }
    return 0;
}
int dfsMatching(vector<vi>& g, vi& btoa) {
    vi vis;
    rep(i,0,sz(g)) {
        vis.assign(sz(btoa), 0);
        trav(j,g[i])
        if (find(j, g, btoa, vis)) {
            btoa[j] = i;
            break;
        }
    }
    return sz(btoa) - (int)count(all(btoa), -1);
}

vi cover(vector<vi>& g, int n, int m) {
    vi match(m, -1);
    int res = dfsMatching(g, match);
    vector<bool> lfound(n, true), seen(m);
    trav(it, match) if (it != -1) lfound[it] = false;
    vi q, cover;
    rep(i,0,n) if (lfound[i]) q.push_back(i);
    while (!q.empty()) {
        int i = q.back(); q.pop_back();
        lfound[i] = 1;
        trav(e, g[i]) if (!seen[e] && match[e] != -1) {
            seen[e] = true;
            q.push_back(match[e]);
        }
    }
    rep(i,0,n) if (!lfound[i]) cover.push_back(i);
    rep(i,0,m) if (seen[i]) cover.push_back(n+i);
    assert(sz(cover) == res);
    return cover;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vector<vi> g(n);
    string s;
    rep(i, 0, n) {
        cin >> s;
        rep(j, 0, n) if (s[j]=='o') g[i].push_back(j);
    }
    vi r=cover(g, n, n);
    cout << sz(r) << '\n';
    trav(i, r)
    cout << i/n+1 << "" "" << i%n+1 << '\n';
    return 0;
}
"
Coin Grid,Java,"// https://cses.fi/problemset/task/1709
// Coin Grid
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1709 extends PrintWriter {
    CSES1709() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
        int m = 1 << 7; byte[] cc = new byte[m];
        int read() {
            byte c = 0; while (c <= 32) c = getc();
            int n = 0;
            while (c > 32) {
                if (n == m) cc = Arrays.copyOf(cc, m <<= 1);
                cc[n++] = c; c = getc();
            }
            return n;
        }
        byte[] nextBytes() { int n = read(); return Arrays.copyOf(cc, n); }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1709 o = new CSES1709(); o.main(); o.flush();
    }
    
    ArrayList[] aa;
    int[] qq, dd, vv, uu;
    boolean bfs(int n) {
        int head = 0, cnt = 0;
        dd[0] = n;
        for (int u = 1; u <= n; u++)
            if (vv[u] == 0) {
                dd[u] = 0;
                qq[head + cnt++] = u;
            } else
                dd[u] = n;
        while (cnt > 0) {
            int u = qq[head++]; cnt--;
            int d = dd[u] + 1;
            ArrayList<Integer> adj = aa[u];
            for (int v : adj) {
                int w = uu[v];
                if (dd[w] == n) {
                    dd[w] = d;
                    if (w == 0)
                        return true;
                    qq[head + cnt++] = w;
                }
            }
        }
        return false;
    }
    boolean dfs(int u, int n) {
        if (u == 0)
            return true;
        int d = dd[u] + 1;
        ArrayList<Integer> adj = aa[u];
        for (int v : adj) {
            int w = uu[v];
            if (dd[w] == d && dfs(w, n)) {
                vv[u] = v; uu[v] = u;
                return true;
            }
        }
        dd[u] = n;
        return false;
    }
    int hopcroft_karp(int n, int n_) {
        qq = new int[n];
        dd = new int[n + 1];
        vv = new int[n + 1];
        uu = new int[n_ + 1];
        int m = 0;
        while (bfs(n))
            for (int u = 1; u <= n; u++)
                if (vv[u] == 0 && dfs(u, n))
                    m++;
        return m;
    }
    void main() {
        int n = sc.nextInt();
        int n_ = n;
        aa = new ArrayList[n + 1];
        for (int u = 1; u <= n; u++) {
            aa[u] = new ArrayList<Integer>();
            byte[] cc = sc.nextBytes();
            for (int v = 1; v <= n_; v++)
                if (cc[v - 1] == 'o')
                    aa[u].add(v);
        }
        println(hopcroft_karp(n, n_));
        for (int u = 1; u <= n; u++) {
            if (vv[u] == 0)
                continue;
            if (dd[u] == n)
                println(""1 "" + u);
            else
                println(""2 "" + vv[u]);
        }
    }
}
"
Coin Grid,C++,"/*
 https://cses.fi/problemset/task/1709
 Coin Grid
 practice with Dukkha
 */
#include <stdio.h>

#define N    100

struct L {
    struct L *next;
    int v;
} aa[N + 1];

void link(int u, int v) {
    static struct L l91[N * N], *l = l91;
    
    l->v = v;
    l->next = aa[u].next, aa[u].next = l++;
}

int dd[N + 1], vv[N + 1], uu[N + 1];

int bfs(int n) {
    static int qq[N];
    int u, head, cnt, d;
    
    head = cnt = 0;
    dd[0] = n;
    for (u = 1; u <= n; u++)
        if (vv[u] == 0) {
            dd[u] = 0;
            qq[head + cnt++] = u;
        } else
            dd[u] = n;
    while (cnt) {
        struct L *l;
        
        u = qq[cnt--, head++];
        d = dd[u] + 1;
        for (l = aa[u].next; l; l = l->next) {
            int v = l->v, w = uu[v];
            
            if (dd[w] == n) {
                dd[w] = d;
                if (w == 0)
                    return 1;
                qq[head + cnt++] = w;
            }
        }
    }
    return 0;
}

int dfs(int u, int n) {
    struct L *l;
    int d;
    
    if (u == 0)
        return 1;
    d = dd[u] + 1;
    for (l = aa[u].next; l; l = l->next) {
        int v = l->v, w = uu[v];
        
        if (dd[w] == d && dfs(w, n)) {
            vv[u] = v, uu[v] = u;
            return 1;
        }
    }
    dd[u] = n;
    return 0;
}

int hopcroft_karp(int n) {
    int u, m = 0;
    
    while (bfs(n))
        for (u = 1; u <= n; u++)
            if (vv[u] == 0 && dfs(u, n))
                m++;
    return m;
}

int main() {
    static char s[N + 1];
    int n, u, v;
    
    scanf(""%d"", &n);
    for (u = 1; u <= n; u++) {
        scanf(""%s"", s);
        for (v = 1; v <= n; v++)
            if (s[v - 1] == 'o')
                link(u, v);
    }
    printf(""%d\n"", hopcroft_karp(n));
    for (u = 1; u <= n; u++) {
        if (vv[u] == 0)
            continue;
        if (dd[u] == n)
            printf(""1 %d\n"", u);
        else
            printf(""2 %d\n"", vv[u]);
    }
    return 0;
}
"
Counting Bits,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

ll n, ans;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n;
    F0R(i,50) {
        ll tmp = 1LL<<i;
        ans += (n/(2*tmp))*tmp;
        ll t = n % (2*tmp);
        if (t >= tmp) ans += t-tmp+1;
    }
    cout << ans;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Counting Bits,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int B=60;
    ll n, ans=0;
    cin >> n;
    n++;
    rep(b, 0, B) {
        ans+=(n>>(b+1))<<b;
        ans+=min(n%(1LL<<(b+1)), 1LL<<b);
    }
    cout << n*B-ans << '\n';
    return 0;
}
"
Counting Bits,Java,"// https://cses.fi/problemset/task/1146
// Counting Bits
import java.io.*;

public class CSES1146 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        long n = Long.parseLong(br.readLine());
        long cnt = 0;
        for (int i = 0; 1L << i <= n; i++) {
            cnt += n >> i + 1 << i;
            if ((n & 1L << i) != 0)
                cnt += (n & (1L << i) - 1) + 1;
        }
        System.out.println(cnt);
    }
}
"
Counting Bits,C++,"/*
 https://cses.fi/problemset/task/1146
 Counting Bits
 */
#include <stdio.h>

int main() {
    long long n, ans;
    int i;
    
    scanf(""%lld"", &n);
    ans = 0;
    for (i = 0; 1LL << i <= n; i++) {
        ans += n >> (i + 1) << i;
        if (n & 1LL << i)
            ans += (n & (1LL << i) - 1) + 1;
    }
    printf(""%lld\n"", ans);
    return 0;
}
"
Course Schedule II,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,m,out[MX];
vi radj[MX];

int main() {
    setIO(); re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        radj[b].pb(a);
        out[a] ++;
    }
    vi ans;
    priority_queue<int> pq;
    FOR(i,1,n+1) if (!out[i]) pq.push(i);
    while (sz(pq)) {
        int x = pq.top(); pq.pop(); ans.pb(x);
        trav(t,radj[x]) {
            out[t] --;
            if (!out[t]) pq.push(t);
        }
    }
    reverse(all(ans));
    trav(t,ans) pr(t,' ');
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Course Schedule II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vi topo_sort(const vector<vi>& gr) {
    vi indeg(sz(gr)), ret;
    trav(li, gr) trav(x, li) indeg[x]++;
    priority_queue<int> q;
    rep(i,0,sz(gr)) if (indeg[i] == 0) q.push(i);
    while (!q.empty()) {
        int i = q.top();
        ret.push_back(i);
        q.pop();
        trav(x, gr[i])
        if (--indeg[x] == 0) q.push(x);
    }
    return ret;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<vi> g(n);
    while (m--) {
        int a, b;
        cin >> a >> b;
        g[b-1].push_back(a-1);
    }
    vi r=topo_sort(g);
    rep(i, 0, n) cout << r[n-1-i]+1 << "" \n""[i==n-1];
    return 0;
}
"
Course Schedule II,Java,"// https://cses.fi/problemset/task/1757
// Course Schedule II
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1757 extends PrintWriter {
    CSES1757() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1757 o = new CSES1757(); o.main(); o.flush();
    }
    
    void main() {
        int n = sc.nextInt();
        int m = sc.nextInt();
        ArrayList[] aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        int[] dd = new int[n];
        while (m-- > 0) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            aa[j].add(i);
            dd[i]++;
        }
        TreeSet<Integer> pq = new TreeSet<>((i, j) -> i - j);
        for (int i = 0; i < n; i++)
            if (dd[i] == 0)
                pq.add(i);
        int[] stack = new int[n];
        n = 0;
        Integer last;
        while ((last = pq.pollLast()) != null) {
            int i = last;
            stack[n++] = i;
            ArrayList<Integer> adj = aa[i];
            for (int j : adj)
                if (--dd[j] == 0)
                    pq.add(j);
        }
        while (n-- > 0)
            print(stack[n] + 1 + "" "");
        println();
    }
}
"
Course Schedule II,C++,"/*
 https://cses.fi/problemset/task/1757
 Course Schedule II
 practice with Dukkha
 */
#include <stdio.h>

#define N    100000
#define M    200000

#define LT(u, v) ((u) > (v))

int pq[1 + N], iq[N], cnt;

int i2(int i) {
    return (i *= 2) > cnt ? 0 : i < cnt && LT(pq[i + 1], pq[i]) ? i + 1 : i;
}

void pq_up(int u) {
    int i, j;
    
    for (i = iq[u]; (j = i / 2) && LT(u, pq[j]); i = j)
        pq[iq[pq[j]] = i] = pq[j];
    pq[iq[u] = i] = u;
}

void pq_dn(int u) {
    int i, j;
    
    for (i = iq[u]; (j = i2(i)) && LT(pq[j], u); i = j)
        pq[iq[pq[j]] = i] = pq[j];
    pq[iq[u] = i] = u;
}

void pq_add(int u) {
    iq[u] = ++cnt;
    pq_up(u);
}

int pq_remove_first() {
    int u = pq[1], v = pq[cnt--];
    
    iq[v] = 1;
    pq_dn(v);
    return u;
}

struct L {
    struct L *next;
    int j;
} aa[N];

void link(int i, int j) {
    static struct L l91[M], *l = l91;
    
    l->j = j;
    l->next = aa[i].next, aa[i].next = l++;
}

int main() {
    static int dd[N], stack[N];
    int n, m, i, j, k;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(j, i), dd[i]++;
    }
    for (i = 0; i < n; i++)
        if (dd[i] == 0)
            pq_add(i);
    k = 0;
    while (cnt) {
        struct L *l;
        
        stack[k++] = i = pq_remove_first();
        for (l = aa[i].next; l; l = l->next)
            if (--dd[j = l->j] == 0)
                pq_add(l->j);
    }
    while (k--)
        printf(""%d "", stack[k] + 1);
    printf(""\n"");
    return 0;
}
"
Creating Offices,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,d;
vi adj[MX], dp[MX], stor[MX];

vi ins(vi a) {
    a.pb(a.back());
    return a;
}

void comb(int A, vi b) {
    vi& a = dp[A]; assert(sz(a) >= sz(b));
    // >= d/2:
    int lo = (d+1)/2;
    FOR(i,max(d-sz(b)+1,0),min(lo,sz(a))) {
        assert(i < sz(a) && d-i < sz(b));
        a[sz(a)-1-i] += b[sz(b)-1-(d-i)];
    }
    FOR(i,max(d-sz(a)+1,0),min(lo,sz(b))) b[sz(b)-1-i] += a[sz(a)-1-(d-i)]; // 0 <= d-i < sz(a)
    FOR(i,lo,sz(b)) a[sz(a)-1-i] += b[sz(b)-1-i];
    F0Rd(i,sz(b)) {
        ckmax(a[sz(a)-1-i],b[sz(b)-1-i]);
        if (i+1 < sz(a)) ckmax(a[sz(a)-1-i],a[sz(a)-1-(i+1)]);
    }
    // < d/2
}

void dfs(int a, int b) {
    if (b) adj[a].erase(find(all(adj[a]),b));
    trav(t,adj[a]) dfs(t,a);
    FOR(i,1,sz(adj[a])) if (sz(dp[adj[a][i]]) > sz(dp[adj[a][0]])) swap(adj[a][0],adj[a][i]);
    if (sz(adj[a])) {
        swap(dp[a],dp[adj[a][0]]); dp[a].pb(dp[a].back());
        comb(a,{1});
        FOR(i,1,sz(adj[a])) {
            int z = sz(dp[adj[a][i]]);
            stor[adj[a][i]] = vi(dp[a].end()-z-1,dp[a].end());
            comb(a,ins(dp[adj[a][i]]));
        }
    } else dp[a] = {1};
    //ps(""??"",a,dp[a]);
    // ps(a,b,adj[a],dp[a]);
}

void dfs2(int a, int ind);

void solve(int A, int B, int& ind) {
    if (ind < 0) return;
    int val = dp[A][ind];
    F0R(i,sz(stor[B])) swap(dp[A][sz(dp[A])-1-i],stor[B][sz(stor[B])-1-i]);
    const vi& a = dp[A]; const vi b = ins(dp[B]);
    
    if (a[ind] == val) return;
    if (b[sz(b)-(sz(a)-ind)] == val) {
        ind = -1; dfs2(B,sz(b)-(sz(a)-ind));
        return;
    }
    int lo = (d+1)/2; int zz = sz(b)-(sz(a)-ind);
    if (sz(a)-1-ind >= lo && a[ind]+(zz >= 0 ? b[zz] : 0) >= val) {
        assert(a[ind]+(zz >= 0 ? b[zz] : 0) == val);
        dfs2(B,zz); return;
    }
    
    // ps(""WUT"",A,B,ind,sz(a)-1-ind,val); exit(0);
    FOR(i,max(d-sz(b)+1,0),min(lo,sz(a))) {
        if (sz(a)-1-i <= ind && a[sz(a)-1-i]+b[sz(b)-1-(d-i)] >= val) {
            ind = sz(a)-1-i; dfs2(B,sz(b)-1-(d-i));
            return;
        }
    }
    FOR(i,max(d-sz(a)+1,0),min(lo,sz(b))) {
        if (sz(b)-1-i <= ind && b[sz(b)-1-i]+a[sz(a)-1-(d-i)] >= val) {
            ind = sz(a)-1-(d-i); dfs2(B,sz(b)-1-i);
            return;
        }
    }
    ps(""OOPS"",ind,val,A,B,a,b);
    exit(0);
    exit(5);
}

void dumb(int a, int ind) {
    ckmin(ind,sz(dp[a])-1);
    if (ind < 0) return;
    if (ind == sz(dp[a])-1) {
        if (ind < d || dp[a][ind-d]+1 != dp[a][ind]) {
            ps(""??"",ind,d,dp[a],dp[a][ind-1],dp[a][ind]);
            exit(0);
        }
        ps(a); ind -= d;
    }
    dp[a].pop_back(); swap(dp[adj[a][0]],dp[a]);
    dfs2(adj[a][0],ind);
}

void dfs2(int a, int ind) {
    ckmin(ind,sz(dp[a])-1);
    if (ind < 0) return;
    if (sz(adj[a]) == 0) { ps(a); return; }
    // ps(""HA"",a,ind,dp[a]);
    FORd(i,1,sz(adj[a])) {
        while (ind > 0 && dp[a][ind-1] == dp[a][ind]) ind --;
        solve(a,adj[a][i],ind);
    }
    while (ind > 0 && dp[a][ind-1] == dp[a][ind]) ind --;
    dumb(a,ind);
    // swap(dp[a],dp[adj[a][0]]); dp[a].pb(dp[a].back()); comb(dp[a],{1});
}

int main() {
    setIO(); re(n,d);
    F0R(i,n-1) {
        int a,b; re(a,b);
        adj[a].pb(b), adj[b].pb(a);
    }
    dfs(1,0);
    ps(dp[1].back());
    dfs2(1,sz(dp[1])-1);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Creating Offices,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef pair<ll, ll> pll;

int n, d;
vector<vi> g, dp, dpw;
vi t, e, ew, ans;

void dfsSmall(int i, int p) {
    trav(j, g[i]) if (j!=p)
        dfsSmall(j, i);
    rep(k, 0, d) t[k]=0;
    trav(j, g[i]) if (j!=p) rep(k, 0, d)
        t[k]+=dp[j][k];
    dp[i][0]=1+t[d-1];
    trav(j, g[i]) if (j!=p) rep(k, 0, d-1) {
        int c=max(k, d-k-2);
        dp[i][k+1]=max(dp[i][k+1],
                       dp[j][k]+t[c]-dp[j][c]);
    }
    for(int k=d-1; k>0; k--)
        dp[i][k-1]=max(dp[i][k-1], dp[i][k]);
}

void recSmall(int i, int p, int f) {
    rep(k, 0, d) t[k]=0;
    trav(j, g[i]) if (j!=p) rep(k, 0, d)
        t[k]+=dp[j][k];
    int s=0, ds=0, dc=d-1;
    if (f==0 && dp[i][0]==1+t[d-1])
        ans.push_back(i);
    else {
        trav(j, g[i]) if (j!=p) rep(k, max(f-1, 0), d-1) {
            int c=max(k, d-k-2);
            if (dp[i][f]==dp[j][k]+t[c]-dp[j][c]) {
                s=j, ds=k, dc=c;
                goto out1;
            }
        }
    }
out1:
    trav(j, g[i]) if (j!=p)
        recSmall(j, i, (j==s? ds:dc));
}

void solveSmall() {
    dp.assign(n+1, vi(d));
    t.resize(d);
    dfsSmall(1, 0);
    recSmall(1, 0, 0);
}

void dfsLarge(int i, int p) {
    trav(j, g[i]) if (j!=p)
        dfsLarge(j, i);
    t.clear();
    trav(j, g[i]) if (j!=p)
        t.insert(end(t), all(dp[j]));
    sort(all(t));
    e.assign(sz(t)+3, -1);
    ew.assign(sz(t)+3, -1);
    auto tail=[&](int k, vi& a) {
        return end(a)-lower_bound(all(a), k);
    };
    e[1+tail(d-1, t)]=0;
    ew[1+tail(d-1, t)]=-1;
    trav(j, g[i]) if (j!=p) rep(k, 0, sz(dp[j])) {
        int c=max(dp[j][k], d-dp[j][k]-2);
        int x=sz(dp[j])-k + tail(c, t)-tail(c, dp[j]);
        if (e[x]<dp[j][k]+1)
            e[x]=dp[j][k]+1, ew[x]=j+(n+1)*k;
        if (2*dp[j][k]+2>=d) break;
    }
    int m=sz(e)-2;
    while(e[m]<0) m--;
    dp[i].reserve(m);
    dpw[i].reserve(m);
    for(int k=m; k>0; k--) {
        if (e[k]<e[k+1])
            e[k]=e[k+1], ew[k]=ew[k+1];
        if (e[k]>=0) {
            dp[i].push_back(e[k]);
            dpw[i].push_back(ew[k]);
        }
    }
}

void recLarge(int i, int p, int f) {
    int k=lower_bound(all(dp[i]), f)-begin(dp[i]);
    if (k==sz(dp[i])) return;
    int s=0, ds=0, dc=d-1, val=dpw[i][k];
    if (val==-1)
        ans.push_back(i);
    else {
        s=val%(n+1);
        ds=dp[s][val/(n+1)];
        dc=max(ds, d-ds-2);
    }
    trav(j, g[i]) if (j!=p)
        recLarge(j, i, (j==s? ds:dc));
}

void solveLarge() {
    dp.assign(n+1, vi());
    dpw.assign(n+1, vi());
    e.reserve(n);
    dfsLarge(1, 0);
    recLarge(1, 0, 0);
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int D=400;
    cin >> n >> d;
    g.resize(n+1);
    rep(i, 0, n-1) {
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    if (d<D) solveSmall();
    else solveLarge();
    cout << sz(ans) << '\n';
    rep(i, 0, sz(ans))
    cout << ans[i] << "" \n""[i==sz(ans)-1];
    return 0;
}
"
Creating Offices,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef pair<ll, ll> pll;

constexpr int inf=1e9;
int n, d;
vector<vi> g;
vi lvl, h, s, ans;

void dfs(int i, int p, int clvl) {
    lvl[i]=clvl;
    h[i]=inf;
    s[i]=i;
    trav(j, g[i]) if(j!=p) {
        dfs(j, i, clvl+1);
        if (s[j]) {
            if ((lvl[s[j]]-lvl[i])*2>=d)
                ans.push_back(s[j]), h[j]=lvl[s[j]];
            else if(lvl[s[j]]>lvl[s[i]])
                s[i]=s[j];
        }
        h[i]=min(h[i], h[j]);
    }
    if (lvl[s[i]]+h[i]-2*lvl[i]<d)
        s[i]=0;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    cin >> n >> d;
    g.resize(n+1);
    lvl.resize(n+1);
    h.resize(n+1);
    s.resize(n+1);
    rep(i, 0, n-1) {
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    dfs(1, 0, 0);
    if (s[1]) ans.push_back(s[1]);
    cout << sz(ans) << '\n';
    rep(i, 0, sz(ans))
    cout << ans[i] << "" \n""[i==sz(ans)-1];
    return 0;
}
"
Creating Offices,Java,"// https://cses.fi/problemset/task/1752
// Creating Offices
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1752 extends PrintWriter {
    CSES1752() { super(System.out); }
    byte[] __; int $;
    { try { __ = System.in.readAllBytes(); } catch (IOException e) {} }
    int nextInt() {
        while ($ < __.length && __[$] <= 32) $++;
        int a = 0;
        while ($ < __.length && __[$] > 32) a = a * 10 + __[$++] - '0';
        return a;
    }
    public static void main(String[] $) {
        CSES1752 o = new CSES1752(); o.main(); o.flush();
    }
    
    static final int INF = 0x3f3f3f3f;
    ArrayList[] aa;
    boolean[] used;
    int[] cc, dd, dd_;
    int lambda;
    void dfs(int p, int i, int d) {
        dd[i] = d;
        ArrayList<Integer> adj = aa[i];
        int d_ = INF, c_ = -1;
        for (int j : adj)
            if (j != p) {
                dfs(i, j, d + 1);
                d_ = Math.min(d_, dd_[j]);
                int c = cc[j];
                if (c == -1)
                    continue;
                if ((dd[c] - d) * 2 >= lambda) {
                    used[c] = true;
                    d_ = Math.min(d_, dd[c]);
                } else if (c_ == -1 || dd[c_] < dd[c])
                    c_ = c;
            }
        dd_[i] = d_;
        if (c_ != -1 && dd[c_] - d + d_ - d < lambda)
            c_ = -1;
        if (c_ == -1 && d_ - d >= lambda)
            c_ = i;
        cc[i] = c_;
    }
    void main() {
        int n = nextInt();
        lambda = nextInt();
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        for (int h = 0; h < n - 1; h++) {
            int i = nextInt() - 1;
            int j = nextInt() - 1;
            aa[i].add(j);
            aa[j].add(i);
        }
        cc = new int[n];
        dd = new int[n];
        dd_ = new int[n];
        used = new boolean[n];
        dfs(-1, 0, 0);
        if (cc[0] != -1)
            used[cc[0]] = true;
        int k = 0;
        for (int i = 0; i < n; i++)
            if (used[i])
                k++;
        println(k);
        for (int i = 0; i < n; i++)
            if (used[i])
                print(i + 1 + "" "");
        println();
    }
}
"
Creating Offices,Java,"// https://cses.fi/problemset/task/1752
// Creating Offices
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1752 extends PrintWriter {
    CSES1752() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1752 o = new CSES1752(); o.main(); o.flush();
    }
    
    static final int INF = 0x3f3f3f3f;
    ArrayList[] aa;
    boolean[] used;
    int[] cc, dd, dd_;
    int lambda;
    void dfs(int p, int i, int d) {
        dd[i] = d;
        ArrayList<Integer> adj = aa[i];
        int d_ = INF, c_ = -1;
        for (int j : adj)
            if (j != p) {
                dfs(i, j, d + 1);
                d_ = Math.min(d_, dd_[j]);
                int c = cc[j];
                if (c == -1)
                    continue;
                if ((dd[c] - d) * 2 >= lambda) {
                    used[c] = true;
                    d_ = Math.min(d_, dd[c]);
                } else if (c_ == -1 || dd[c_] < dd[c])
                    c_ = c;
            }
        dd_[i] = d_;
        if (c_ != -1 && dd[c_] - d + d_ - d < lambda)
            c_ = -1;
        if (c_ == -1 && d_ - d >= lambda)
            c_ = i;
        cc[i] = c_;
    }
    void main() {
        int n = sc.nextInt();
        lambda = sc.nextInt();
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        for (int h = 0; h < n - 1; h++) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            aa[i].add(j);
            aa[j].add(i);
        }
        cc = new int[n];
        dd = new int[n];
        dd_ = new int[n];
        used = new boolean[n];
        dfs(-1, 0, 0);
        if (cc[0] != -1)
            used[cc[0]] = true;
        int k = 0;
        for (int i = 0; i < n; i++)
            if (used[i])
                k++;
        println(k);
        for (int i = 0; i < n; i++)
            if (used[i])
                print(i + 1 + "" "");
        println();
    }
}
"
Creating Offices,C++,"// https://cses.fi/problemset/task/1752
// Creating Offices
// practice with rainboy
#include <iostream>
#include <vector>

using namespace std;

const int INF = 0x3f3f3f3f, N = 200000;

vector<int> aa[N];
bool used[N];
int cc[N], dd[N], dd_[N], lambda;

void dfs(int p, int i, int d) {
    dd[i] = d;
    int d_ = INF, c_ = -1;
    for (int j : aa[i])
        if (j != p) {
            dfs(i, j, d + 1);
            d_ = min(d_, dd_[j]);
            int c = cc[j];
            if (c == -1)
                continue;
            if ((dd[c] - d) * 2 >= lambda) {
                used[c] = true;
                d_ = min(d_, dd[c]);
            } else if (c_ == -1 || dd[c_] < dd[c])
                c_ = c;
        }
    dd_[i] = d_;
    if (c_ != -1 && dd[c_] - d + d_ - d < lambda)
        c_ = -1;
    if (c_ == -1 && d_ - d >= lambda)
        c_ = i;
    cc[i] = c_;
}

int main() {
    int n;
    scanf(""%d%d"", &n, &lambda);
    for (int h = 0; h < n - 1; h++) {
        int i, j;
        scanf(""%d%d"", &i, &j), i--, j--;
        aa[i].push_back(j);
        aa[j].push_back(i);
    }
    dfs(-1, 0, 0);
    if (cc[0] != -1)
        used[cc[0]] = true;
    int k = 0;
    for (int i = 0; i < n; i++)
        if (used[i])
            k++;
    printf(""%d\n"", k);
    for (int i = 0; i < n; i++)
        if (used[i])
            printf(""%d "", i + 1);
    printf(""\n"");
    return 0;
}
"
Creating Offices,C++,"/*
 https://cses.fi/problemset/task/1752
 Creating Offices
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define INF    0x3f3f3f3f

struct L {
    struct L *next;
    int j;
} aa[N];

void link(int i, int j) {
    static struct L l91[N * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next, aa[i].next = l++;
}

char used[N];
int cc[N], dd[N], dd_[N], lambda;

void dfs(int p, int i, int d) {
    struct L *l;
    int j, c, c_, d_;
    
    dd[i] = d;
    d_ = INF;
    for (l = aa[i].next; l; l = l->next)
        if ((j = l->j) != p) {
            dfs(i, j, d + 1);
            if (d_ > dd_[j])
                d_ = dd_[j];
            c = cc[j];
            if (c != -1 && (dd[c] - d) * 2 >= lambda) {
                used[c] = 1;
                if (d_ > dd[c])
                    d_ = dd[c];
            }
        }
    dd_[i] = d_;
    c_ = -1;
    for (l = aa[i].next; l; l = l->next)
        if ((j = l->j) != p) {
            c = cc[j];
            if (c != -1 && !used[c] && (c_ == -1 || dd[c_] < dd[c]))
                c_ = c;
        }
    if (c_ != -1 && dd[c_] - d + d_ - d < lambda)
        c_ = -1;
    if (c_ == -1 && d_ - d >= lambda)
        c_ = i;
    cc[i] = c_;
}

int main() {
    int n, h, i, j, k;
    
    scanf(""%d%d"", &n, &lambda);
    for (h = 0; h < n - 1; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), link(j, i);
    }
    dfs(-1, 0, 0);
    if (cc[0] != -1)
        used[cc[0]] = 1;
    k = 0;
    for (i = 0; i < n; i++)
        if (used[i])
            k++;
    printf(""%d\n"", k);
    for (i = 0; i < n; i++)
        if (used[i])
            printf(""%d "", i + 1);
    printf(""\n"");
    return 0;
}
"
Creating Offices,C++,"/*
 https://cses.fi/problemset/task/1752
 Creating Offices
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define INF    0x3f3f3f3f

struct L {
    struct L *next;
    int j;
} aa[N];

void link(int i, int j) {
    static struct L l91[N * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next, aa[i].next = l++;
}

char used[N];
int cc[N], dd[N], dd_[N], lambda;

void dfs(int p, int i, int d) {
    struct L *l;
    int j, c, c_, d_;
    
    dd[i] = d;
    d_ = INF, c_ = -1;
    for (l = aa[i].next; l; l = l->next)
        if ((j = l->j) != p) {
            dfs(i, j, d + 1);
            if (d_ > dd_[j])
                d_ = dd_[j];
            c = cc[j];
            if (c == -1)
                continue;
            if ((dd[c] - d) * 2 >= lambda) {
                used[c] = 1;
                if (d_ > dd[c])
                    d_ = dd[c];
            } else if (c_ == -1 || dd[c_] < dd[c])
                c_ = c;
        }
    if (c_ != -1 && dd[c_] - d + d_ - d < lambda)
        c_ = -1;
    if (c_ == -1 && d_ - d >= lambda)
        c_ = i;
    dd_[i] = d_;
    cc[i] = c_;
}

int main() {
    int n, h, i, j, k;
    
    scanf(""%d%d"", &n, &lambda);
    for (h = 0; h < n - 1; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), link(j, i);
    }
    dfs(-1, 0, 0);
    if (cc[0] != -1)
        used[cc[0]] = 1;
    k = 0;
    for (i = 0; i < n; i++)
        if (used[i])
            k++;
    printf(""%d\n"", k);
    for (i = 0; i < n; i++)
        if (used[i])
            printf(""%d "", i + 1);
    printf(""\n"");
    return 0;
}
"
Critical Cities,C++,"// equivalent to USACO sweetgrass :o

#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;

template<class T> using Tree = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;

typedef pair<int,int> pi;
typedef vector<pi> vpi;
typedef vector<int> vi;

#define F0R(i,a) for (int i = 0; i < a; ++i)
#define F0Rd(i,a) for (int i = a-1; i >= 0; --i)
#define FOR(i,a,b) for (int i = a; i < b; ++i)

#define all(a) a.begin(), a.end()
#define sz(a) int((a).size())
#define lb lower_bound
#define ub upper_bound
#define pb push_back
#define mp make_pair
#define f first
#define s second

const int MOD = 1000000007;
const int MX = 100001;

int N,M, pre[MX], nex[MX], bad[MX], pos[MX];
vi adj[MX], radj[MX];

void gen(int x) {
    for (int i: adj[x]) if (!pre[i] && i != 1) {
        pre[i] = x;
        gen(i);
    }
}

void dfsPre(int x, int y) {
    for (int i: radj[x]) if (!nex[i]) {
        nex[i] = y;
        if (!bad[i]) dfsPre(i,y);
    }
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> N >> M;
    F0R(i,M) {
        // int a = rand() % N+1,b = rand() % N+1;
        int a,b; cin >> a >> b;
        if (a == b) continue;
        adj[a].pb(b); radj[b].pb(a);
    }
    gen(1);
    vi al;
    for (int x = N; x; x = pre[x]) {
        bad[x] = 1;
        al.pb(x);
    }
    reverse(all(al));
    F0Rd(i,sz(al)) {
        int x = al[i];
        pos[x] = i+1;
        dfsPre(x,x);
    }
    
    int bes = 0;
    vi ans;
    F0R(I,sz(al)-2) {
        int i = al[I];
        bes = max(bes,pos[nex[i]]);
        if (bes <= pos[al[I+1]]) ans.pb(al[I+1]);
    }
    ans.pb(1), ans.pb(N);
    cout << sz(ans) << ""\n"";
    sort(all(ans));
    for (int i: ans) cout << i << "" "";
}
"
Critical Cities,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int n, r;
vector<vi> g(n+1);
vi d, p;

int dfs1(int i) {
    d[i]=1;
    p.push_back(i);
    if(i==n) return 1;
    trav(j, g[i])
    if (!d[j] && dfs1(j)) return 1;
    p.pop_back();
    return 0;
}

void dfs2(int i) {
    d[i]=r;
    trav(j, g[i]) {
        r=max(r, d[j]);
        if (d[j]==-1) dfs2(j);
    }
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int m;
    cin >> n >> m;
    g.resize(n+1);
    while (m--) {
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
    }
    d.resize(n+1);
    dfs1(1);
    d.assign(n+1, -1);
    vi ans;
    m=sz(p);
    rep(i, 0, m) d[p[i]]=i;
    rep(i, 0, m) {
        if (r<=i)
            ans.push_back(p[i]);
        dfs2(p[i]);
    }
    
    
    sort(all(ans));
    m=sz(ans);
    cout << m << '\n';
    rep(i, 0, m)
    cout << ans[i] << "" \n""[i==m-1];
    return 0;
}
"
Critical Cities,Java,"// https://cses.fi/problemset/task/1703
// Critical Cities
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1703 extends PrintWriter {
    CSES1703() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1703 o = new CSES1703(); o.main(); o.flush();
    }
    
    ArrayList[] aa;
    int[] stack, dd;
    int cnt, n, d_;
    boolean dfs(int i, int d) {
        if (dd[i] < n)
            return false;
        dd[i] = d;
        if (i == n - 1) {
            stack[cnt++] = i;
            return true;
        }
        ArrayList<Integer> adj = aa[i];
        for (int j : adj)
            if (dfs(j, d + 1)) {
                stack[cnt++] = i;
                return true;
            }
        return false;
    }
    void dfs2(int i) {
        if (dd[i] < n) {
            if (d_ < dd[i])
                d_ = dd[i];
            return;
        }
        dd[i] = -1;
        ArrayList<Integer> adj = aa[i];
        for (int j : adj)
            dfs2(j);
    }
    void main() {
        n = sc.nextInt();
        int m = sc.nextInt();
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        while (m-- > 0) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            aa[i].add(j);
        }
        dd = new int[n];
        Arrays.fill(dd, n);
        stack = new int[n];
        dfs(0, 0);
        Arrays.fill(dd, n);
        for (int h = 0; h < cnt; h++) {
            int i = stack[h];
            dd[i] = cnt - 1 - h;
        }
        ArrayList<Integer> cc = new ArrayList<>();
        for (int h = cnt - 1; h >= 0; h--) {
            int i = stack[h];
            if (dd[i] == d_)
                cc.add(i);
            dd[i] = n;
            dfs2(i);
        }
        println(cc.size());
        Collections.sort(cc);
        for (int i : cc)
            print(i + 1 + "" "");
        println();
    }
}
"
Critical Cities,C++,"/*
 https://cses.fi/problemset/task/1703
 Critical Cities
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>

#define N    100000
#define M    200000

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

struct L {
    struct L *next;
    int j;
} aa[N];

int stack[N], dd[N], cnt, n;

void link(int i, int j) {
    static struct L l91[M], *l = l91;
    
    l->j = j;
    l->next = aa[i].next, aa[i].next = l++;
}

int dfs(int i, int d) {
    struct L *l;
    
    if (dd[i] < n)
        return 0;
    dd[i] = d;
    if (i == n - 1) {
        stack[cnt++] = i;
        return 1;
    }
    for (l = aa[i].next; l; l = l->next)
        if (dfs(l->j, d + 1)) {
            stack[cnt++] = i;
            return 1;
        }
    return 0;
}

int d_;

void dfs2(int i) {
    struct L *l;
    
    if (dd[i] < n) {
        if (d_ < dd[i])
            d_ = dd[i];
        return;
    }
    dd[i] = -1;
    for (l = aa[i].next; l; l = l->next)
        dfs2(l->j);
}

int compare(const void *a, const void *b) {
    int ia = *(int *) a;
    int ib = *(int *) b;
    
    return ia - ib;
}

int main() {
    static int cc[N];
    int m, h, i, j, k, tmp;
    
    init_rand();
    scanf(""%d%d"", &n, &m);
    for (h = 0; h < m; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j);
    }
    for (i = 0; i < n; i++)
        dd[i] = n;
    dfs(0, 0);
    for (i = 0; i < n; i++)
        dd[i] = n;
    for (h = 0; h < cnt; h++) {
        i = stack[h];
        dd[i] = cnt - 1 - h;
    }
    d_ = 0;
    k = 0;
    for (h = cnt - 1; h >= 0; h--) {
        i = stack[h];
        if (dd[i] == d_)
            cc[k++] = i;
        dd[i] = n;
        dfs2(i);
    }
    for (j = 0; j < k; j++) {
        i = rand_(j + 1);
        tmp = cc[i], cc[i] = cc[j], cc[j] = tmp;
    }
    qsort(cc, k, sizeof *cc, compare);
    printf(""%d\n"", k);
    for (i = 0; i < k; i++)
        printf(""%d "", cc[i] + 1);
    printf(""\n"");
    return 0;
}
"
Cyclic Array,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

ll n, k, sum;
int x[1000000], nex[20][1000000], ans = MOD;

int get(int z) {
    int cur = 0;
    int Z = z;
    F0Rd(i,20) {
        if (nex[i][Z] < z+n) {
            Z = nex[i][Z];
            cur ^= (1<<i);
        }
    }
    return cur+1;
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> k;
    F0R(i,n) {
        cin >> x[i];
        x[i+n] = x[i];
    }
    int sum = 0, r = -1;
    F0R(i,2*n) {
        while (r < 2*n-2 && sum+x[r+1] <= k) sum += x[++r];
        nex[0][i] = r+1;
        sum -= x[i];
    }
    FOR(i,1,20) F0R(j,2*n) nex[i][j] = nex[i-1][nex[i-1][j]];
    F0R(i,n) ans = min(ans,get(i));
    cout << ans;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Cyclic Array,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int B=20;
    ll n, k;
    cin >> n >> k;
    vector<ll> x(2*n);
    rep(i, 0, n) {
        cin >> x[i];
        x[i+n]=x[i];
    }
    if (accumulate(all(x), 0LL)<=2*k) {
        cout << ""1\n"";
        return 0;
    }
    vector<vector<ll>> p(n, vector<ll>(B));
    ll j=0, s=0;
    rep(i, 0, n) {
        while (s<=k) s+=x[j++];
        p[i][0]=j-i-1;
        s-=x[i];
    }
    rep(b, 1, B) rep(i, 0, n) {
        ll d=p[i][b-1];
        p[i][b]=d+p[(i+d)%n][b-1];
    }
    ll ans=n;
    rep(i, 0, n) {
        ll j=0, s=0;
        for(int b=B-1; b>=0; b--)
            if (s+p[(i+s)%n][b]<n)
                s+=p[(i+s)%n][b], j+=1<<b;
        ans=min(ans, j+1);
    }
    cout << ans << '\n';
    return 0;
}
"
Cyclic Array,Java,"// https://cses.fi/problemset/task/1191
// Cyclic Array
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1191 {
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        long b = sc.nextLong();
        long[] aa = new long[1 + n + n];
        for (int i = 1; i <= n; i++)
            aa[n + i] = aa[i] = sc.nextInt();
        for (int i = 1; i <= n + n; i++)
            aa[i] += aa[i - 1];
        int l = 0;
        while (1 << l + 1 <= n)
            l++;
        int[][] pp = new int[l + 1][1 + n + n];
        for (int i = 1, j = 1; i <= n + n; i++) {
            while (j < n + n && aa[j] - aa[i - 1] <= b)
                j++;
            pp[0][i] = j;
        }
        for (int k = 1; k <= l; k++)
            for (int i = 1; i <= n + n; i++)
                pp[k][i] = pp[k - 1][pp[k - 1][i]];
        int ans = n;
        for (int i = 1; i <= n; i++) {
            int cnt = 1;
            int j = i;
            for (int k = l; k >= 0; k--)
                if (pp[k][j] < i + n) {
                    j = pp[k][j];
                    cnt += 1 << k;
                }
            ans = Math.min(ans, cnt);
        }
        System.out.println(ans);
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb); //if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
        long nextLong() throws IOException {
            long n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Cyclic Array,Java,"// https://cses.fi/problemset/task/1191
// Cyclic Array
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1191 {
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        long b = sc.nextLong();
        long[] aa = new long[1 + n + n];
        for (int i = 1; i <= n; i++)
            aa[n + i] = aa[i] = sc.nextInt();
        for (int i = 1; i <= n + n; i++)
            aa[i] += aa[i - 1];
        int l = 0;
        while (1 << l + 1 <= n)
            l++;
        int[][] pp = new int[l + 1][1 + n + n];
        for (int i = 1, j = 1; i <= n + n; i++) {
            while (j < n + n && aa[j] - aa[i - 1] <= b)
                j++;
            pp[0][i] = j;
        }
        for (int k = 1; k <= l; k++)
            for (int i = 1; i <= n + n; i++)
                pp[k][i] = pp[k - 1][pp[k - 1][i]];
        int ans = n;
        for (int i = 1; i <= n; i++) {
            int cnt = 1;
            int j = i;
            for (int k = l; k >= 0; k--)
                if (pp[k][j] < i + n) {
                    j = pp[k][j];
                    cnt += 1 << k;
                }
            ans = Math.min(ans, cnt);
        }
        System.out.println(ans);
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
        long nextLong() throws IOException {
            long n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Cyclic Array,C++,"/*
 https://cses.fi/problemset/task/1191
 Cyclic Array
 practice with Dukkha
 */
#include <stdio.h>

#define N    500000
#define L    18    /* L = floor(log2(N)) */

int main() {
    static long long aa[1 + N + N];
    static int pp[L + 1][1 + N + N];
    int n, i, j, k, l, ans, cnt;
    long long b;
    
    scanf(""%d%lld"", &n, &b);
    for (i = 1; i <= n; i++) {
        scanf(""%lld"", &aa[i]);
        aa[i + n] = aa[i];
    }
    for (i = 1; i <= n + n; i++)
        aa[i] += aa[i - 1];
    l = 0;
    while (1 << (l + 1) <= n)
        l++;
    for (i = 1, j = 1; i <= n + n; i++) {
        while (j < n + n && aa[j] - aa[i - 1] <= b)
            j++;
        pp[0][i] = j;
    }
    for (k = 1; k <= l; k++)
        for (i = 1; i <= n + n; i++)
            pp[k][i] = pp[k - 1][pp[k - 1][i]];
    ans = n;
    for (i = 1; i <= n; i++) {
        cnt = 1;
        j = i;
        for (k = l; k >= 0; k--)
            if (pp[k][j] < i + n) {
                j = pp[k][j];
                cnt += 1 << k;
            }
        if (ans > cnt)
            ans = cnt;
    }
    printf(""%d\n"", ans);
    return 0;
}
"
Edge Directions,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,d;

void dfs(vi& a, vl& b, int ind, ll sum) {
    if (ind == sz(a)) {
        b.pb(sum);
        return;
    }
    dfs(a,b,ind+1,sum);
    dfs(a,b,ind+1,sum+a[ind]);
}

vl gen(vi a) {
    vl b;
    dfs(a,b,0,0);
    sort(all(b));
    return b;
}

int main() {
    setIO();
    int n,m; re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        if (a > b) swap(a,b);
        ps(a,b);
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Edge Directions,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    while (m--) {
        int a, b;
        cin >> a >> b;
        if (a>b) swap(a, b);
        cout << a << "" "" << b << '\n';
    }
    return 0;
}
"
Edge Directions,Java,"// https://cses.fi/problemset/task/1756
// Edge Directions
// practice with rainboy
import java.io.*;

public class CSES1756 extends PrintWriter {
    CSES1756() { super(System.out); } byte[] __; int $;
    { try { __ = System.in.readAllBytes(); } catch (IOException e) {} }
    int nextInt() {
        while ($ < __.length && __[$] < 33) $++;
        boolean minus = __[$] == '-'; if (minus) $++;
        int a = 0;
        while ($ < __.length && __[$] > 32) a = a * 10 + __[$++] - '0';
        return minus ? -a : a;
    }
    public static void main(String[] __) { new CSES1756().main(); }
    
    void main() {
        int m = nextInt(); m = nextInt();
        while (m-- > 0) {
            int a = nextInt(), b = nextInt();
            println(a < b ? a + "" "" + b : b + "" "" + a);
        }
        flush();
    }
}
"
Edge Directions,Java,"// https://cses.fi/problemset/task/1756
// Edge Directions
// practice with rainboy
import java.io.*;

public class CSES1756 extends PrintWriter {
    CSES1756() { super(System.out); } byte[] __; int $;
    { try { __ = System.in.readAllBytes(); } catch (IOException e) {} }
    int nextInt() {
        while ($ < __.length && __[$] < 33) $++;
        int a = 0;
        while ($ < __.length && __[$] > 32) a = a * 10 + __[$++] - '0';
        return a;
    }
    public static void main(String[] __) { new CSES1756().main(); }
    
    void main() {
        int m = nextInt(); m = nextInt();
        while (m-- > 0) {
            int a = nextInt(), b = nextInt();
            println(a < b ? a + "" "" + b : b + "" "" + a);
        }
        flush();
    }
}
"
Edge Directions,C++,"/*
 https://cses.fi/problemset/task/1756
 Edge Directions
 practice with Dukkha
 */
#include <stdio.h>

int main() {
    int n, m;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        int i, j, tmp;
        
        scanf(""%d%d"", &i, &j);
        if (i > j)
            tmp = i, i = j, j = tmp;
        printf(""%d %d\n"", i, j);
    }
    return 0;
}
"
Elevator Rides,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,x;
pi dp[1<<20];
vi w;

int main() {
    setIO(); re(n,x); w.resz(n); re(w);
    FOR(i,1,1<<n) dp[i] = {MOD,MOD};
    F0R(i,1<<n) F0R(j,n) if (!(i&(1<<j))) {
        int t = dp[i].s+w[j];
        if (t <= x) {
            ckmin(dp[i^(1<<j)],{dp[i].f,t});
        } else {
            ckmin(dp[i^(1<<j)],{dp[i].f+1,w[j]});
        }
    }
    ps(dp[(1<<n)-1].f+1);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Elevator Rides,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    ll n, x;
    cin >> n >> x;
    vector<ll> a(n);
    rep(i, 0, n) cin >> a[i];
    int M=1<<n;
    vector<ll> w(M);
    rep(m, 0, M) rep(i, 0, n)
    if (m&(1<<i)) w[m]+=a[i];
    vector<ll> dp(M);
    rep(ans, 1, n+1) {
        rep(b, 0, n) rep(m, 0, M)
        if (m&(1<<b)) dp[m]=max(dp[m], dp[m^(1<<b)]);
        rep(m, 0, M)
        dp[m]=(dp[m]>=w[m]-x? w[m]:0);
        if (dp[M-1]>0) {
            cout << ans << '\n';
            return 0;
        }
    }
    return 0;
}
"
Elevator Rides,Java,"// https://cses.fi/problemset/task/1653
// Elevator Rides
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1653 extends PrintWriter {
    CSES1653() { super(System.out, true); } byte[] __; int $;
    { try { __ = System.in.readAllBytes(); } catch (IOException e) {} }
    int nextInt() {
        while ($ < __.length && __[$] < 33) $++;
        int a = 0;
        while ($ < __.length && __[$] > 32) a = a * 10 + __[$++] - '0';
        return a;
    }
    public static void main(String[] __) { new CSES1653().main(); }
    
    void main() {
        int n = nextInt();
        int x = nextInt();
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = nextInt();
        int[] dp = new int[1 << n];
        int[] dq = new int[1 << n];
        Arrays.fill(dp, n + 1);
        dp[0] = 0;
        dq[0] = x;
        for (int b = 0; b < 1 << n; b++)
            for (int i = 0; i < n; i++)
                if ((b & 1 << i) == 0) {
                    int p = dp[b], q = dq[b], a = aa[i];
                    if (q + a <= x)
                        q += a;
                    else {
                        p++;
                        q = a;
                    }
                    int b_ = b | 1 << i;
                    if (dp[b_] > p || dp[b_] == p && dq[b_] > q) {
                        dp[b_] = p; dq[b_] = q;
                    }
                }
        println(dp[(1 << n) - 1]);
    }
}
"
Elevator Rides,C++,"/*
 https://cses.fi/problemset/task/1653
 Elevator Rides
 practice with Dukkha
 */
#include <stdio.h>

#define N    20

int main() {
    static int aa[N], dp[1 << N], dq[1 << N];
    int n, x, i, b, b_, p, q, a;
    
    scanf(""%d%d"", &n, &x);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    for (b = 0; b < 1 << n; b++)
        dp[b] = n + 1;
    dp[0] = 0, dq[0] = x;
    for (b = 0; b < 1 << n; b++)
        for (i = 0; i < n; i++)
            if (!(b & 1 << i)) {
                p = dp[b], q = dq[b], a = aa[i];
                if (q + a <= x)
                    q += a;
                else {
                    p++;
                    q = a;
                }
                b_ = b | 1 << i;
                if (dp[b_] > p || (dp[b_] == p && dq[b_] > q))
                    dp[b_] = p, dq[b_] = q;
            }
    printf(""%d\n"", dp[(1 << n) - 1]);
    return 0;
}
"
Empty String,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;


template<int SZ> struct Combo {
    ll fac[SZ+1], ifac[SZ+1];
    
    Combo() {
        fac[0] = ifac[0] = 1;
        FOR(i,1,SZ+1) {
            fac[i] = i*fac[i-1] % MOD;
            ifac[i] = inv(fac[i]);
        }
    }
    
    ll po (ll b, ll p) {
        return !p?1:po(b*b%MOD,p/2)*(p&1?b:1)%MOD;
    }
    
    ll inv (ll b) { return po(b,MOD-2); }
    
    ll comb(ll a, ll b) {
        if (a < b) return 0;
        ll tmp = fac[a]*ifac[b] % MOD;
        tmp = tmp*ifac[a-b] % MOD;
        return tmp;
    }
};

string s;
int dp[501][501];
Combo<500> C;

void solve(int l, int r) {
    if ((r-l+1) % 2 == 1) return;
    for (int i = l+1; i <= r; i += 2) if (s[l] == s[i]) {
        ll t = (ll)dp[l+1][i-1]*dp[i+1][r] % MOD;
        t = t*C.comb((r-l+1)/2,(i-l+1)/2) % MOD;
        dp[l][r] += t;
        dp[l][r] %= MOD;
    }
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> s;
    FOR(i,1,sz(s)+1) dp[i][i-1] = 1;
    F0Rd(i,sz(s)) FOR(j,i,sz(s)) solve(i,j);
    cout << dp[0][sz(s)-1];
}
"
Empty String,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int P=1e9+7;
    string s;
    cin >> s;
    int n=sz(s);
    vector<vi> dp(n+1, vi(n+1));
    vector<vi> B(n, vi(n));
    rep(i, 0, n) {
        B[i][0]=1;
        rep(j, 1, i+1) B[i][j]=(B[i-1][j]+B[i-1][j-1])%P;
    }
    rep(i, 0, n+1) dp[i][i]=1;
    for(int l=2; l<=n; l+=2) rep(i, 0, n-l+1) {
        for(int k=i+1; k<i+l; k+=2) {
            if (s[k]!=s[i]) continue;
            int t=1LL*dp[i+1][k]*dp[k+1][i+l]%P;
            t=1LL*t*B[l/2][(k-i+1)/2]%P;
            dp[i][i+l]=(dp[i][i+l]+t)%P;
        }
    }
    cout << dp[0][n] << '\n';
    return 0;
}
"
Empty String,Java,"// https://cses.fi/problemset/task/1080
// Empty String
// practice with rainboy
import java.io.*;

public class CSES1080 {
    static final int MD = 1000000007;
    static int[][] ch;
    static void init(int n) {
        ch = new int[n + 1][n + 1];
        ch[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            ch[i][0] = 1;
            for (int j = 1; j <= i; j++)
                ch[i][j] = (ch[i - 1][j] + ch[i - 1][j - 1]) % MD;
        }
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        char[] cc = ("" "" + br.readLine()).toCharArray();
        int n = cc.length - 1;
        init(n / 2);
        long[][] dp = new long[n + 1][n + 1];
        for (int i = 1; i <= n; i++)
            dp[i][i - 1] = 1;
        for (int h = n; h >= 1; h--)
            for (int j = h + 1; j <= n; j += 2) {
                long x = 0;
                for (int i = h; i < j; i += 2)
                    if (cc[i] == cc[j])
                        x = (x + dp[h][i - 1] * dp[i + 1][j - 1] % MD * ch[(j - h + 1) / 2][(i - h) / 2]) % MD;
                dp[h][j] = x;
            }
        System.out.println(dp[1][n]);
    }
}
"
Empty String,C++,"/*
 https://cses.fi/problemset/task/1080
 Empty String
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    500
#define MD    1000000007

int ch[N + 1][N + 1];

void init(int n) {
    int i, j;
    
    ch[0][0] = 1;
    for (i = 1; i <= n; i++) {
        ch[i][0] = 1;
        for (j = 1; j <= i; j++)
            ch[i][j] = (ch[i - 1][j] + ch[i - 1][j - 1]) % MD;
    }
}

int main() {
    static char cc[1 + N + 1];
    static long long dp[N + 1][N + 1];
    int n, h, i, j;
    
    scanf(""%s"", cc + 1);
    n = strlen(cc + 1);
    init(n);
    for (i = 1; i <= n; i++)
        dp[i][i - 1] = 1;
    for (h = n; h >= 1; h--)
        for (j = h + 1; j <= n; j += 2) {
            long long x = 0;
            
            for (i = h; i < j; i += 2)
                if (cc[i] == cc[j])
                    x = (x + dp[h][i - 1] * dp[i + 1][j - 1] % MD * ch[(j - h + 1) / 2][(i - h) / 2]) % MD;
            dp[h][j] = x;
        }
    printf(""%lld\n"", dp[1][n]);
    return 0;
}
"
Flight Route Requests,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

queue<int> todo;

template<int SZ> struct TopoSort {
    int N, in[SZ];
    vi res, adj[SZ];
    
    void addEdge(int x, int y) {
        adj[x].pb(y), in[y] ++;
    }
    
    bool sort(int des) {
        res.clear();
        while (sz(todo)) {
            int x = todo.front(); todo.pop();
            res.pb(x);
            trav(i,adj[x]) {
                in[i] --;
                if (!in[i]) todo.push(i);
            }
        }
        return sz(res) == des;
        /*N = _N;
         FOR(i,1,N+1) if (in[i] == 0) todo.push(i);
         return sz(res) == N;*/
    }
};

template<int SZ> struct DSU {
    int par[SZ], sz[SZ];
    
    DSU() {
        F0R(i,SZ) par[i] = i, sz[i] = 1;
    }
    
    int get(int x) { // path compression
        if (par[x] != x) par[x] = get(par[x]);
        return par[x];
    }
    
    bool unite(int x, int y) { // union-by-rank
        x = get(x), y = get(y);
        if (x == y) return 0;
        if (sz[x] < sz[y]) swap(x,y);
        sz[x] += sz[y], par[y] = x;
        return 1;
    }
};

vi comp[MX];
DSU<MX> D;
TopoSort<MX> T;
int n,m;

int main() {
    setIO(); re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        D.unite(a,b); T.addEdge(a,b);
    }
    FOR(i,1,n+1) comp[D.get(i)].pb(i);
    int ans = 0;
    FOR(i,1,n+1) if (sz(comp[i])) {
        trav(t,comp[i]) if (T.in[t] == 0) todo.push(t);
        if (T.sort(sz(comp[i]))) ans += sz(comp[i])-1;
        else ans += sz(comp[i]);
    }
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Flight Route Requests,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vi val, comp, z, cont;
int Time, ncomps;
template<class G, class F> int dfs(int j, G& g, F& f) {
    int low = val[j] = ++Time, x; z.push_back(j);
    trav(e,g[j]) if (comp[e] < 0)
        low = min(low, val[e] ?: dfs(e,g,f));
    
    if (low == val[j]) {
        do {
            x = z.back(); z.pop_back();
            comp[x] = ncomps;
            cont.push_back(x);
        } while (x != j);
        f(cont); cont.clear();
        ncomps++;
    }
    return val[j] = low;
}
template<class G, class F> void scc(G& g, F f) {
    int n = sz(g);
    val.assign(n, 0); comp.assign(n, -1);
    Time = ncomps = 0;
    rep(i,0,n) if (comp[i] < 0) dfs(i, g, f);
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<vi> g(n), gu(n);
    while (m--) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        g[a].push_back(b);
        gu[a].push_back(b);
        gu[b].push_back(a);
    }
    vi bs(n);
    scc(g, [&](vi &c) {
        if (sz(c)==1) return;
        trav(i, c) bs[i]=1;
    });
    int ans=n;
    scc(gu, [&](vi &c) {
        ans--;
        trav(i, c) if (bs[i]) {
            ans++;
            return;
        }
    });
    cout << ans <<'\n';
    return 0;
}
"
Flight Route Requests,Java,"// https://cses.fi/problemset/task/1699
// Flight Route Requests
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1699 extends PrintWriter {
    CSES1699() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1699 o = new CSES1699(); o.main(); o.flush();
    }
    
    ArrayList[] aa, bb;
    int[] dd;
    boolean[] visited;
    int[] ii;
    int n_;
    void dfs(int i) {
        if (visited[i])
            return;
        visited[i] = true;
        ii[n_++] = i;
        ArrayList<Integer> adj;
        adj = aa[i];
        for (int j : adj)
            dfs(j);
        adj = bb[i];
        for (int j : adj)
            dfs(j);
    }
    int[] qq;
    boolean acyclic() {
        int head = 0, cnt = 0;
        for (int h = 0; h < n_; h++) {
            int i = ii[h];
            if (dd[i] == 0)
                qq[head + cnt++] = i;
        }
        while (cnt > 0) {
            int i = qq[head++]; cnt--;
            ArrayList<Integer> adj = aa[i];
            for (int j : adj)
                if (--dd[j] == 0)
                    qq[head + cnt++] = j;
        }
        return head == n_;
    }
    void main() {
        int n = sc.nextInt();
        int m = sc.nextInt();
        aa = new ArrayList[n];
        bb = new ArrayList[n];
        dd = new int[n];
        for (int i = 0; i < n; i++) {
            aa[i] = new ArrayList<Integer>();
            bb[i] = new ArrayList<Integer>();
        }
        for (int h = 0; h < m; h++) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            if (i == j)
                continue;
            aa[i].add(j);
            bb[j].add(i);
            dd[j]++;
        }
        visited = new boolean[n];
        ii = new int[n];
        qq = new int[n];
        int ans = n;
        for (int i = 0; i < n; i++)
            if (!visited[i]) {
                n_ = 0;
                dfs(i);
                if (acyclic())
                    ans--;
            }
        println(ans);
    }
}
"
Flight Route Requests,C++,"/*
 https://cses.fi/problemset/task/1699
 Flight Route Requests
 practice with Dukkha
 */
#include <stdio.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int j;
} aa[N], bb[N];

void link(int i, int j) {
    static struct L l91[M * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next, aa[i].next = l++;
    l->j = i;
    l->next = bb[j].next, bb[j].next = l++;
}

int dd[N];
char visited[N];
int ii[N], n_;

void dfs(int i) {
    struct L *l;
    
    if (visited[i])
        return;
    visited[i] = 1;
    ii[n_++] = i;
    for (l = aa[i].next; l; l = l->next)
        dfs(l->j);
    for (l = bb[i].next; l; l = l->next)
        dfs(l->j);
}

int acyclic() {
    static int qq[N];
    int head, cnt, h, i, j;
    
    head = cnt = 0;
    for (h = 0; h < n_; h++)
        if (dd[i = ii[h]] == 0)
            qq[head + cnt++] = i;
    while (cnt) {
        struct L *l;
        
        i = qq[cnt--, head++];
        for (l = aa[i].next; l; l = l->next)
            if (--dd[j = l->j] == 0)
                qq[head + cnt++] = j;
    }
    return head == n_;
}

int main() {
    int n, m, i, j, ans;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        if (i == j)
            continue;
        link(i, j), dd[j]++;
    }
    ans = n;
    for (i = 0; i < n; i++)
        if (!visited[i]) {
            n_ = 0;
            dfs(i);
            if (acyclic())
                ans--;
        }
    printf(""%d\n"", ans);
    return 0;
}
"
Food Division,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int n, a[500000], b[500000];
vector<ll> v;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n;
    F0R(i,n) cin >> a[i];
    F0R(i,n) {
        cin >> b[i];
        a[i] -= b[i];
    }
    ll z = 0;
    F0R(i,n) {
        v.pb(z);
        z += a[i];
    }
    sort(all(v));
    ll x = v[sz(v)/2];
    ll ans = 0;
    F0R(i,n) ans += abs(v[i]-x);
    cout << ans;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Food Division,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vector<ll> a(n), b(n),  s(n);
    rep(i, 0, n) cin >> a[i];
    rep(i, 0, n) cin >> b[i];
    rep(i, 1, n) s[i]=a[i]-b[i]+s[i-1];
    sort(all(s));
    ll ans=0;
    rep(i, 0, n) ans+=abs(s[i]-s[n/2]);
    cout << ans << '\n';
    return 0;
}
"
Food Division,C++,"// https://cses.fi/problemset/task/1189
// Food Division
// practice with rainboy
#include <algorithm>
#include <iostream>

using namespace std;

const int N = 500000;

long long aa[N];

int main() {
    int n, x;
    scanf(""%d"", &n);
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &x);
        aa[i] = x;
    }
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &x);
        aa[i] -= x;
    }
    for (int i = 1; i < n; i++)
        aa[i] += aa[i - 1];
    sort(aa, aa + n);
    long long med = aa[n / 2], ans = 0;
    for (int i = 0; i < n; i++)
        ans += abs(aa[i] - med);
    printf(""%lld\n"", ans);
    return 0;
}
"
Food Division,C++,"/*
 https://cses.fi/problemset/task/1189
 Food Division
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>

#define N    500000

int compare(const void *a, const void *b) {
    long long la = *(long long *) a;
    long long lb = *(long long *) b;
    
    return la == lb ? 0 : la < lb ? -1 : 1;
}

int main() {
    static long long aa[N];
    int n, i, x;
    long long med, ans;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++) {
        scanf(""%d"", &x);
        aa[i] = x;
    }
    for (i = 0; i < n; i++) {
        scanf(""%d"", &x);
        aa[i] -= x;
    }
    for (i = 1; i < n; i++)
        aa[i] += aa[i - 1];
    qsort(aa, n, sizeof *aa, compare);
    med = aa[n / 2];
    ans = 0;
    for (i = 0; i < n; i++)
        ans += aa[i] > med ? aa[i] - med : med - aa[i];
    printf(""%lld\n"", ans);
    return 0;
}
"
Forbidden Cities,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<int SZ> struct LCA {
    static const int BITS = 32-__builtin_clz(SZ);
    
    int N, R = 1; // vertices from 1 to N, R = root
    vi adj[SZ];
    int par[BITS][SZ], depth[SZ];
    
    // INITIALIZE
    
    void addEdge(int u, int v) { adj[u].pb(v), adj[v].pb(u); }
    
    void dfs(int u, int prev){
        par[0][u] = prev;
        depth[u] = depth[prev]+1;
        trav(v,adj[u]) if (v != prev) dfs(v, u);
    }
    
    void init(int _N) {
        N = _N; dfs(R, 0);
        FOR(k,1,BITS) FOR(i,1,N+1) par[k][i] = par[k-1][par[k-1][i]];
    }
    
    // QUERY
    
    int getPar(int a, int b) {
        F0Rd(k,BITS) if (b&(1<<k)) a = par[k][a];
        return a;
    }
    
    int lca(int u, int v){
        if (depth[u] < depth[v]) swap(u,v);
        u = getPar(u,depth[u]-depth[v]);
        F0Rd(k,BITS) if (par[k][u] != par[k][v]) u = par[k][u], v = par[k][v];
        return u == v ? u : par[0][u];
    }
    
    int dist(int u, int v) {
        return depth[u]+depth[v]-2*depth[lca(u,v)];
    }
};

LCA<MX> L;

template<int SZ> struct BCC {
    int N;
    vi adj[SZ];
    vector<vpi> fin;
    
    void addEdge(int u, int v) { adj[u].pb(v), adj[v].pb(u); }
    
    int ti = 0, disc[SZ], low[SZ], comp[SZ], par[SZ];
    vpi st;
    
    void BCCutil(int u, bool root = 0) {
        disc[u] = low[u] = ti++;
        int child = 0;
        
        trav(i,adj[u]) if (i != par[u])
            if (disc[i] == -1) {
                child ++; par[i] = u;
                st.pb({u,i});
                BCCutil(i);
                low[u] = min(low[u],low[i]);
                
                // disc[u] < low[i]: bridge
                if ((root && child > 1) || (!root && disc[u] <= low[i])) { // articulation point!
                    vpi tmp;
                    while (st.back() != mp(u,i)) tmp.pb(st.back()), st.pop_back();
                    tmp.pb(st.back()), st.pop_back();
                    fin.pb(tmp);
                }
            } else if (disc[i] < disc[u]) {
                low[u] = min(low[u],disc[i]);
                st.pb({u,i});
            }
    }
    
    void bcc(int _N) {
        N = _N;
        FOR(i,1,N+1) par[i] = disc[i] = low[i] = -1;
        FOR(i,1,N+1) if (disc[i] == -1) {
            BCCutil(i,1);
            if (sz(st)) fin.pb(st);
            st.clear();
        }
    }
};

BCC<MX> B;
int n,m,q;

int main() {
    setIO(); re(n,m,q);
    F0R(i,m) {
        int a,b; re(a,b);
        B.addEdge(a,b);
    }
    B.bcc(n);
    F0R(i,sz(B.fin)) {
        set<int> x;
        trav(j,B.fin[i]) x.insert(j.f), x.insert(j.s);
        trav(j,x) L.addEdge(n+1+i,j);
    }
    L.init(n+sz(B.fin));
    F0R(i,q) {
        int a,b,c; re(a,b,c);
        if (L.dist(a,c)+L.dist(c,b) == L.dist(a,b)) ps(""NO"");
        else ps(""YES"");
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Forbidden Cities,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vi num, st;
vector<vector<pii>> ed;
int Time;
template<class F>
int dfs(int at, int par, F& f) {
    int me = num[at] = ++Time, e, y, top = me;
    trav(pa, ed[at]) if (pa.second != par) {
        tie(y, e) = pa;
        if (num[y]) {
            top = min(top, num[y]);
            if (num[y] < me)
                st.push_back(e);
        } else {
            int si = sz(st);
            int up = dfs(y, e, f);
            top = min(top, up);
            if (up == me) {
                st.push_back(e);
                f(vi(st.begin() + si, st.end()));
                st.resize(si);
            }
            else if (up < me) st.push_back(e);
            else { f(vi{e}); }
        }
    }
    return top;
}

template<class F>
void bicomps(F f) {
    num.assign(sz(ed), 0);
    rep(i,0,sz(ed)) if (!num[i]) dfs(i, -1, f);
}

typedef vector<pii> vpi;
typedef vector<vpi> graph;

template<class T>
struct RMQ {
    vector<vector<T>> jmp;
    
    RMQ(const vector<T>& V) {
        int N = sz(V), on = 1, depth = 1;
        while (on < N) on *= 2, depth++;
        jmp.assign(depth, V);
        rep(i,0,depth-1) rep(j,0,N)
        jmp[i+1][j] = min(jmp[i][j],
                          jmp[i][min(N - 1, j + (1 << i))]);
    }
    
    T query(int a, int b) {
        assert(a < b); // or return inf if a == b
        int dep = 31 - __builtin_clz(b - a);
        return min(jmp[dep][a], jmp[dep][b - (1 << dep)]);
    }
};

struct LCA {
    vi time;
    vector<ll> dist;
    RMQ<pii> rmq;
    
    LCA(graph& C) : time(sz(C), -99), dist(sz(C)), rmq(dfs(C)) {}
    
    vpi dfs(graph& C) {
        vector<tuple<int, int, int, ll>> q(1);
        vpi ret;
        int T = 0, v, p, d; ll di;
        while (!q.empty()) {
            tie(v, p, d, di) = q.back();
            q.pop_back();
            if (d) ret.emplace_back(d, p);
            time[v] = T++;
            dist[v] = di;
            trav(e, C[v]) if (e.first != p)
                q.emplace_back(e.first, v, d+1, di + e.second);
        }
        return ret;
    }
    
    int query(int a, int b) {
        if (a == b) return a;
        a = time[a], b = time[b];
        return rmq.query(min(a, b), max(a, b)).second;
    }
    ll distance(int a, int b) {
        int lca = query(a, b);
        return dist[a] + dist[b] - 2 * dist[lca];
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m, q;
    cin >> n >> m >> q;
    ed.resize(n);
    vector<pii> e(m);
    rep(i, 0, m) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        ed[a].push_back({b, i});
        ed[b].push_back({a, i});
        e[i]={a, b};
    }
    int nbcc=0;
    vi id(n);
    vector<pii> br;
    vector<vi> bcc(n);
    bicomps([&](const vi &c) {
        if (sz(c)==1) {
            int a=e[c[0]].first;
            int b=e[c[0]].second;
            br.push_back({a, b});
            id[a]=id[b]=1;
            return;
        }
        trav(i, c) for(int j: {e[i].first, e[i].second}) {
            if (!sz(bcc[j]) || bcc[j].back()!=nbcc)
                bcc[j].push_back(nbcc);
        }
        nbcc++;
    });
    int nap=0;
    rep(i, 0, n) {
        if (sz(bcc[i])>1 || id[i])
            id[i]=nbcc+(nap++);
        else id[i]=bcc[i][0];
    }
    graph T(nbcc+nap);
    trav(p, br) {
        T[id[p.first]].push_back({id[p.second], 1});
        T[id[p.second]].push_back({id[p.first], 1});
    }
    rep(i, 0, n) if(id[i]>=nbcc) {
        trav(j, bcc[i]) {
            T[id[i]].push_back({j, 1});
            T[j].push_back({id[i], 1});
        }
    }
    LCA lca(T);
    while (q--) {
        int a, b, c, ans=0;
        cin >> a >> b >> c;
        a--, b--, c--;
        if (a==c || b==c) ans=1;
        else if (id[c]<nbcc) ans=0;
        else {
            ll d1=lca.distance(id[a], id[c]);
            ll d2=lca.distance(id[b], id[c]);
            ll d=lca.distance(id[a], id[b]);
            ans=(d1+d2==d);
        }
        cout << (ans? ""NO\n"":""YES\n"");
    }
    return 0;
}
"
Forbidden Cities,Java,"// https://cses.fi/problemset/task/1705
// Forbidden Cities
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1705 extends PrintWriter {
    CSES1705() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1705 o = new CSES1705(); o.main(); o.flush();
    }
    
    int[] dsu;
    int find(int i) {
        return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));
    }
    boolean join(int i, int j) {
        i = find(i);
        j = find(j);
        if (i == j)
            return false;
        if (dsu[i] > dsu[j])
            dsu[i] = j;
        else {
            if (dsu[i] == dsu[j])
                dsu[i]--;
            dsu[j] = i;
        }
        return true;
    }
    int[] ta, tb, tc;
    int time;
    ArrayList[] aa;
    int[] ii, jj, hh;
    boolean[] cut;
    void dfs1(int h_, int i) {
        hh[i] = h_;
        ArrayList<Integer> adj = aa[i];
        ta[i] = tb[i] = ++time;
        int c = 0;
        for (int h : adj)
            if (h != h_) {
                int j = i ^ ii[h] ^ jj[h];
                if (ta[j] == 0) {
                    c++;
                    dfs1(h, j);
                    tb[i] = Math.min(tb[i], tb[j]);
                    if (h_ != -1 && ta[i] <= tb[j])
                        cut[i] = true;
                } else if (ta[j] < ta[i])
                    tb[i] = Math.min(tb[i], ta[j]);
            }
        if (h_ == -1 && c > 1)
            cut[i] = true;
    }
    void dfs2(int h_, int i) {
        ArrayList<Integer> adj = aa[i];
        for (int h : adj)
            if (h != h_) {
                int j = i ^ ii[h] ^ jj[h];
                if (hh[j] != h && ta[j] > ta[i])
                    while (j != i) {
                        if (!join(h, hh[j]))
                            break;
                        h = hh[j];
                        j ^= ii[h] ^ jj[h];
                    }
            }
        for (int h : adj)
            if (h != h_) {
                int j = i ^ ii[h] ^ jj[h];
                if (hh[j] == h)
                    dfs2(h, j);
            }
    }
    static final int INF = 0x3f3f3f3f;
    int[] tr;
    int n_, i_;
    void update(int k, int x) {
        for (k += n_; k >= 1; k >>= 1)
            tr[k] = Math.min(tr[k], x);
    }
    int query(int l, int r) {
        int x = INF;
        for (l += n_, r += n_; l <= r; l >>= 1, r >>= 1) {
            if ((l & 1) == 1)
                x = Math.min(x, tr[l++]);
            if ((r & 1) == 0)
                x = Math.min(x, tr[r--]);
        }
        return x;
    }
    ArrayList[] aa_;
    int[] ll, rr;
    void dfs_(int i) {
        ArrayList<Integer> adj = aa_[i];
        tc[i] = ++time;
        ll[i] = i_;
        update(i_++, tc[i]);
        for (int j : adj)
            if (tc[j] == 0) {
                dfs_(j);
                update(i_++, tc[i]);
            }
        rr[i] = i_;
    }
    boolean ancestor(int i, int a) {
        return ll[a] <= ll[i] && rr[i] <= rr[a];
    }
    boolean block(int i, int j, int k) {
        if (ll[i] > ll[j])
            return block(j, i, k);
        boolean aik = ancestor(i, k);
        boolean ajk = ancestor(j, k);
        return aik != ajk || aik && ajk && query(ll[i], ll[j]) == tc[k];
    }
    void main() {
        int n = sc.nextInt();
        int m = sc.nextInt();
        int q = sc.nextInt();
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        ii = new int[m];
        jj = new int[m];
        for (int h = 0; h < m; h++) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            ii[h] = i;
            jj[h] = j;
            aa[i].add(h);
            aa[j].add(h);
        }
        ta = new int[n];
        tb = new int[n];
        hh = new int[n];
        cut = new boolean[n];
        dfs1(-1, 0);
        dsu = new int[m + n];
        Arrays.fill(dsu, -1);
        dfs2(-1, 0);
        for (int h = 0; h < m; h++) {
            int i = ii[h], j = jj[h];
            if (!cut[i])
                join(h, m + i);
            if (!cut[j])
                join(h, m + j);
        }
        aa_ = new ArrayList[m + n];
        for (int h = 0; h < m + n; h++)
            aa_[h] = new ArrayList<Integer>();
        for (int i = 0; i < n; i++)
            if (cut[i]) {
                ArrayList<Integer> adj = aa[i];
                for (int h : adj) {
                    h = find(h);
                    aa_[m + i].add(h);
                    aa_[h].add(m + i);
                }
            }
        int h_ = 0;
        n_ = 0;
        for (int h = 0; h < m + n; h++)
            if (aa_[h].size() != 0) {
                n_++;
                h_ = h;
            }
        n_ *= 2;
        tr = new int[n_ * 2 + 1];
        Arrays.fill(tr, INF);
        ll = new int[m + n];
        rr = new int[m + n];
        tc = new int[m + n];
        time = 0;
        dfs_(h_);
        while (q-- > 0) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            int k = sc.nextInt() - 1;
            boolean yes;
            if (i == k || j == k)
                yes = false;
            else if (!cut[k])
                yes = true;
            else
                yes = !block(find(m + i), find(m + j), find(m + k));
            println(yes ? ""YES"" : ""NO"");
        }
    }
}
"
Forbidden Cities,C++,"/*
 https://cses.fi/problemset/task/1705/
 Forbidden Cities
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100000
#define M    200000
#define N_    (N * 2 * 2)
#define INF    0x3f3f3f3f

int min(int a, int b) { return a < b ? a : b; }

int dsu[M + N];

int find(int i) {
    return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));
}

int join(int i, int j) {
    i = find(i);
    j = find(j);
    if (i == j)
        return 0;
    if (dsu[i] > dsu[j])
        dsu[i] = j;
    else {
        if (dsu[i] == dsu[j])
            dsu[i]--;
        dsu[j] = i;
    }
    return 1;
}

int ta[N], tb[N], tc[M + N], time;

struct L {
    struct L *next;
    int x;
} aa[N], aa_[M + N];

int ii[M], jj[M], hh[N];
char cut[N];

void link(int i, int h) {
    static struct L l91[M * 2], *l = l91;
    
    l->x = h;
    l->next = aa[i].next, aa[i].next = l++;
}

void link_(int i, int j) {
    static struct L l91[M * 2], *l = l91;
    
    l->x = j;
    l->next = aa_[i].next, aa_[i].next = l++;
}

void dfs1(int h_, int i) {
    struct L *l;
    int c, h, j;
    
    hh[i] = h_;
    ta[i] = tb[i] = ++time;
    c = 0;
    for (l = aa[i].next; l; l = l->next)
        if ((h = l->x) != h_) {
            j = i ^ ii[h] ^ jj[h];
            if (!ta[j]) {
                c++;
                dfs1(h, j);
                tb[i] = min(tb[i], tb[j]);
                if (h_ != -1 && ta[i] <= tb[j])
                    cut[i] = 1;
            } else if (ta[j] < ta[i])
                tb[i] = min(tb[i], ta[j]);
        }
    if (h_ == -1 && c > 1)
        cut[i] = 1;
}

void dfs2(int h_, int i) {
    struct L *l;
    int h, j;
    
    for (l = aa[i].next; l; l = l->next)
        if ((h = l->x) != h_) {
            j = i ^ ii[h] ^ jj[h];
            if (hh[j] != h && ta[j] > ta[i])
                while (j != i) {
                    if (!join(h, hh[j]))
                        break;
                    h = hh[j];
                    j ^= ii[h] ^ jj[h];
                }
        }
    for (l = aa[i].next; l; l = l->next)
        if ((h = l->x) != h_) {
            j = i ^ ii[h] ^ jj[h];
            if (hh[j] == h)
                dfs2(h, j);
        }
}

int tr[N_ * 2 + 1], n_, i_;

void update(int k, int x) {
    for (k += n_; k >= 1; k >>= 1)
        tr[k] = min(tr[k], x);
}

int query(int l, int r) {
    int x = INF;
    
    for (l += n_, r += n_; l <= r; l >>= 1, r >>= 1) {
        if ((l & 1) == 1)
            x = min(x, tr[l++]);
        if ((r & 1) == 0)
            x = min(x, tr[r--]);
    }
    return x;
}

int ll[M + N], rr[M + N];

void dfs_(int i) {
    struct L *l;
    int j;
    
    tc[i] = ++time;
    ll[i] = i_;
    update(i_++, tc[i]);
    for (l = aa_[i].next; l; l = l->next)
        if (tc[j = l->x] == 0) {
            dfs_(j);
            update(i_++, tc[i]);
        }
    rr[i] = i_;
}

int ancestor(int i, int a) {
    return ll[a] <= ll[i] && rr[i] <= rr[a];
}

int block(int i, int j, int k) {
    int aik, ajk;
    
    if (ll[i] > ll[j])
        return block(j, i, k);
    aik = ancestor(i, k);
    ajk = ancestor(j, k);
    return aik != ajk || aik && ajk && query(ll[i], ll[j]) == tc[k];
}

int main() {
    int n, m, q, h, h_, i, j, k;
    
    scanf(""%d%d%d"", &n, &m, &q);
    for (h = 0; h < m; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        ii[h] = i, jj[h] = j;
        link(i, h), link(j, h);
    }
    dfs1(-1, 0);
    memset(dsu, -1, (m + n) * sizeof *dsu);
    dfs2(-1, 0);
    for (h = 0; h < m; h++) {
        i = ii[h], j = jj[h];
        if (!cut[i])
            join(h, m + i);
        if (!cut[j])
            join(h, m + j);
    }
    for (i = 0; i < n; i++)
        if (cut[i]) {
            struct L *l;
            
            for (l = aa[i].next; l; l = l->next) {
                h = find(l->x);
                link_(m + i, h);
                link_(h, m + i);
            }
        }
    h_ = 0;
    for (h = 0; h < m + n; h++)
        if (aa_[h].next) {
            n_++;
            h_ = h;
        }
    n_ *= 2;
    memset(tr, 0x3f, (n_ * 2 + 1) * sizeof *tr);
    time = 0;
    dfs_(h_);
    while (q--) {
        int yes;
        
        scanf(""%d%d%d"", &i, &j, &k), i--, j--, k--;
        if (i == k || j == k)
            yes = 0;
        else if (!cut[k])
            yes = 1;
        else
            yes = !block(find(m + i), find(m + j), find(m + k));
        printf(yes ? ""YES\n"" : ""NO\n"");
    }
    return 0;
}
"
Graph Girth,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,m, ans = MOD, bad,dist[2501];
vi adj[2501];
vpi ed;

void tri() {
    FOR(i,1,n+1) dist[i] = MOD;
    queue<int> q; dist[ed[bad].f] = 0; q.push(ed[bad].f);
    while (sz(q)) {
        int x = q.front(); q.pop();
        trav(a,adj[x]) if (a != bad) {
            int b = ed[a].f+ed[a].s-x;
            if (dist[b] == MOD) {
                q.push(b);
                dist[b] = dist[x]+1;
            }
        }
    }
    ckmin(ans,dist[ed[bad].s]+1);
}

int main() {
    setIO(); re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        adj[a].pb(i), adj[b].pb(i);
        ed.pb({a,b});
    }
    F0R(i,m) {
        bad = i;
        tri();
    }
    if (ans == MOD) ps(-1);
    else ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Graph Girth,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<vi> g(n+1);
    while (m--) {
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    int ans=n+1;
    vi d(n+1), p(n+1);
    rep(i, 1, n+1) {
        rep(j, 1, n+1) p[j]=0;
        d[i]=0, p[i]=-1;
        queue<int> q;
        for(q.push(i); !q.empty(); q.pop()) {
            int i=q.front();
            trav(j, g[i]) {
                if (!p[j])
                    d[j]=d[i]+1, p[j]=i, q.push(j);
                else if(p[i]!=j)
                    ans=min(ans, d[i]+d[j]+1);
            }
        }
    }
    cout << (ans>n? -1:ans) << '\n';
    return 0;
}
"
Graph Girth,Java,"// https://cses.fi/problemset/task/1707
// Graph Girth
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1707 extends PrintWriter {
    CSES1707() { super(System.out, true); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) { new CSES1707().main(); }
    
    int[][] aa;
    int[] qq, dd;
    static final int INF = 2501;
    int bfs(int i) {
        Arrays.fill(dd, INF);
        int d_ = INF;
        int head = 0, cnt = 0;
        dd[i] = 0;
        qq[head + cnt++] = i;
        while (cnt > 0) {
            i = qq[head++]; cnt--;
            int d = dd[i];
            if (d > d_)
                return d_ * 2 + 2;
            for (int h = 0; h < aa[i].length; h++) {
                int j = aa[i][h];
                if (dd[j] < d)
                    continue;
                if (dd[j] == INF) {
                    dd[j] = d + 1;
                    qq[head + cnt++] = j;
                } else {
                    if (dd[j] == d)
                        return d * 2 + 1;
                    d_ = d;
                }
            }
        }
        return INF;
    }
    void main() {
        int n = sc.nextInt();
        int m = sc.nextInt();
        ArrayList[] aa_ = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa_[i] = new ArrayList<Integer>();
        while (m-- > 0) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            if (i == j) {
                println(1);
                return;
            }
            aa_[i].add(j);
            aa_[j].add(i);
        }
        aa = new int[n][];
        for (int i = 0; i < n; i++) {
            ArrayList<Integer> adj = aa_[i];
            aa[i] = adj.stream().mapToInt($->$).toArray();
        }
        qq = new int[n];
        dd = new int[n];
        int ans = INF;
        for (int i = 0; i < n; i++)
            ans = Math.min(ans, bfs(i));
        println(ans == INF ? -1 : ans);
    }
}
"
Graph Girth,C++,"/*
 https://cses.fi/problemset/task/1707
 Graph Girth
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    2500
#define M    5000
#define INF    0x3f3f3f3f

struct L {
    struct L *next;
    int j;
} aa[N];

void link(int i, int j) {
    static struct L l91[M * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

int bfs(int i) {
    static int qq[N], dd[N];
    struct L *l;
    int j, d, d_, head, cnt;
    
    memset(dd, 0x3f, sizeof dd);
    d_ = INF;
    head = cnt = 0;
    dd[i] = 0;
    qq[head + cnt++] = i;
    while (cnt) {
        i = qq[cnt--, head++];
        d = dd[i];
        if (d > d_)
            return d_ * 2 + 2;
        for (l = aa[i].next; l; l = l->next) {
            j = l->j;
            if (dd[j] < d)
                continue;
            if (dd[j] == INF) {
                dd[j] = d + 1;
                qq[head + cnt++] = j;
            } else {
                if (dd[j] == d)
                    return d * 2 + 1;
                d_ = d;
            }
        }
    }
    return INF + 1;
}

int main() {
    int n, m, h, i, j, ans, c;
    
    scanf(""%d%d"", &n, &m);
    for (h = 0; h < m; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), link(j, i);
        if (i == j) {
            printf(""1\n"");
            return 0;
        }
    }
    ans = INF;
    for (i = 0; i < n; i++)
        if (ans > (c = bfs(i)))
            ans = c;
    printf(""%d\n"", ans == INF ? -1 : ans);
    return 0;
}
"
Grid Paths,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

template<int SZ> struct Combo {
    ll fac[SZ+1], ifac[SZ+1];
    
    Combo() {
        fac[0] = ifac[0] = 1;
        FOR(i,1,SZ+1) {
            fac[i] = i*fac[i-1] % MOD;
            ifac[i] = inv(fac[i]);
        }
    }
    
    ll po (ll b, ll p) {
        return !p?1:po(b*b%MOD,p/2)*(p&1?b:1)%MOD;
    }
    
    ll inv (ll b) { return po(b,MOD-2); }
    
    ll comb(ll a, ll b) {
        if (a < b) return 0;
        ll tmp = fac[a]*ifac[b] % MOD;
        tmp = tmp*ifac[a-b] % MOD;
        return tmp;
    }
};

Combo<2000000> C;

int n,m;
ll ans[1002];
vector<pii> p;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m;
    F0R(i,m) {
        int x,y; cin >> x >> y;
        p.pb({x-1,y-1});
    }
    p.pb({0,0});
    p.pb({n-1,n-1});
    sort(all(p));
    ans[0] = 1;
    FOR(i,1,m+2) {
        ans[i] = C.comb(p[i].f+p[i].s,p[i].f);
        FOR(j,1,i) if (p[j].f <= p[i].f && p[j].s <= p[i].s) {
            ans[i] -= C.comb(p[i].f-p[j].f+p[i].s-p[j].s,p[i].s-p[j].s)*ans[j];
            ans[i] = (ans[i]%MOD+MOD)%MOD;
        }
    }
    cout << ans[m+1];
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Grid Paths,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr ll P=1e9+7;
vector<ll> f, invf;

ll modpow(ll b, ll e) {
    ll ans = 1;
    for (; e; b = b * b % P, e /= 2)
        if (e & 1) ans = ans * b % P;
    return ans;
}

ll B(int a, int b) {
    return f[a]*invf[b]%P*invf[a-b]%P;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    f.resize(2*n+1);
    invf.resize(2*n+1);
    f[0]=1;
    rep(i, 1, 2*n+1) f[i]=f[i-1]*i%P;
    invf[2*n]=modpow(f[2*n], P-2);
    for(int i=2*n; i; i--)
        invf[i-1]=invf[i]*i%P;
    vector<pii> t(m);
    rep(i, 0, m)
    cin >> t[i].first >> t[i].second;
    t.push_back({n, n});
    sort(all(t));
    vector<ll> dp(m+1);
    rep(i, 0, m+1) {
        int r=t[i].first;
        int c=t[i].second;
        dp[i]=B(r+c-2, r-1);
        rep(j, 0, i) {
            int R=t[j].first;
            int C=t[j].second;
            if (R<=r && C<=c)
                dp[i]=(dp[i]+P-B(r-R+c-C, r-R)*dp[j]%P)%P;
        }
    }
    cout << dp[m] << '\n';
    return 0;
}
"
Grid Paths,Java,"// https://cses.fi/problemset/task/1078
// Grid Paths
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1078 {
    static final int MD = 1000000007;
    static int[] ff, gg;
    static long power(long a, int k) {
        if (k == 0)
            return 1;
        long p = power(a, k / 2);
        p = p * p % MD;
        if (k % 2 == 1)
            p = p * a % MD;
        return p;
    }
    static void init(int n) {
        ff = new int[n];
        gg = new int[n];
        long f = 1;
        for (int i = 0; i < n; i++) {
            ff[i] = (int) f;
            gg[i] = (int) power(f, MD - 2);
            f = f * (i + 1) % MD;
        }
    }
    static long ch(int n, int k) {
        return (long) ff[n] * gg[k] % MD * gg[n - k] % MD;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        init(n * 2);
        int[] xx = new int[m + 1];
        int[] yy = new int[m + 1];
        for (int h = 0; h < m; h++) {
            st = new StringTokenizer(br.readLine());
            xx[h] = Integer.parseInt(st.nextToken()) - 1;
            yy[h] = Integer.parseInt(st.nextToken()) - 1;
        }
        xx[m] = n - 1;
        yy[m] = n - 1;
        Integer[] ii = new Integer[m + 1];
        for (int h = 0; h <= m; h++)
            ii[h] = h;
        Arrays.sort(ii, (i, j) -> xx[i] != xx[j] ? xx[i] - xx[j] : yy[i] - yy[j]);
        int[] zz = new int[m + 1];
        for (int h = 0; h <= m; h++) {
            int j = ii[h];
            int x = xx[j];
            int y = yy[j];
            long z = ch(x + y, x);
            for (int h_ = 0; h_ < h; h_++) {
                int i = ii[h_];
                if (xx[i] <= xx[j] && yy[i] <= yy[j]) {
                    x = xx[j] - xx[i];
                    y = yy[j] - yy[i];
                    z = (z - zz[i] * ch(x + y, x)) % MD;
                }
            }
            zz[j] = (int) z;
        }
        System.out.println((zz[m] + MD) % MD);
    }
}
"
Grid Paths,C++,"/*
 https://cses.fi/problemset/task/1078
 Grid Paths
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>

#define N    1000000
#define M    1000
#define MD    1000000007

int xx[M + 1], yy[M + 1], zz[M + 1], ii[M + 1];

int compare(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return xx[i] != xx[j] ? xx[i] - xx[j] : yy[i] - yy[j];
}

int ff[N * 2], gg[N * 2];

long long power(int a, int k) {
    long long p;
    
    if (k == 0)
        return 1;
    p = power(a, k / 2);
    p = p * p % MD;
    if (k % 2)
        p = p * a % MD;
    return p;
}

void init(int n) {
    int i;
    long long f = 1;
    
    for (i = 0; i < n; i++) {
        ff[i] = f;
        gg[i] = power(f, MD - 2);
        f = f * (i + 1) % MD;
    }
}

long long choose(int n, int k) {
    return (long long) ff[n] * gg[k] % MD * gg[n - k] % MD;
}

int main() {
    int n, m, h, h_, i, j, x, y, z;
    
    scanf(""%d%d"", &n, &m);
    init(n * 2);
    for (h = 0; h < m; h++)
        scanf(""%d%d"", &xx[h], &yy[h]), xx[h]--, yy[h]--;
    xx[m] = yy[m] = n - 1;
    for (h = 0; h <= m; h++)
        ii[h] = h;
    qsort(ii, m + 1, sizeof *ii, compare);
    for (h = 0; h <= m; h++) {
        j = ii[h];
        x = xx[j];
        y = yy[j];
        z = choose(x + y, x);
        for (h_ = 0; h_ < h; h_++) {
            i = ii[h_];
            if (xx[i] <= xx[j] && yy[i] <= yy[j]) {
                x = xx[j] - xx[i];
                y = yy[j] - yy[i];
                z = (z - zz[i] * choose(x + y, x)) % MD;
            }
        }
        zz[j] = z;
    }
    printf(""%d\n"", (zz[m] + MD) % MD);
    return 0;
}
"
Increasing Subsequence II,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template <class T, int ...Ns> struct BIT {
    T val = 0;
    void upd(T v) { val += v; }
    T query() { return val; }
};

template <class T, int N, int... Ns> struct BIT<T, N, Ns...> {
    BIT<T,Ns...> bit[N + 1];
    template<typename... Args> void upd(int pos, Args... args) {
        for (; pos <= N; pos += (pos&-pos)) bit[pos].upd(args...);
    }
    template<typename... Args> T sum(int r, Args... args) {
        T res = 0; for (; r; r -= (r&-r)) res += bit[r].query(args...);
        return res;
    }
    template<typename... Args> T query(int l, int r, Args... args) {
        return sum(r,args...)-sum(l-1,args...);
    }
}; // BIT<int,10,10> gives a 2D BIT

BIT<mi,MX> B;
int n;
vi x;

int main() {
    setIO(); re(n); x.resz(n); re(x);
    map<int,int> m; trav(t,x) m[t] = 0;
    int co = 0; trav(t,m) t.s = ++co;
    trav(t,x) t = m[t];
    mi ans(0);
    trav(t,x) {
        mi ret = 1+B.sum(t-1);
        B.upd(t,ret); ans += ret;
    }
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Increasing Subsequence II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr ll P=1e9+7;
struct FT {
    vector<ll> s;
    FT(int n) : s(n) {}
    void update(int pos, ll dif) { // a[pos] += dif
        for (; pos < sz(s); pos |= pos + 1) (s[pos] += dif)%=P;
    }
    ll query(int pos) { // sum of values in [0, pos)
        ll res = 0;
        for (; pos > 0; pos &= pos - 1) res += s[pos-1];
        return res%P;
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >>  n;
    vi x(n);
    rep(i, 0, n) cin >> x[i];
    vi y(x);
    sort(all(y));
    y.erase(unique(all(y)), end(y));
    trav(a, x) a=lower_bound(all(y), a)-begin(y);
    FT t(n);
    ll ans=0;
    rep(i, 0, n) {
        ll cur=t.query(x[i])+1;
        (ans+=cur)%=P;
        t.update(x[i], cur);
    }
    cout << ans << '\n';
    return 0;
}
"
Increasing Subsequence II,Java,"// https://cses.fi/problemset/task/1748
// Increasing Subsequence II
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1748 extends PrintWriter {
    CSES1748() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1748 c = new CSES1748(); c.main(); c.flush();
    }
    
    static final int MD = 1000000007;
    int[] tt;
    void update(int i, int n, int x) {
        while (i < n) {
            tt[i] = (tt[i] + x) % MD;
            i |= i + 1;
        }
    }
    int query(int i) {
        int x = 0;
        while (i >= 0) {
            x = (x + tt[i]) % MD;
            i &= i + 1;
            i--;
        }
        return x;
    }
    void main() {
        int n = sc.nextInt();
        int[] aa = new int[n];
        Integer[] ii = new Integer[n];
        for (int i = 0; i < n; i++) {
            aa[i] = sc.nextInt();
            ii[i] = i;
        }
        Arrays.sort(ii, (i, j) -> aa[i] != aa[j] ? aa[i] - aa[j] : j - i);
        tt = new int[n];
        for (int h = 0; h < n; h++) {
            int i = ii[h];
            update(i, n, query(i) + 1);
        }
        println(query(n - 1));
    }
}
"
Increasing Subsequence II,C++,"/*
 https://cses.fi/problemset/task/1748
 Increasing Subsequence II
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    200000
#define MD    1000000007

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

int xx[N];

int compare(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return xx[i] != xx[j] ? xx[i] - xx[j] : j - i;
}

int tt[N];

void update(int i, int n, int x) {
    while (i < n) {
        tt[i] = (tt[i] + x) % MD;
        i |= i + 1;
    }
}

int query(int i) {
    int x = 0;
    
    while (i >= 0) {
        x = (x + tt[i]) % MD;
        i &= i + 1;
        i--;
    }
    return x;
}

int main() {
    static int ii[N];
    int n, h, i, j, tmp;
    
    init_rand();
    scanf(""%d"", &n);
    for (i = 0; i < n; i++) {
        scanf(""%d"", &xx[i]);
        ii[i] = i;
    }
    for (j = 0; j < n; j++) {
        i = rand_(j + 1);
        tmp = ii[i], ii[i] = ii[j], ii[j] = tmp;
    }
    qsort(ii, n, sizeof *ii, compare);
    for (h = 0; h < n; h++)
        update(ii[h], n, query(ii[h]) + 1);
    printf(""%d\n"", query(n - 1));
    return 0;
}
"
Intersection Points,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template <class T, int ...Ns> struct BIT {
    T val = 0;
    void upd(T v) { val += v; }
    T query() { return val; }
};

template <class T, int N, int... Ns> struct BIT<T, N, Ns...> {
    BIT<T,Ns...> bit[N + 1];
    template<typename... Args> void upd(int pos, Args... args) {
        for (; pos <= N; pos += (pos&-pos)) bit[pos].upd(args...);
    }
    template<typename... Args> T sum(int r, Args... args) {
        T res = 0; for (; r; r -= (r&-r)) res += bit[r].query(args...);
        return res;
    }
    template<typename... Args> T query(int l, int r, Args... args) {
        return sum(r,args...)-sum(l-1,args...);
    }
}; // BIT<int,10,10> gives a 2D BIT


int n;
vector<array<int,4>> mod;
BIT<int,2000005> B;

int main() {
    setIO(); re(n);
    F0R(i,n) {
        int x1,y1,x2,y2; re(x1,y1,x2,y2);
        if (y1 == y2) mod.pb({y1,2,x1,x2});
        else {
            mod.pb({y1,1,x1,-1});
            mod.pb({y2,3,x1,-1});
        }
    }
    sort(all(mod));
    // exit(0);
    ll ans = 0;
    trav(t,mod) {
        t[2] += 1000001, t[3] += 1000001;
        if (t[1] == 1) {
            B.upd(t[2],1);
        } else if (t[1] == 2) {
            ans += B.query(t[2],t[3]);
        } else {
            B.upd(t[2],-1);
        }
    }
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Intersection Points,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

#include <bits/extc++.h>
using namespace __gnu_pbds;

template<class T>
using Tree = tree<T, null_type, less<T>, rb_tree_tag,
tree_order_statistics_node_update>;

void example() {
    Tree<int> t, t2; t.insert(8);
    auto it = t.insert(10).first;
    assert(it == t.lower_bound(9));
    assert(t.order_of_key(10) == 1);
    assert(t.order_of_key(11) == 2);
    assert(*t.find_by_order(0) == 8);
    t.join(t2); // assuming T < T2 or T > T2, merge t2 into t
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vector<tuple<int, int, int, int>> e;
    rep(i, 0, n) {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        if(x1==x2) e.push_back({x1, 0, y1, y2});
        else {
            e.push_back({min(x1, x2), -1, y1, 0});
            e.push_back({max(x1, x2), +1, y1, 0});
        }
    }
    sort(all(e));
    Tree<int> t;
    ll ans=0;
    trav(p, e) {
        int x, type, a, b;
        tie(x, type, a, b)=p;
        if (type==-1) t.insert(a);
        if (type==+1) t.erase(a);
        if (type==0) {
            if(a>b) swap(a, b);
            ans+=t.order_of_key(b+1)-t.order_of_key(a);
        }
    }
    cout << ans << '\n';
    return 0;
}
"
Intersection Points,Java,"// https://cses.fi/problemset/task/1740
// Intersection Points
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1740 extends PrintWriter {
    CSES1740() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            boolean minus = c == '-'; if (minus) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return minus ? -a : a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1740 c = new CSES1740(); c.main(); c.flush();
    }
    
    static final int M = 1000000, INF = M * 2 + 1;
    int[] tt = new int[INF];
    void update(int i, int x) {
        while (i < INF) {
            tt[i] += x;
            i |= i + 1;
        }
    }
    int query(int i) {
        int x = 0;
        while (i >= 0) {
            x += tt[i];
            i &= i + 1;
            i--;
        }
        return x;
    }
    static class V {
        int y, l, r;
        V(int y, int l, int r) {
            this.y = y; this.l = l; this.r = r;
        }
    }
    void main() {
        int n = sc.nextInt();
        ArrayList<V> list = new ArrayList<>();
        while (n-- > 0) {
            int x1 = sc.nextInt() + M;
            int y1 = sc.nextInt();
            int x2 = sc.nextInt() + M;
            int y2 = sc.nextInt();
            if (y1 == y2)
                list.add(new V(y1, x1, x2));
            else {
                list.add(new V(y1, -1, x1));
                list.add(new V(y2, INF, x1));
            }
        }
        Collections.sort(list, (u, v) -> u.y != v.y ? u.y - v.y : u.l - v.l);
        //V[] vv = list.toArray(new V[0]);
        //Arrays.sort(vv, (u, v) -> u.y != v.y ? u.y - v.y : u.l - v.l);
        long ans = 0;
        for (V v : list)
            if (v.l == -1)
                update(v.r, 1);
            else if (v.l == INF)
                update(v.r, -1);
            else
                ans += query(v.r) - query(v.l - 1);
        println(ans);
    }
}
"
Intersection Points,Java,"// https://cses.fi/problemset/task/1740
// Intersection Points
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1740 extends PrintWriter {
    CSES1740() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            boolean minus = c == '-'; if (minus) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return minus ? -a : a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1740 c = new CSES1740(); c.main(); c.flush();
    }
    
    static final int M = 1000000, INF = M * 2 + 1;
    int[] tt = new int[INF];
    void update(int i, int x) {
        while (i < INF) {
            tt[i] += x;
            i |= i + 1;
        }
    }
    int query(int i) {
        int x = 0;
        while (i >= 0) {
            x += tt[i];
            i &= i + 1;
            i--;
        }
        return x;
    }
    static class V {
        int y, l, r;
        V(int y, int l, int r) {
            this.y = y; this.l = l; this.r = r;
        }
    }
    void main() {
        int n = sc.nextInt();
        ArrayList<V> list = new ArrayList<>();
        while (n-- > 0) {
            int x1 = sc.nextInt() + M;
            int y1 = sc.nextInt();
            int x2 = sc.nextInt() + M;
            int y2 = sc.nextInt();
            if (y1 == y2)
                list.add(new V(y1, x1, x2));
            else {
                list.add(new V(y1, -1, x1));
                list.add(new V(y2, INF, x1));
            }
        }
        //Collections.sort(list, (u, v) -> u.y != v.y ? u.y - v.y : u.l - v.l);
        V[] vv = list.toArray(new V[0]);
        Arrays.sort(vv, (u, v) -> u.y != v.y ? u.y - v.y : u.l - v.l);
        long ans = 0;
        for (V v : vv)
            if (v.l == -1)
                update(v.r, 1);
            else if (v.l == INF)
                update(v.r, -1);
            else
                ans += query(v.r) - query(v.l - 1);
        println(ans);
    }
}
"
Intersection Points,C++,"/*
 https://cses.fi/problemset/task/1740
 Intersection Points
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    100000
#define M    1000000
#define INF    (M * 2 + 1)

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

struct V {
    int y, l, r;
} vv[N * 2];

int compare(const void *a, const void *b) {
    struct V *u = (struct V *) a;
    struct V *v = (struct V *) b;
    
    return u->y != v->y ? u->y - v->y : u->l - v->l;
}

int tt[INF];

void update(int i, int x) {
    while (i < INF) {
        tt[i] += x;
        i |= i + 1;
    }
}

int query(int i) {
    int x = 0;
    
    while (i >= 0) {
        x += tt[i];
        i &= i + 1;
        i--;
    }
    return x;
}

int main() {
    int n, n_, i, j;
    long long ans;
    struct V tmp;
    
    init_rand();
    scanf(""%d"", &n);
    n_ = 0;
    while (n--) {
        int x1, y1, x2, y2;
        struct V *v;
        
        scanf(""%d%d%d%d"", &x1, &y1, &x2, &y2), x1 += M, x2 += M;
        if (y1 == y2) {
            v = &vv[n_++];
            v->y = y1, v->l = x1, v->r = x2;
        } else {
            v = &vv[n_++];
            v->y = y1, v->l = -1, v->r = x1;
            v = &vv[n_++];
            v->y = y2, v->l = INF, v->r = x1;
        }
    }
    for (j = 0; j < n_; j++) {
        i = rand_(j + 1);
        tmp = vv[i], vv[i] = vv[j], vv[j] = tmp;
    }
    qsort(vv, n_, sizeof *vv, compare);
    ans = 0;
    for (i = 0; i < n_; i++) {
        struct V *v = &vv[i];
        
        if (v->l == -1)
            update(v->r, 1);
        else if (v->l == INF)
            update(v->r, -1);
        else
            ans += query(v->r) - query(v->l - 1);
    }
    printf(""%lld\n"", ans);
    return 0;
}
"
Maximum Building I,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

template<int SZ> struct DSU {
    int par[SZ], sz[SZ];
    DSU() {
        F0R(i,SZ) par[i] = -1, sz[i] = 1;
    }
    
    int get(int x) { // path compression
        if (par[x] != x) par[x] = get(par[x]);
        return par[x];
    }
    
    bool unite(int x, int y) { // union-by-rank
        x = get(x), y = get(y);
        if (x == y) return 0;
        if (sz[x] < sz[y]) swap(x,y);
        sz[x] += sz[y], par[y] = x;
        return 1;
    }
};

int n,m, cur[1000];
char g[1000][1000];
ll ans = 0;

void solve(int x) {
    vector<pii> v;
    F0R(i,n) v.pb({cur[i]-x,i});
    sort(v.rbegin(),v.rend());
    
    DSU<1000> D = DSU<1000>();
    for (auto a: v) {
        D.par[a.s] = a.s;
        if (a.s > 0 && D.par[a.s-1] != -1) D.unite(a.s,a.s-1);
        if (a.s < n-1 && D.par[a.s+1] != -1) D.unite(a.s,a.s+1);
        ans = max(ans,a.f*(ll)D.sz[D.get(a.s)]);
    }
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m;
    F0R(i,n) F0R(j,m) cin >> g[i][j];
    F0R(i,n) cur[i] = m;
    F0Rd(j,m) {
        F0R(i,n) if (g[i][j] == '*') cur[i] = j;
        solve(j);
    }
    cout << ans;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Maximum Building I,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;
const ll INF = 1e18;
const int MX = 100001;

template<int SZ> struct DSU {
    int par[SZ], sz[SZ];
    DSU() {
        F0R(i,SZ) par[i] = -1, sz[i] = 1;
    }
    
    int get(int x) { // path compression
        if (par[x] != x) par[x] = get(par[x]);
        return par[x];
    }
    
    bool unite(int x, int y) { // union-by-rank
        x = get(x), y = get(y);
        if (x == y) return 0;
        if (sz[x] < sz[y]) swap(x,y);
        sz[x] += sz[y], par[y] = x;
        return 1;
    }
};

int n,m,cur[1000];
char g[1000][1000];
ll ans = 0;

void solve(int x) {
    vi nex[m+1];
    F0R(i,n) nex[cur[i]-x].pb(i);
    
    DSU<1000> D = DSU<1000>();
    F0Rd(i,m+1) for (int a: nex[i]) {
        D.par[a] = a;
        if (a > 0 && D.par[a-1] != -1) D.unite(a,a-1);
        if (a < n-1 && D.par[a+1] != -1) D.unite(a,a+1);
        ans = max(ans,i*(ll)D.sz[D.get(a)]);
    }
}

int solve() {
    F0R(i,n) cur[i] = m;
    F0Rd(j,m) {
        F0R(i,n) if (g[i][j] == '*') cur[i] = j;
        solve(j);
    }
    return ans;
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m;
    F0R(i,n) F0R(j,m) cin >> g[i][j];
    cout << solve();
}

/* Look for:
 * the exact constraints (multiple sets are too slow for n=10^6 :( )
 * special cases (n=1?)
 * overflow (ll vs int?)
 * array bounds
 */
"
Maximum Building I,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<string> s(n);
    rep(i, 0, n) cin >> s[i];
    vi z(m+2), f(m+2);
    vector<vi> ans(n+2, vi(m+2));
    rep(r, 0, n) {
        rep(c, 1, m+1)
        z[c]=(s[r][c-1]=='*'? 0:z[c]+1);
        vi h(z);
        set<pii, greater<pii>> y;
        rep(c, 0, m+2) {
            int d;
            for(d=c; d<m+1; d++)
                if (h[d+1]!=h[c]) break;
            f[c]=d, f[d]=c;
            y.insert({h[c], c});
            c=d;
        }
        int L, R, H, NH;
        while ((H=h[L=begin(y)->second])) {
            R=f[L];
            NH=max(h[L-1], h[R+1]);
            ans[NH+1][R-L+1]++;
            ans[H+1][R-L+1]--;
            y.erase(begin(y));
            if(h[L-1]==NH)
                L=f[L-1], y.erase({h[L], L});
            if(h[R+1]==NH)
                y.erase({h[R+1], R+1}), R=f[R+1];
            f[L]=R, f[R]=L;
            y.insert({h[L]=h[R]=NH, L});
        }
    }
    int A=0;
    rep(r, 1, n+1) rep(c, 1, m+1)
    ans[r][c]+=ans[r-1][c];
    rep(r, 1, n+1) {
        rep(k, 0, 2) for (int c=m; c; c--)
            ans[r][c]+=ans[r][c+1];
        rep(c, 1, m+1)
        if (ans[r][c]) A=max(A, r*c);
    }
    cout << A << '\n';
    return 0;
}
"
Maximum Building I,Java,"// https://cses.fi/problemset/task/1147
// Building
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1147 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        char[][] cc = new char[n][m];
        for (int i = 0; i < n; i++)
            br.readLine().getChars(0, m, cc[i], 0);
        int[][] ll = new int[n][m];
        int[][] rr = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++)
                if (cc[i][j] == '*')
                    ll[i][j] = 0;
                else
                    ll[i][j] = (j == 0 ? 0 : ll[i][j - 1]) + 1;
            for (int j = m - 1; j >= 0; j--)
                if (cc[i][j] == '*')
                    rr[i][j] = 0;
                else
                    rr[i][j] = (j == m - 1 ? 0 : rr[i][j + 1]) + 1;
        }
        int ans = 0;
        for (int j = 0; j < m; j++) {
            int h = 0, l = m, r = m;
            for (int i = 0; i < n; i++) {
                if (cc[i][j] == '*') {
                    h = 0;
                    l = r = m;
                } else {
                    h++;
                    l = Math.min(l, ll[i][j]);
                    r = Math.min(r, rr[i][j]);
                }
                ans = Math.max(ans, (l + r - 1) * h);
            }
        }
        System.out.println(ans);
    }
}
"
Maximum Building I,C++,"/*
 https://cses.fi/problemset/task/1147
 Building
 practice with Dukkha
 */
#include <stdio.h>

#define N    1000

int main() {
    static char cc[N][N + 1];
    static int ll[N][N], rr[N][N];
    int n, m, i, j, ans, h, l, r;
    
    scanf(""%d%d"", &n, &m);
    for (i = 0; i < n; i++)
        scanf(""%s"", cc[i]);
    for (i = 0; i < n; i++) {
        for (j = 0; j < m; j++)
            if (cc[i][j] == '*')
                ll[i][j] = 0;
            else
                ll[i][j] = (j == 0 ? 0 : ll[i][j - 1]) + 1;
        for (j = m - 1; j >= 0; j--)
            if (cc[i][j] == '*')
                rr[i][j] = 0;
            else
                rr[i][j] = (j == m - 1 ? 0 : rr[i][j + 1]) + 1;
    }
    ans = 0;
    for (j = 0; j < m; j++) {
        h = 0, l = m, r = m;
        for (i = 0; i < n; i++) {
            if (cc[i][j] == '*')
                h = 0, l = m, r = m;
            else {
                h++;
                if (l > ll[i][j])
                    l = ll[i][j];
                if (r > rr[i][j])
                    r = rr[i][j];
            }
            if (ans < (l + r - 1) * h)
                ans = (l + r - 1) * h;
        }
    }
    printf(""%d\n"", ans);
    return 0;
}
"
Maximum Building II,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<ll,ll> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;
const int MX = 1002;

int n,m, cur[MX],ans[MX][MX];
pii tmp[MX][MX];
char g[MX][MX];

pii operator+(pii a, pii b) {
    return {a.f+b.f,a.s+b.s};
}

pii operator-(pii a, pii b) {
    return {a.f-b.f,a.s-b.s};
}

void upd(int x, int l, int r, pii val) {
    tmp[x][l] = tmp[x][l] + val;
    tmp[x][r+1] = tmp[x][r+1] - val;
}

void ins(int x, int l, int r) {
    if (l > r) swap(l,r);
    
    upd(x,1,l-1,{1,0});
    upd(x,l,r,{0,l});
    upd(x,r+1,l+r-1,{-1,l+r});
}

void solve(int x) {
    vector<pii> v;
    F0R(i,n) v.pb({cur[i]-x,i});
    sort(v.rbegin(),v.rend());
    
    set<int> bad;
    FOR(i,-1,n+1) bad.insert(i);
    for (pii x: v) {
        auto it = bad.find(x.s);
        ins(x.f,x.s-*prev(it),*next(it)-x.s);
        bad.erase(it);
    }
}

void propagate(int x) {
    FOR(i,1,n+1) {
        tmp[x][i] = tmp[x][i]+tmp[x][i-1];
        ans[x][i] = tmp[x][i].f*i+tmp[x][i].s;
    }
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m;
    F0R(i,n) F0R(j,m) cin >> g[i][j];
    F0R(i,n) cur[i] = m;
    F0Rd(j,m) {
        F0R(i,n) if (g[i][j] == '*') cur[i] = j;
        solve(j);
    }
    FOR(j,1,m+1) propagate(j);
    FORd(j,1,m) FOR(i,1,n+1) ans[j][i] += ans[j+1][i];
    FOR(i,1,n+1) {
        FOR(j,1,m+1) cout << ans[j][i] << "" "";
        cout << ""\n"";
    }
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Maximum Building II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<string> s(n);
    rep(i, 0, n) cin >> s[i];
    vi z(m+2), f(m+2);
    vector<vi> ans(n+2, vi(m+2));
    rep(r, 0, n) {
        rep(c, 1, m+1)
        z[c]=(s[r][c-1]=='*'? 0:z[c]+1);
        vi h(z);
        set<pii, greater<pii>> y;
        rep(c, 0, m+2) {
            int d;
            for(d=c; d<m+1; d++)
                if (h[d+1]!=h[c]) break;
            f[c]=d, f[d]=c;
            y.insert({h[c], c});
            c=d;
        }
        int L, R, H, NH;
        while ((H=h[L=begin(y)->second])) {
            R=f[L];
            NH=max(h[L-1], h[R+1]);
            ans[NH+1][R-L+1]++;
            ans[H+1][R-L+1]--;
            y.erase(begin(y));
            if(h[L-1]==NH)
                L=f[L-1], y.erase({h[L], L});
            if(h[R+1]==NH)
                y.erase({h[R+1], R+1}), R=f[R+1];
            f[L]=R, f[R]=L;
            y.insert({h[L]=h[R]=NH, L});
        }
    }
    rep(r, 1, n+1) rep(c, 1, m+1)
    ans[r][c]+=ans[r-1][c];
    rep(r, 1, n+1) {
        rep(k, 0, 2) for (int c=m; c; c--)
            ans[r][c]+=ans[r][c+1];
        rep(c, 1, m+1) cout << ans[r][c] << "" \n""[c==m];
    }
    return 0;
}
"
Maximum Building II,C++,"// https://cses.fi/problemset/task/1148
// Building II
// practice with rainboy
#include <iostream>

using namespace std;

typedef pair<int, int> pii;

const int N = 1000;

char cc[N][N + 1];
int ll[N][N], rr[N][N];
bool alive[N][N];

pii *ee[N + 1];
int kk[N + 1];

int pp[N + 1], aa[N][N];

int main() {
    int n, m;
    scanf(""%d%d"", &n, &m);
    for (int i = 0; i < n; i++)
        scanf(""%s"", cc[i]);
    for (int j = 0; j < m; j++) {
        int d = 0;
        for (int i = 0; i < n; i++) {
            if (cc[i][j] == '*')
                d = 0;
            else
                d++;
            kk[d]++;
        }
    }
    for (int d = 0; d <= n; d++) {
        ee[d] = new pii[kk[d]];
        kk[d] = 0;
    }
    for (int j = 0; j < m; j++) {
        int d = 0;
        for (int i = 0; i < n; i++) {
            if (cc[i][j] == '*')
                d = 0;
            else
                d++;
            auto &e = ee[d][kk[d]++];
            e.first = i;
            e.second = j;
        }
    }
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            ll[i][j] = rr[i][j] = j;
    for (int d = n; d > 0; d--) {
        for (int h = 0; h < kk[d]; h++) {
            auto &e = ee[d][h];
            int i = e.first;
            int j = e.second;
            alive[i][j] = true;
            int l, r;
            l = r = j;
            if (j > 0 && alive[i][j - 1]) {
                l = ll[i][j - 1];
                pp[j - l]--;
            }
            if (j < m - 1 && alive[i][j + 1]) {
                r = rr[i][j + 1];
                pp[r - j]--;
            }
            rr[i][l] = r;
            ll[i][r] = l;
            pp[r - l + 1]++;
        }
        auto &qq = aa[d - 1];
        for (int j = 1; j <= m; j++)
            qq[j - 1] = pp[j];
        for (int j = m - 2; j >= 0; j--)
            qq[j] += qq[j + 1];
        for (int j = m - 2; j >= 0; j--)
            qq[j] += qq[j + 1];
    }
    for (int d = 0; d < n; d++) {
        for (int j = 0; j < m; j++)
            printf(""%d "", aa[d][j]);
        printf(""\n"");
    }
    return 0;
}
"
Maximum Building II,C++,"/*
 https://cses.fi/problemset/task/1148
 Building II
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>

#define N    1000

char cc[N][N + 1];

int ll[N][N], rr[N][N];
char alive[N][N];

struct E {
    int i, j;
} *ee[N + 1];

int kk[N + 1], pp[N + 1], aa[N][N], *qq;

int main() {
    int n, m, h, i, j, d, l, r;
    struct E *e;
    
    scanf(""%d%d"", &n, &m);
    for (i = 0; i < n; i++)
        scanf(""%s"", cc[i]);
    for (j = 0; j < m; j++) {
        d = 0;
        for (i = 0; i < n; i++) {
            if (cc[i][j] == '*')
                d = 0;
            else
                d++;
            kk[d]++;
        }
    }
    for (d = 0; d <= n; d++) {
        ee[d] = (struct E *) malloc(kk[d] * sizeof *ee[d]);
        kk[d] = 0;
    }
    for (j = 0; j < m; j++) {
        d = 0;
        for (i = 0; i < n; i++) {
            if (cc[i][j] == '*')
                d = 0;
            else
                d++;
            e = &ee[d][kk[d]++];
            e->i = i, e->j = j;
        }
    }
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++)
            ll[i][j] = rr[i][j] = j;
    for (d = n; d > 0; d--) {
        for (h = 0; h < kk[d]; h++) {
            e = &ee[d][h];
            i = e->i, j = e->j;
            alive[i][j] = 1;
            l = r = j;
            if (j > 0 && alive[i][j - 1]) {
                l = ll[i][j - 1];
                pp[j - l]--;
            }
            if (j < m - 1 && alive[i][j + 1]) {
                r = rr[i][j + 1];
                pp[r - j]--;
            }
            rr[i][l] = r;
            ll[i][r] = l;
            pp[r - l + 1]++;
        }
        qq = aa[d - 1];
        for (j = 1; j <= m; j++)
            qq[j - 1] = pp[j];
        for (j = m - 2; j >= 0; j--)
            qq[j] += qq[j + 1];
        for (j = m - 2; j >= 0; j--)
            qq[j] += qq[j + 1];
    }
    for (d = 0; d < n; d++) {
        for (j = 0; j < m; j++)
            printf(""%d "", aa[d][j]);
        printf(""\n"");
    }
    return 0;
}
"
Maximum Xor Subarray,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;


template<int MX, int MXBIT> struct Trie {
    int nex[MX][2], sz[MX], num = 0; // num is last node in trie
    // change 2 to 26 for lowercase letters
    
    Trie() {
        memset(nex,0,sizeof nex);
        memset(sz,0,sizeof sz);
    }
    
    void ins(ll x, int a = 1) { // insert or delete
        int cur = 0; sz[cur] += a;
        F0Rd(i,MXBIT) {
            int t = (x&(1LL<<i))>>i;
            if (!nex[cur][t]) nex[cur][t] = ++num;
            sz[cur = nex[cur][t]] += a;
        }
    }
    
    ll test(ll x) { // compute max xor
        if (sz[0] == 0) return -INF; // no elements in trie
        int cur = 0;
        F0Rd(i,MXBIT) {
            int t = ((x&(1LL<<i))>>i) ^ 1;
            if (!nex[cur][t] || !sz[nex[cur][t]]) t ^= 1;
            cur = nex[cur][t]; if (t) x ^= 1LL<<i;
        }
        return x;
    }
};

Trie<7000001,30> T;

int n;

int main() {
    setIO(); re(n);
    int cur = 0; T.ins(cur);
    int ans = 0;
    F0R(i,n) {
        int x; re(x); cur ^= x;
        ckmax(ans,(int)T.test(cur));
        T.ins(cur);
    }
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Maximum Xor Subarray,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr int B=30;
vector<array<int, 2>> T(2);

void insert(int x) {
    int i=1;
    for (int b=B; b>=0; b--) {
        int w=(x>>b)&1;
        if (!T[i][w]) {
            T[i][w]=sz(T);
            T.push_back({0, 0});
        }
        i=T[i][w];
    }
}

int query(int x) {
    int i=1, val=0;
    for (int b=B; b>=0; b--) {
        int w=(x>>b)&1;
        if (T[i][w^1])
            w^=1, val|=1<<b;
        i=T[i][w];
    }
    return val;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    insert(0);
    int s=0, ans=0;
    while (n--) {
        int a;
        cin >> a;
        s^=a;
        ans=max(ans, query(s));
        insert(s);
    }
    cout << ans << '\n';
    return 0;
}
"
Maximum Xor Subarray,C++,"// https://cses.fi/problemset/task/1655
// Maximum Xor Subarray
// practice with rainboy

#include <iostream>

using namespace std;

const int N = 200000, K = 30, B = 1 << (K - 1);
int tt[N * K + 2][2], m;

void update(int x) {
    int i = 1;
    for (int b = B; b != 0; b >>= 1) {
        int j = (x & b) == 0 ? 0 : 1;
        if (tt[i][j] == 0)
            tt[i][j] = ++m;
        i = tt[i][j];
    }
}

int query(int x) {
    int i = 1;
    for (int b = B; b != 0; b >>= 1) {
        int j = (x & b) == 0 ? 0 : 1;
        if (tt[i][j ^ 1] != 0) {
            j ^= 1;
            x |= b;
        } else
            x &= ~b;
        i = tt[i][j];
    }
    return x;
}

int main() {
    int n;
    scanf(""%d"", &n);
    int x = 0, ans = 0;
    m = 1;
    while (n-- > 0) {
        int a;
        scanf(""%d"", &a);
        update(x);
        x ^= a;
        ans = max(ans, query(x));
    }
    printf(""%d\n"", ans);
    return 0;
}
"
Maximum Xor Subarray,C++,"/*
 https://cses.fi/problemset/task/1655
 Maximum Xor Subarray
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define K    30

struct T {
    struct T *tt[2];
};

struct T *new_T() {
    static struct T t91[1 + (N + 1) * K], *t = t91;
    
    return t++;
}

struct T *update(struct T *t, int x, int b) {
    if (t == NULL)
        t = new_T();
    if (b > 0) {
        int i = (x & b) != 0;
        
        t->tt[i] = update(t->tt[i], x, b >> 1);
    }
    return t;
}

int query(struct T *t, int x, int b) {
    while (b > 0) {
        int i = (x & b) == 0;
        
        if (t->tt[i])
            x |= b;
        else {
            i ^= 1;
            x &= ~b;
        }
        t = t->tt[i];
        b >>= 1;
    }
    return x;
}

int main() {
    struct T *t;
    int n, x, a, ans, y;
    
    scanf(""%d"", &n);
    x = 0;
    t = update(NULL, x, 1 << (K - 1));
    ans = 0;
    while (n--) {
        scanf(""%d"", &a), x ^= a;
        if (ans < (y = query(t, x, 1 << (K - 1))))
            ans = y;
        t = update(t, x, 1 << (K - 1));
    }
    printf(""%d\n"", ans);
    return 0;
}
"
Maximum Xor Subarray,C++,"/*
 https://cses.fi/problemset/task/1655
 Maximum Xor Subarray
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define M    (1 + N * K)
#define K    30
#define B    (1 << (K - 1))

int tt[1 + M][2], m;

int update(int i, int x, int b) {
    if (i == 0)
        i = ++m;
    if (b > 0) {
        int j = (x & b) != 0;
        
        tt[i][j] = update(tt[i][j], x, b >> 1);
    }
    return i;
}

int query(int i, int x, int b) {
    while (b > 0) {
        int j = (x & b) == 0;
        
        if (tt[i][j])
            x |= b;
        else {
            j ^= 1;
            x &= ~b;
        }
        i = tt[i][j];
        b >>= 1;
    }
    return x;
}

int main() {
    int n, x, a, i, ans, y;
    
    scanf(""%d"", &n);
    x = 0, i = 0, ans = 0;
    while (n--) {
        i = update(i, x, B);
        scanf(""%d"", &a), x ^= a;
        if (ans < (y = query(i, x, B)))
            ans = y;
    }
    printf(""%d\n"", ans);
    return 0;
}
"
Maximum Xor Subarray,C++,"/*
 https://cses.fi/problemset/task/1655
 Maximum Xor Subarray
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define M    (1 + N * K)
#define K    30
#define B    (1 << (K - 1))

int tt[1 + M][2], m;

void update(int x) {
    int b, i = 1;
    
    for (b = B; b != 0; b >>= 1) {
        int j = (x & b) != 0;
        
        if (!tt[i][j])
            tt[i][j] = ++m;
        i = tt[i][j];
    }
}

int query(int x) {
    int b, i = 1;
    
    for (b = B; b != 0; b >>= 1) {
        int j = (x & b) != 0;
        
        if (tt[i][j ^ 1]) {
            j ^= 1;
            x |= b;
        } else
            x &= ~b;
        i = tt[i][j];
    }
    return x;
}

int main() {
    int n, x, a, ans, y;
    
    scanf(""%d"", &n);
    x = 0, ans = 0;
    m = 1;
    while (n--) {
        update(x);
        scanf(""%d"", &a), x ^= a;
        if (ans < (y = query(x)))
            ans = y;
    }
    printf(""%d\n"", ans);
    return 0;
}
"
Meet in the Middle,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,d;

void dfs(vi& a, vl& b, int ind, ll sum) {
    if (ind == sz(a)) {
        b.pb(sum);
        return;
    }
    dfs(a,b,ind+1,sum);
    dfs(a,b,ind+1,sum+a[ind]);
}

vl gen(vi a) {
    vl b;
    dfs(a,b,0,0);
    sort(all(b));
    return b;
}

int main() {
    setIO(); re(n,d); vi t(n); re(t);
    vi a(t.begin(),t.begin()+n/2), b(t.begin()+n/2,t.end());
    auto x = gen(a), y = gen(b);
    int l = sz(y), r = sz(y);
    ll ans = 0;
    trav(t,x) {
        while (l > 0 && t+y[l-1] >= d) l --;
        while (r > 0 && t+y[r-1] > d) r --;
        ans += r-l;
    }
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Meet in the Middle,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

void process(vector<ll> &H, vi x) {
    int n=sz(x);
    H.resize(1<<n);
    int k=1;
    rep(i, 0, n) rep(j, 0, 1<<i)
    H[k++]=H[j]+x[i];
    sort(all(H));
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, s;
    cin >> n >> s;
    vi x(n);
    rep(i, 0, n) cin >> x[i];
    vector<ll> L, R;
    process(L, vi(begin(x), begin(x)+n/2));
    process(R, vi(begin(x)+n/2, end(x)));
    ll ans=0;
    trav(a, L) {
        auto l=lower_bound(all(R), s-a);
        auto r=upper_bound(all(R), s-a);
        ans+=r-l;
    }
    cout << ans << '\n';
    return 0;
}
"
Meet in the Middle,Java,"// https://cses.fi/problemset/task/1628
// Meet in the Middle
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1628 extends PrintWriter {
    CSES1628() {
        super(System.out, true);
        try { _bb = System.in.readAllBytes(); } catch (IOException e) {}
    }
    byte[] _bb; int _i;
    int nextInt() {
        int n = _bb.length;
        while (_i < n && _bb[_i] < 33) _i++;
        boolean minus = _bb[_i] == '-'; if (minus) _i++;
        int a = 0;
        while (_i < n && _bb[_i] > 32) a = a * 10 + _bb[_i++] - '0';
        return minus ? -a : a;
    }
    public static void main(String[] __) { new CSES1628().main(); }
    
    void main() {
        int n = nextInt();
        int x = nextInt();
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = nextInt();
        int k0 = n / 2, k1 = n - k0;
        int n0 = 1 << k0, n1 = 1 << k1;
        long[] a0 = new long[n0];
        long[] a1 = new long[n1];
        for (int i = 0; i < k0; i++)
            a0[1 << i] = aa[i];
        for (int b = 1; b < n0; b++) {
            int b_ = b & b - 1;
            a0[b] = a0[b_] + a0[b ^ b_];
        }
        for (int i = 0; i < k1; i++)
            a1[1 << i] = aa[k0 + i];
        for (int b = 1; b < n1; b++) {
            int b_ = b & b - 1;
            a1[b] = a1[b_] + a1[b ^ b_];
        }
        Arrays.sort(a0);
        Arrays.sort(a1);
        long ans = 0;
        for (int i = 0, p = n1 - 1, q = p; i < n0; i++) {
            long y = 0;
            while (q >= 0 && (y = a0[i] + a1[q]) > x)
                q--;
            if (q < 0)
                break;
            if (y == x) {
                if (p > q)
                    p = q;
                while (p > 0 && a1[p - 1] == a1[q])
                    p--;
                ans += q - p + 1;
            }
        }
        println(ans);
    }
}
"
Meet in the Middle,Java,"// https://cses.fi/problemset/task/1628
// Meet in the Middle
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1628 extends PrintWriter {
    CSES1628() {
        super(System.out, true);
        try { _bb = System.in.readAllBytes(); } catch (IOException e) {}
    }
    byte[] _bb; int _i;
    int nextInt() {
        int n = _bb.length;
        while (_i < n && _bb[_i] < 33) _i++;
        boolean minus = _bb[_i] == '-'; if (minus) _i++;
        int a = 0;
        while (_i < n && _bb[_i] > 32) a = a * 10 + _bb[_i++] - '0';
        return minus ? -a : a;
    }
    public static void main(String[] __) { new CSES1628().main(); }
    
    Random rand = new Random();
    void shuffle(long[] aa, int n) {
        for (int j = 0; j < n; j++) {
            int i = rand.nextInt(j + 1);
            long tmp = aa[i]; aa[i] = aa[j]; aa[j] = tmp;
        }
    }
    void main() {
        int n = nextInt();
        int x = nextInt();
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = nextInt();
        int k0 = n / 2, k1 = n - k0;
        int n0 = 1 << k0, n1 = 1 << k1;
        long[] a0 = new long[n0];
        long[] a1 = new long[n1];
        for (int i = 0; i < k0; i++)
            a0[1 << i] = aa[i];
        for (int b = 1; b < n0; b++) {
            int b_ = b & b - 1;
            a0[b] = a0[b_] + a0[b ^ b_];
        }
        for (int i = 0; i < k1; i++)
            a1[1 << i] = aa[k0 + i];
        for (int b = 1; b < n1; b++) {
            int b_ = b & b - 1;
            a1[b] = a1[b_] + a1[b ^ b_];
        }
        shuffle(a0, n0);
        Arrays.sort(a0);
        shuffle(a1, n1);
        Arrays.sort(a1);
        long ans = 0;
        for (int i = 0, p = n1 - 1, q = p; i < n0; i++) {
            long y = 0;
            while (q >= 0 && (y = a0[i] + a1[q]) > x)
                q--;
            if (q < 0)
                break;
            if (y == x) {
                if (p > q)
                    p = q;
                while (p > 0 && a1[p - 1] == a1[q])
                    p--;
                ans += q - p + 1;
            }
        }
        println(ans);
    }
}
"
Meet in the Middle,Java,"// https://cses.fi/problemset/task/1628
// Meet in the Middle
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1628 extends PrintWriter {
    CSES1628() {
        super(System.out, true);
        try { _bb = System.in.readAllBytes(); } catch (IOException e) {}
    }
    byte[] _bb; int _i;
    int nextInt() {
        int n = _bb.length;
        while (_i < n && _bb[_i] < 33) _i++;
        int a = 0;
        while (_i < n && _bb[_i] > 32) a = a * 10 + _bb[_i++] - '0';
        return a;
    }
    public static void main(String[] __) { new CSES1628().main(); }
    
    long[] tt;
    long[] build(int[] aa, int l, int r) {
        long[] ss = new long[1 << r - l];
        for (int k = 1; l < r; l++, k <<= 1) {
            int a = aa[l];
            for (int h = 0; h < k; h++) {
                tt[h] = ss[h];
                tt[h + k] = ss[h] + a;
            }
            int p = 0, q = k, p_ = k, q_ = k + k, h = 0;
            while (p < p_ && q < q_)
                if (tt[p] < tt[q])
                    ss[h++] = tt[p++];
                else
                    ss[h++] = tt[q++];
            while (p < p_)
                ss[h++] = tt[p++];
            while (q < q_)
                ss[h++] = tt[q++];
        }
        return ss;
    }
    void main() {
        int n = nextInt();
        int x = nextInt();
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = nextInt();
        int k0 = n / 2, k1 = n - k0, n0 = 1 << k0, n1 = 1 << k1;
        tt = new long[1 << k1];
        long[] a0 = build(aa, 0, k0);
        long[] a1 = build(aa, k0, n);
        long ans = 0;
        for (int i = 0, p = n1 - 1, q = p; i < n0; i++) {
            long y = 0;
            while (q >= 0 && (y = a0[i] + a1[q]) > x)
                q--;
            if (q < 0)
                break;
            if (y == x) {
                if (p > q)
                    p = q;
                while (p > 0 && a1[p - 1] == a1[q])
                    p--;
                ans += q - p + 1;
            }
        }
        println(ans);
    }
}
"
Meet in the Middle,C++,"/*
 https://cses.fi/problemset/task/1628
 Meet in the Middle
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    40
#define N_    (1 << (N / 2))

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

int compare(const void *a, const void *b) {
    long long la = *(long long *) a;
    long long lb = *(long long *) b;
    
    return la == lb ? 0 : la < lb ? -1 : 1;
}

int main() {
    static int aa[N];
    static long long a0[N_], a1[N_];
    int n, n0, n1, k0, k1, x, i, j, b, p, q;
    long long tmp, a, y, ans;
    
    scanf(""%d%d"", &n, &x);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    k0 = n / 2, k1 = n - k0;
    n0 = 1 << k0, n1 = 1 << k1;
    for (b = 0; b < n0; b++) {
        a = 0;
        for (i = 0; i < k0; i++)
            if (b & 1 << i)
                a += aa[i];
        a0[b] = a;
    }
    for (b = 0; b < n1; b++) {
        a = 0;
        for (i = 0; i < k1; i++)
            if (b & 1 << i)
                a += aa[k0 + i];
        a1[b] = a;
    }
    init_rand();
    for (j = 0; j < n0; j++) {
        i = rand_(j + 1);
        tmp = a0[i], a0[i] = a0[j], a0[j] = tmp;
    }
    qsort(a0, n0, sizeof *a0, compare);
    for (j = 0; j < n1; j++) {
        i = rand_(j + 1);
        tmp = a1[i], a1[i] = a1[j], a1[j] = tmp;
    }
    qsort(a1, n1, sizeof *a1, compare);
    ans = 0;
    for (i = 0, p = n1 - 1, q = p; i < n0; i++) {
        while (q >= 0 && (y = a0[i] + a1[q]) > x)
            q--;
        if (q < 0)
            break;
        if (y == x) {
            if (p > q)
                p = q;
            while (p > 0 && a1[p - 1] == a1[q])
                p--;
            ans += q - p + 1;
        }
    }
    printf(""%lld\n"", ans);
    return 0;
}
"
Meet in the Middle,C++,"/*
 https://cses.fi/problemset/task/1628
 Meet in the Middle
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    40
#define N_    (1 << (N / 2))

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

int compare(const void *a, const void *b) {
    long long la = *(long long *) a;
    long long lb = *(long long *) b;
    
    return la == lb ? 0 : la < lb ? -1 : 1;
}

int main() {
    static int aa[N];
    static long long a0[N_], a1[N_];
    int n, n0, n1, k0, k1, x, i, j, b, b_, p, q;
    long long tmp, y, ans;
    
    scanf(""%d%d"", &n, &x);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    k0 = n / 2, k1 = n - k0;
    n0 = 1 << k0, n1 = 1 << k1;
    for (i = 0; i < k0; i++)
        a0[1 << i] = aa[i];
    for (b = 1; b < n0; b++) {
        b_ = b & b - 1;
        a0[b] = a0[b_] + a0[b ^ b_];
    }
    for (i = 0; i < k1; i++)
        a1[1 << i] = aa[k0 + i];
    for (b = 1; b < n1; b++) {
        b_ = b & b - 1;
        a1[b] = a1[b_] + a1[b ^ b_];
    }
    init_rand();
    for (j = 0; j < n0; j++) {
        i = rand_(j + 1);
        tmp = a0[i], a0[i] = a0[j], a0[j] = tmp;
    }
    qsort(a0, n0, sizeof *a0, compare);
    for (j = 0; j < n1; j++) {
        i = rand_(j + 1);
        tmp = a1[i], a1[i] = a1[j], a1[j] = tmp;
    }
    qsort(a1, n1, sizeof *a1, compare);
    ans = 0;
    for (i = 0, p = n1 - 1, q = p; i < n0; i++) {
        while (q >= 0 && (y = a0[i] + a1[q]) > x)
            q--;
        if (q < 0)
            break;
        if (y == x) {
            if (p > q)
                p = q;
            while (p > 0 && a1[p - 1] == a1[q])
                p--;
            ans += q - p + 1;
        }
    }
    printf(""%lld\n"", ans);
    return 0;
}
"
Meet in the Middle,C++,"/*
 https://cses.fi/problemset/task/1628
 Meet in the Middle
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    40
#define N_    (1 << (N / 2))

void build(int *aa, long long *ss, int l, int r) {
    static long long tt[N_];
    int a, h, k, p, p_, q, q_;
    
    ss[0] = 0;
    for (k = 1; l < r; l++, k <<= 1) {
        a = aa[l];
        for (h = 0; h < k; h++) {
            tt[h] = ss[h];
            tt[h + k] = ss[h] + a;
        }
        p = 0, q = k, p_ = k, q_ = k + k, h = 0;
        while (p < p_ && q < q_)
            if (tt[p] < tt[q])
                ss[h++] = tt[p++];
            else
                ss[h++] = tt[q++];
        while (p < p_)
            ss[h++] = tt[p++];
        while (q < q_)
            ss[h++] = tt[q++];
    }
}

int main() {
    static int aa[N];
    static long long a0[N_], a1[N_];
    int n, n0, n1, k0, k1, x, i, p, q;
    long long y, ans;
    
    scanf(""%d%d"", &n, &x);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    k0 = n / 2, k1 = n - k0, n0 = 1 << k0, n1 = 1 << k1;
    build(aa, a0, 0, k0);
    build(aa, a1, k0, n);
    ans = 0;
    for (i = 0, p = n1 - 1, q = p; i < n0; i++) {
        while (q >= 0 && (y = a0[i] + a1[q]) > x)
            q--;
        if (q < 0)
            break;
        if (y == x) {
            if (p > q)
                p = q;
            while (p > 0 && a1[p - 1] == a1[q])
                p--;
            ans += q - p + 1;
        }
    }
    printf(""%lld\n"", ans);
    return 0;
}
"
Meet in the Middle,C++,"/*
 https://cses.fi/problemset/task/1628
 Meet in the Middle
 practice with Dukkha
 */
#include <stdio.h>

#define N    40
#define N_    (1 << (N / 2))

void build(int *aa, long long *ss, int l, int r) {
    static long long tt[N_];
    int a, h, k, p, p_, q, q_;
    
    ss[0] = 0;
    for (k = 1; l < r; l++, k <<= 1) {
        a = aa[l];
        for (h = 0; h < k; h++) {
            tt[h] = ss[h];
            tt[h + k] = ss[h] + a;
        }
        p = 0, q = k, p_ = k, q_ = k + k, h = 0;
        while (p < p_ && q < q_)
            if (tt[p] < tt[q])
                ss[h++] = tt[p++];
            else
                ss[h++] = tt[q++];
        while (p < p_)
            ss[h++] = tt[p++];
        while (q < q_)
            ss[h++] = tt[q++];
    }
}

int main() {
    static int aa[N];
    static long long a0[N_], a1[N_];
    int n, n0, n1, k0, k1, x, i, p, q;
    long long y, ans;
    
    scanf(""%d%d"", &n, &x);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    k0 = n / 2, k1 = n - k0, n0 = 1 << k0, n1 = 1 << k1;
    build(aa, a0, 0, k0);
    build(aa, a1, k0, n);
    ans = 0;
    for (i = 0, p = n1 - 1, q = p; i < n0; i++) {
        while (q >= 0 && (y = a0[i] + a1[q]) > x)
            q--;
        if (q < 0)
            break;
        if (y == x) {
            if (p > q)
                p = q;
            while (p > 0 && a1[p - 1] == a1[q])
                p--;
            ans += q - p + 1;
        }
    }
    printf(""%lld\n"", ans);
    return 0;
}
"
Movie Festival Queries,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 1000005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,q;
int nex[MX][20];

int main() {
    setIO(); re(n,q);
    F0R(i,MX) nex[i][0] = MX-1;
    F0R(i,n) {
        int a,b; re(a,b);
        ckmin(nex[a][0],b);
    }
    FORd(i,1,MX) ckmin(nex[i-1][0],nex[i][0]);
    FOR(j,1,20) F0R(i,MX) nex[i][j] = nex[nex[i][j-1]][j-1];
    F0R(i,q) {
        int a,b; re(a,b);
        int ans = 0;
        F0Rd(j,20) if (nex[a][j] <= b) {
            ans ^= 1<<j;
            a = nex[a][j];
        }
        ps(ans);
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Movie Festival Queries,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int inf=1e9;
    constexpr int B=20;
    int n, q;
    cin >> n >> q;
    vector<pii> x(n);
    rep(i, 0, n) cin >> x[i].first >> x[i].second;
    sort(all(x));
    x.push_back({inf, inf});
    vector<pii> y(x);
    y.back().second=n;
    int cur=n;
    for (int i=n-1; i>=0; i--) {
        if (x[i].second<=x[cur].second)
            cur=i;
        y[i].second=cur;
    }
    auto nxt=[&](int t) {
        return lower_bound(all(y), pii{t, 0})->second;
    };
    vector<vi> t(n+1, vi(B));
    rep(i, 0, n+1)
    t[i][0]=nxt(x[i].second);
    rep(b, 1, B) rep(i, 0, n+1)
    t[i][b]=t[t[i][b-1]][b-1];
    while (q--) {
        int L, R;
        cin >> L >> R;
        int i=nxt(L), ans=(x[i].second<=R);
        for (int b=B-1; b>=0; b--) {
            if (x[t[i][b]].second<=R)
                i=t[i][b], ans+=1<<b;
        }
        cout << ans << '\n';
    }
    return 0;
}
"
Movie Festival Queries,Java,"// https://cses.fi/problemset/task/1664
// Movie Festival Queries
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1664 extends PrintWriter {
    CSES1664() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) { new CSES1664().main(); }
    
    static final int A = 1000000;
    static class V {
        int a, b;
        V(int a, int b) {
            this.a = a; this.b = b;
        }
    }
    void main() {
        int n = sc.nextInt();
        int q = sc.nextInt();
        V[] vv = new V[n];
        for (int i = 0; i < n; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            vv[i] = new V(a, b);
        }
        int k = 0;
        while (1 << k + 1 <= n)
            k++;
        int[][] pp = new int[k + 1][A + 1];
        Arrays.sort(vv, (u, v) -> u.b - v.b);
        for (int a = 0, b = 0, i = 0; b <= A; b++) {
            while (i < n && vv[i].b == b) {
                a = Math.max(a, vv[i].a);
                i++;
            }
            pp[0][b] = a;
        }
        for (int h = 1; h <= k; h++)
            for (int a = 0; a <= A; a++)
                pp[h][a] = pp[h - 1][pp[h - 1][a]];
        while (q-- > 0) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            int m = 0;
            for (int h = k; h >= 0; h--)
                if (pp[h][b] >= a) {
                    b = pp[h][b];
                    m += 1 << h;
                }
            println(m);
        }
        flush();
    }
}
"
Movie Festival Queries,C++,"/*
 https://cses.fi/problemset/task/1664
 Movie Festival Queries
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    200000
#define A    1000000
#define K    17    /* K = floor(log2(N)) */

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

struct V {
    int a, b;
} vv[N];

int compare(const void *a, const void *b) {
    struct V *u = (struct V *) a;
    struct V *v = (struct V *) b;
    
    return u->b - v->b;
}

int main() {
    static int pp[K + 1][A + 1];
    int n, q, h, i, j, a, a_, b, m;
    struct V tmp;
    
    init_rand();
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++) {
        struct V *v = &vv[i];
        
        scanf(""%d%d"", &v->a, &v->b);
    }
    for (j = 0; j < n; j++) {
        i = rand_(j + 1);
        tmp = vv[i], vv[i] = vv[j], vv[j] = tmp;
    }
    qsort(vv, n, sizeof *vv, compare);
    for (a = 0, b = 0, i = 0; b <= A; b++) {
        while (i < n && vv[i].b == b) {
            if (a < (a_ = vv[i].a))
                a = a_;
            i++;
        }
        pp[0][b] = a;
    }
    for (h = 1; h <= K; h++)
        for (a = 0; a <= A; a++)
            pp[h][a] = pp[h - 1][pp[h - 1][a]];
    while (q--) {
        scanf(""%d%d"", &a, &b);
        m = 0;
        for (h = K; h >= 0; h--)
            if (pp[h][b] >= a) {
                b = pp[h][b];
                m += 1 << h;
            }
        printf(""%d\n"", m);
    }
    return 0;
}
"
Network Breakdown,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;


template<int SZ> struct DSU {
    int par[SZ], sz[SZ];
    
    DSU() {
        F0R(i,SZ) par[i] = i, sz[i] = 1;
    }
    
    int get(int x) { // path compression
        if (par[x] != x) par[x] = get(par[x]);
        return par[x];
    }
    
    bool unite(int x, int y) { // union-by-rank
        x = get(x), y = get(y);
        if (x == y) return 0;
        if (sz[x] < sz[y]) swap(x,y);
        sz[x] += sz[y], par[y] = x;
        return 1;
    }
};

int n,m,k;
DSU<MX> D;
set<pi> ed;
vpi rem;

int main() {
    setIO();  re(n,m,k);
    F0R(i,m) {
        int a,b; re(a,b); if (a > b) swap(a,b);
        ed.insert({a,b});
    }
    F0R(i,k) {
        int a,b; re(a,b); if (a > b) swap(a,b);
        rem.pb({a,b}); ed.erase({a,b});
    }
    reverse(all(rem));
    int cnt = n;
    trav(t,ed) if (D.unite(t.f,t.s)) cnt --;
    vi ans;
    trav(t,rem) {
        ans.pb(cnt);
        cnt -= D.unite(t.f,t.s);
    }
    reverse(all(ans));
    trav(t,ans) pr(t,' ');
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Network Breakdown,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

struct UF {
    vi e;
    UF(int n) : e(n, -1) {}
    bool same_set(int a, int b) { return find(a) == find(b); }
    int size(int x) { return -e[find(x)]; }
    int find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }
    bool join(int a, int b) {
        a = find(a), b = find(b);
        if (a == b) return false;
        if (e[a] > e[b]) swap(a, b);
        e[a] += e[b]; e[b] = a;
        return true;
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m, q;
    cin >> n >> m >> q;
    set<pii> e;
    while (m--) {
        int a, b;
        cin >> a >> b;
        if (a>b) swap(a, b);
        e.insert({a, b});
    }
    vi L(q), R(q), ans(q);
    rep(i, 0, q) {
        cin >> L[i] >> R[i];
        if (L[i]>R[i]) swap(L[i], R[i]);
        e.erase({L[i], R[i]});
    }
    UF x(n+1);
    int c=n;
    trav(p, e) c-=x.join(p.first, p.second);
    for(int i=q-1; i>=0; i--) {
        ans[i]=c;
        c-=x.join(L[i], R[i]);
    }
    rep(i, 0, q)
    cout << ans[i] << "" \n""[i==q-1];
    return 0;
}
"
Network Breakdown,Java,"// https://cses.fi/problemset/task/1677
// Network Breakdown
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1677 extends PrintWriter {
    CSES1677() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1677 o = new CSES1677(); o.main(); o.flush();
    }
    
    int[] dsu;
    int find(int i) {
        return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));
    }
    boolean join(int i, int j) {
        i = find(i);
        j = find(j);
        if (i == j)
            return false;
        if (dsu[i] > dsu[j])
            dsu[i] = j;
        else {
            if (dsu[i] == dsu[j])
                dsu[i]--;
            dsu[j] = i;
        }
        return true;
    }
    void main() {
        int n = sc.nextInt();
        int m = sc.nextInt();
        int k = sc.nextInt();
        int[] aa = new int[m + k];
        int[] bb = new int[m + k];
        Integer[] ii = new Integer[m + k];
        for (int h = 0; h < m + k; h++) {
            int a = sc.nextInt() - 1;
            int b = sc.nextInt() - 1;
            if (a > b) {
                int tmp = a; a = b; b = tmp;
            }
            aa[h] = a;
            bb[h] = b;
            ii[h] = h;
        }
        Arrays.sort(ii, (i, j) -> aa[i] != aa[j] ? aa[i] - aa[j] : bb[i] - bb[j]);
        boolean[] dup = new boolean[m + k];
        for (int h = 1; h < m + k; h++) {
            int i = ii[h - 1], j = ii[h];
            if (aa[i] == aa[j] && bb[i] == bb[j])
                dup[i] = dup[j] = true;
        }
        dsu = new int[n];
        Arrays.fill(dsu, -1);
        int c = n;
        for (int h = 0; h < m; h++)
            if (!dup[h])
                if (join(aa[h], bb[h]))
                    c--;
        int[] ans = new int[k];
        for (int h = k - 1; h >= 0; h--) {
            ans[h] = c;
            if (join(aa[m + h], bb[m + h]))
                c--;
        }
        for (int h = 0; h < k; h++)
            print(ans[h] + "" "");
        println();
    }
}
"
Network Breakdown,Java,"// https://cses.fi/problemset/task/1677
// Network Breakdown
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1677 extends PrintWriter {
    CSES1677() { super(System.out); }
    byte[] __; int $;
    { try { __ = System.in.readAllBytes(); } catch (IOException e) {} }
    int nextInt() {
        while ($ < __.length && __[$] <= 32) $++;
        int a = 0;
        while ($ < __.length && __[$] > 32) a = a * 10 + __[$++] - '0';
        return a;
    }
    public static void main(String[] $) {
        CSES1677 o = new CSES1677(); o.main(); o.flush();
    }
    
    int[] dsu;
    int find(int i) {
        return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));
    }
    boolean join(int i, int j) {
        i = find(i);
        j = find(j);
        if (i == j)
            return false;
        if (dsu[i] > dsu[j])
            dsu[i] = j;
        else {
            if (dsu[i] == dsu[j])
                dsu[i]--;
            dsu[j] = i;
        }
        return true;
    }
    void main() {
        int n = nextInt();
        int m = nextInt();
        int k = nextInt();
        int[] aa = new int[m + k];
        int[] bb = new int[m + k];
        Integer[] ii = new Integer[m + k];
        for (int h = 0; h < m + k; h++) {
            int a = nextInt() - 1;
            int b = nextInt() - 1;
            if (a > b) {
                int tmp = a; a = b; b = tmp;
            }
            aa[h] = a;
            bb[h] = b;
            ii[h] = h;
        }
        Arrays.sort(ii, (i, j) -> aa[i] != aa[j] ? aa[i] - aa[j] : bb[i] - bb[j]);
        boolean[] dup = new boolean[m + k];
        for (int h = 1; h < m + k; h++) {
            int i = ii[h - 1], j = ii[h];
            if (aa[i] == aa[j] && bb[i] == bb[j])
                dup[i] = dup[j] = true;
        }
        dsu = new int[n];
        Arrays.fill(dsu, -1);
        int c = n;
        for (int h = 0; h < m; h++)
            if (!dup[h])
                if (join(aa[h], bb[h]))
                    c--;
        int[] ans = new int[k];
        for (int h = k - 1; h >= 0; h--) {
            ans[h] = c;
            if (join(aa[m + h], bb[m + h]))
                c--;
        }
        for (int h = 0; h < k; h++)
            print(ans[h] + "" "");
        println();
    }
}
"
Network Breakdown,C++,"/*
 https://cses.fi/problemset/task/1677
 Network Breakdown
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>

#define N    100000
#define M    200000
#define K    200000

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

int aa[M + K], bb[M + K];

int compare(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return aa[i] != aa[j] ? aa[i] - aa[j] : bb[i] - bb[j];
}

int dsu[N];

int find(int i) {
    return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));
}

int join(int i, int j) {
    i = find(i);
    j = find(j);
    if (i == j)
        return 0;
    if (dsu[i] > dsu[j])
        dsu[i] = j;
    else {
        if (dsu[i] == dsu[j])
            dsu[i]--;
        dsu[j] = i;
    }
    return 1;
}

int main() {
    static int ii[M + K], ans[K];
    static char dup[M + K];
    int n, m, k, h, i, j, tmp, c;
    
    init_rand();
    scanf(""%d%d%d"", &n, &m, &k);
    for (h = 0; h < m + k; h++) {
        scanf(""%d%d"", &aa[h], &bb[h]), aa[h]--, bb[h]--;
        if (aa[h] > bb[h])
            tmp = aa[h], aa[h] = bb[h], bb[h] = tmp;
    }
    for (h = 0; h < m + k; h++)
        ii[h] = h;
    for (j = 0; j < m + k; j++) {
        i = rand_(j + 1);
        tmp = ii[i], ii[i] = ii[j], ii[j] = tmp;
    }
    qsort(ii, m + k, sizeof *ii, compare);
    for (h = 1; h < m + k; h++) {
        i = ii[h - 1];
        j = ii[h];
        if (aa[i] == aa[j] && bb[i] == bb[j])
            dup[i] = dup[j] = 1;
    }
    memset(dsu, -1, n * sizeof *dsu);
    c = n;
    for (h = 0; h < m; h++)
        if (!dup[h] && join(aa[h], bb[h]))
            c--;
    for (h = k - 1; h >= 0; h--) {
        ans[h] = c;
        if (join(aa[m + h], bb[m + h]))
            c--;
    }
    for (h = 0; h < k; h++)
        printf(""%d "", ans[h]);
    printf(""\n"");
    return 0;
}
"
Network Renovation,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n, sz[MX], par[MX];
vi adj[MX];

void dfs(int a) {
    if (sz(adj[a]) == 1) sz[a] = 1;
    trav(t,adj[a]) if (t != par[a]) {
        par[t] = a;
        dfs(t); sz[a] += sz[t];
    }
}

vi leaf;
vector<vi> leafs;

void dfs2(int a, int b) {
    if (sz(adj[a]) == 1) {
        leaf.pb(a);
        return;
    }
    trav(t,adj[a]) if (t != b) dfs2(t,a);
}

int main() {
    setIO(); re(n);
    F0R(i,n-1) {
        int a,b; re(a,b);
        adj[a].pb(b), adj[b].pb(a);
    }
    dfs(1);
    int tot = sz[1]; int cur = 1;
    while (1) {
        bool bad = 0;
        trav(t,adj[cur]) if (t != par[cur] && 2*sz[t] > tot) {
            cur = t;
            bad = 1;
            break;
        }
        if (!bad) break;
    }
    if (sz(adj[cur]) == 1) leafs.pb({cur});
    trav(t,adj[cur]) {
        dfs2(t,cur);
        leafs.pb(leaf); leaf.clear();
    }
    ps((sz[1]+1)/2);
    priority_queue<pi> pq;
    F0R(i,sz(leafs)) pq.push({sz(leafs[i]),i});
    vpi ed;
    while (sz(pq) > 1) {
        auto a = pq.top(); pq.pop();
        auto b = pq.top(); pq.pop();
        ed.pb({leafs[a.s].back(),leafs[b.s].back()});
        leafs[a.s].pop_back(); leafs[b.s].pop_back();
        if (a.f > 1) pq.push({a.f-1,a.s});
        if (b.f > 1) pq.push({b.f-1,b.s});
    }
    if (sz(pq) == 1) {
        assert(pq.top().f == 1);
        ed.pb({cur,leafs[pq.top().s].back()});
    }
    // ps(sz(ed));
    trav(t,ed) ps(t.f,t.s);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Network Renovation,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int nl;
vector<vi> g, a;
vi sl;

int dfs1(int i, int p) {
    int r, ml=0;
    trav(j, g[i]) if (j!=p) {
        if ((r=dfs1(j, i))) return r;
        sl[i]+=sl[j];
        ml=max(ml, sl[j]);
    }
    ml=max(ml, nl-sl[i]);
    return (sz(g[i])>1 && 2*ml<=nl? i:0);
}

void dfs2(int i, int p) {
    trav(j, g[i]) if(j!=p)
        dfs2(j, i);
    if (sz(g[i])==1)
        a.back().push_back(i);
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    g.resize(n+1);
    sl.resize(n+1);
    rep(i, 0, n-1) {
        int a, b;
        cin >> a >>b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    rep(i, 1, n+1) if (sz(g[i])==1)
        sl[i]=1, nl++;
    int r=dfs1(1, 0);
    trav(i, g[r]) {
        a.push_back({});
        dfs2(i, r);
    }
    if (nl%2) {
        int i=0;
        rep(j, 0, sz(a))
        if(sz(a[j])<sz(a[i])) i=j;
        a[i].push_back(a[i].back());
        
    }
    set<pii, greater<pii>> x;
    rep(i, 0, sz(a))
    x.insert({sz(a[i]), i});
    cout << (nl+1)/2 << '\n';
    while (sz(x)) {
        int s1, s2, i1, i2;
        tie(s1, i1)=*begin(x);
        x.erase(begin(x));
        tie(s2, i2)=*begin(x);
        x.erase(begin(x));
        cout << a[i1].back() << "" "" << a[i2].back() << '\n';
        a[i1].pop_back();
        a[i2].pop_back();
        if (s1>1) x.insert({s1-1, i1});
        if (s2>1) x.insert({s2-1, i2});
    }
    return 0;
}
"
Network Renovation,Java,"// https://cses.fi/problemset/task/1704
// Network Renovation
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1704 extends PrintWriter {
    CSES1704() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1704 c = new CSES1704(); c.main(); c.flush();
    }
    
    ArrayList[] aa;
    int[] uu, vv, ii;
    void dfs(int p, int i) {
        ArrayList<Integer> adj = aa[i];
        for (int j : adj)
            if (j != p)
                dfs(i, j);
        int m = 0;
        for (int j : adj)
            if (j != p) {
                if (uu[j] > 0)
                    m++;
                if (vv[j] > 0)
                    m++;
            }
        if (m == 0) {
            uu[i] = i;
            return;
        }
        int x = 0, y = m - 1;
        for (int j : adj)
            if (j != p) {
                if (vv[j] > 0) {
                    ii[x++] = uu[j];
                    ii[x++] = vv[j];
                } else
                    ii[y--] = uu[j];
            }
        uu[i] = ii[0];
        if (m % 2 == 0)
            vv[i] = ii[m - 1];
        for (int z = 0; z < (m - 1) / 2; z++) {
            x = z * 2 + 1;
            y = z * 2 + 2;
            println(ii[x] + "" "" + ii[y]);
        }
    }
    void main() {
        int n = sc.nextInt();
        aa = new ArrayList[n + 1];
        for (int i = 1; i <= n; i++)
            aa[i] = new ArrayList<Integer>();
        for (int h = 0; h < n - 1; h++) {
            int i = sc.nextInt();
            int j = sc.nextInt();
            aa[i].add(j);
            aa[j].add(i);
        }
        uu = new int[n + 1];
        vv = new int[n + 1];
        ii = new int[n];
        int m = 0, r = 0;
        for (int i = 1; i <= n; i++)
            if (aa[i].size() == 1)
                m++;
            else
                r = i;
        println((m + 1) / 2);
        dfs(-1, r);
        println(uu[r] + "" "" + (vv[r] > 0 ? vv[r] : r));
    }
}
"
Network Renovation,Java,"// https://cses.fi/problemset/task/1704
// Network Renovation
// upsolve with rainboy
// https://cses.fi/problemset/hack/1704/entry/169196/ (Noam527)
import java.io.*;
import java.util.*;

public class CSES1704 extends PrintWriter {
    CSES1704() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1704 c = new CSES1704(); c.main(); c.flush();
    }
    
    ArrayList[] aa;
    int[] ii;
    int n;
    void dfs(int p, int i) {
        ArrayList<Integer> adj = aa[i];
        if (adj.size() == 1)
            ii[n++] = i;
        else
            for (int j : adj)
                if (j != p)
                    dfs(i, j);
    }
    void main() {
        n = sc.nextInt();
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        for (int h = 0; h < n - 1; h++) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            aa[i].add(j);
            aa[j].add(i);
        }
        int r = 0;
        while (aa[r].size() == 1)
            r++;
        ii = new int[n];
        n = 0;
        dfs(-1, r);
        int m = (n + 1) / 2, c = m - 1;
        println(m);
        for (int h = 0; h < c; h++)
            println(ii[h] + 1 + "" "" + (ii[c * 2 - h] + 1));
        println(ii[c] + 1 + "" "" + (ii[n - 1] + 1));
    }
}
"
Network Renovation,C++,"/*
 https://cses.fi/problemset/task/1704
 Network Renovation
 practice with Dukkha
 */
#include <stdio.h>

#define N    100000

struct L {
    struct L *next;
    int j;
} aa[N + 1];

int uu[N + 1], vv[N + 1];

void link(int i, int j) {
    static struct L l91[N * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next, aa[i].next = l++;
}

void dfs(int p, int i) {
    static int ii[N];
    struct L *l;
    int m, x, y, z, j;
    
    for (l = aa[i].next; l; l = l->next)
        if ((j = l->j) != p)
            dfs(i, l->j);
    m = 0;
    for (l = aa[i].next; l; l = l->next)
        if ((j = l->j) != p) {
            if (uu[j] > 0)
                m++;
            if (vv[j] > 0)
                m++;
        }
    if (m == 0) {
        uu[i] = i;
        return;
    }
    x = 0, y = m - 1;
    for (l = aa[i].next; l; l = l->next)
        if ((j = l->j) != p)
            if (vv[j] > 0) {
                ii[x++] = uu[j];
                ii[x++] = vv[j];
            } else
                ii[y--] = uu[j];
    uu[i] = ii[0];
    if (m % 2 == 0)
        vv[i] = ii[m - 1];
    for (z = 0; z < (m - 1) / 2; z++) {
        x = z * 2 + 1;
        y = z * 2 + 2;
        printf(""%d %d\n"", ii[x], ii[y]);
    }
}

int main() {
    int n, h, i, j, r, m;
    
    scanf(""%d"", &n);
    for (h = 0; h < n - 1; h++) {
        scanf(""%d%d"", &i, &j);
        link(i, j);
        link(j, i);
    }
    m = 0, r = 0;
    for (i = 1; i <= n; i++)
        if (!aa[i].next->next)
            m++;
        else
            r = i;
    printf(""%d\n"", (m + 1) / 2);
    dfs(-1, r);
    printf(""%d %d\n"", uu[r], vv[r] ? vv[r] : r);
    return 0;
}
"
Network Renovation,C++,"/*
 https://cses.fi/problemset/task/1704
 Network Renovation
 upsolve with Dukkha
 https://cses.fi/problemset/hack/1704/entry/169196/ (Noam527)
 */
#include <stdio.h>

#define N    100000

struct L {
    struct L *next;
    int j;
} aa[N];

int ii[N], n;

void link(int i, int j) {
    static struct L l91[N * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next, aa[i].next = l++;
}

void dfs(int p, int i) {
    struct L *l;
    
    if (!aa[i].next->next)
        ii[n++] = i;
    else
        for (l = aa[i].next; l; l = l->next)
            if (l->j != p)
                dfs(i, l->j);
}

int main() {
    int h, i, j, r, m, c;
    
    scanf(""%d"", &n);
    for (h = 0; h < n - 1; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j);
        link(j, i);
    }
    r = 0;
    while (!aa[r].next->next)
        r++;
    n = 0;
    dfs(-1, r);
    m = (n + 1) / 2, c = m - 1;
    printf(""%d\n"", m);
    for (h = 0; h < m - 1; h++)
        printf(""%d %d\n"", ii[h] + 1, ii[c * 2 - h] + 1);
    printf(""%d %d\n"", ii[c] + 1, ii[n - 1] + 1);
    return 0;
}
"
New Flight Routes,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

vi ADJ[MX], RADJ[MX];
bool con[MX];
int out[MX], in[MX];
set<int> OUT[MX], IN[MX];

template<int SZ> struct scc {
    int N, comp[SZ];
    vi adj[SZ], radj[SZ], todo, allComp;
    bitset<SZ> visit;
    
    void addEdge(int a, int b) { adj[a].pb(b), radj[b].pb(a); }
    
    void dfs(int v) {
        visit[v] = 1;
        trav(w,adj[v]) if (!visit[w]) dfs(w);
        todo.pb(v);
    }
    
    void dfs2(int v, int val) {
        comp[v] = val;
        trav(w,radj[v]) if (comp[w] == -1) dfs2(w,val);
    }
    
    void genSCC(int _N) { // fills allComp
        N = _N;
        FOR(i,1,N+1) comp[i] = -1, visit[i] = 0;
        FOR(i,1,N+1) if (!visit[i]) dfs(i);
        reverse(all(todo)); // toposort
        trav(i,todo) if (comp[i] == -1) dfs2(i,i), allComp.pb(i);
        FOR(i,1,N+1) con[comp[i]] = 1;
        FOR(i,1,N+1) trav(j,adj[i]) if (comp[i] != comp[j]) {
            ADJ[comp[i]].pb(comp[j]);
            RADJ[comp[j]].pb(comp[i]);
        }
    }
};

scc<MX> S;
int n,m;

void init() {
    setIO(); re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        S.addEdge(a,b);
    }
    S.genSCC(n);
    if (sz(S.allComp) == 1) {
        ps(0);
        exit(0);
    }
}

void addEdge(int a, int b) {
    OUT[a].insert(b), IN[b].insert(a);
}

bool done[MX];

int main() {
    init();
    // ps(S.allComp);
    F0Rd(i,sz(S.allComp)) {
        int t = S.allComp[i];
        if (!sz(ADJ[t])) out[t] = t;
        else trav(u,ADJ[t]) ckmax(out[t],out[u]);
        if (!sz(RADJ[t])) addEdge(t,out[t]);
    }
    F0R(i,sz(S.allComp)) {
        int t = S.allComp[i];
        if (!sz(RADJ[t])) in[t] = t;
        else trav(u,RADJ[t]) ckmax(in[t],in[u]);
        if (!sz(ADJ[t]) && !sz(IN[t])) {
            if (sz(OUT[in[t]]) == 1) {
                int x = *OUT[in[t]].begin();
                if (sz(IN[x]) > 1) {
                    IN[x].erase(in[t]);
                    OUT[in[t]].erase(x);
                }
            }
            addEdge(in[t],t);
        }
    }
    // trav(t,S.allComp) ps(t,OUT[t],IN[t]);
    vector<pair<vi,vi>> v;
    trav(t,S.allComp) if (sz(OUT[t]) && !done[t]) {
        pair<vi,vi> p;
        if (sz(OUT[t]) > 1) {
            p.f.pb(t);
            trav(x,OUT[t]) {
                assert(sz(IN[x]) == 1);
                p.s.pb(x);
            }
        } else {
            trav(x,IN[*OUT[t].begin()]) {
                assert(sz(OUT[x]) == 1);
                done[x] = 1;
                p.f.pb(x);
            }
            p.s.pb(*OUT[t].begin());
        }
        v.pb(p);
    }
    // ps(v);
    vpi des;
    vi a,b;
    F0R(i,sz(v)) {
        int j = (i+1)%sz(v);
        des.pb({v[i].s.back(),v[j].f.back()});
        v[i].s.pop_back(); v[j].f.pop_back();
    }
    F0R(i,sz(v)) {
        a.insert(a.end(),all(v[i].f));
        b.insert(b.end(),all(v[i].s));
    }
    while (sz(a) && sz(b)) {
        des.pb({b.back(),a.back()});
        a.pop_back(), b.pop_back();
    }
    while (sz(a)) {
        des.pb({des[0].f,a.back()});
        a.pop_back();
    }
    while (sz(b)) {
        des.pb({b.back(),des[0].f});
        b.pop_back();
    }
    ps(sz(des));
    trav(t,des) ps(t.f,t.s);
    // trav(t,S.allComp) if (sz(ADJ[t]) == 0) ps(t);
    /*vi a,b;
     trav(t,S.allComp) {
     if (!S.in[t]) a.pb(t);
     if (!S.out[t]) b.pb(t);
     }
     ps(a,b);*/
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
New Flight Routes,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vi val, comp, z, cont;
int Time, ncomps;
template<class G, class F> int dfs(int j, G& g, F& f) {
    int low = val[j] = ++Time, x; z.push_back(j);
    trav(e,g[j]) if (comp[e] < 0)
        low = min(low, val[e] ?: dfs(e,g,f));
    
    if (low == val[j]) {
        do {
            x = z.back(); z.pop_back();
            comp[x] = ncomps;
            cont.push_back(x);
        } while (x != j);
        f(cont); cont.clear();
        ncomps++;
    }
    return val[j] = low;
}
template<class G, class F> void scc(G& g, F f) {
    int n = sz(g);
    val.assign(n, 0); comp.assign(n, -1);
    Time = ncomps = 0;
    rep(i,0,n) if (comp[i] < 0) dfs(i, g, f);
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<vi> g(n), gr(n);
    while (m--) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        g[a].push_back(b);
        gr[b].push_back(a);
    }
    vi repr;
    scc(g, [&](vi &c){
        repr.push_back(c[0]);
    });
    if (ncomps==1) {
        cout << ""0\n"";
        return 0;
    }
    vector<vi> gc(ncomps), gcr(ncomps);
    vi issrc(ncomps, 1), issnk(ncomps, 1);
    rep(i, 0, n) trav(j, g[i]) {
        if (comp[i]==comp[j]) continue;
        gc[comp[i]].push_back(comp[j]);
        gcr[comp[j]].push_back(comp[i]);
        issnk[comp[i]]=issrc[comp[j]]=0;
    }
    vi dsrc(ncomps, -1), dsnk(ncomps, -1);
    for(int i=0; i<ncomps; i++) {
        if (issnk[i]) dsnk[i]=i;
        trav(j, gcr[i]) dsnk[j]=dsnk[i];
    }
    for(int i=ncomps-1; i>=0; i--) {
        if (issrc[i]) dsrc[i]=i;
        trav(j, gc[i]) dsrc[j]=dsrc[i];
    }
    vi L(ncomps, -1), R(ncomps, -1), dL(ncomps), dR(ncomps);
    int nL=0, nR=0;
    rep(i, 0, ncomps) {
        if (issrc[i]) {
            L[i]=dsnk[i];
            dR[L[i]]++;
            nL++;
        }
        if (issnk[i]) {
            R[i]=dsrc[i];
            dL[R[i]]++;
            nR++;
        }
    }
    vi L0, R0;
    rep(i, 0, ncomps) {
        if(L[i]>=0 && dL[i]==0) L0.push_back(i);
        if(R[i]>=0 && dR[i]==0) R0.push_back(i);
    }
    auto remove=[&](int i, vi &A, vi &B0, vi &dB, int &nA) {
        nA--;
        if (--dB[A[i]]==0) B0.push_back(A[i]);
        A[i]=-1;
    };
    vector<pii> ans;
    for(;;) {
        if (sz(L0) && sz(R0)) {
            int l=L0.back(), r=R0.back();
            L0.pop_back(), R0.pop_back();
            ans.push_back({r, l});
            remove(l, L, R0, dR, nL);
            remove(r, R, L0, dL, nR);
        }
        else if (sz(L0) && nL>nR) {
            int l=L0.back();
            L0.pop_back();
            ans.push_back({L[l], l});
            remove(l, L, R0, dR, nL);
        }
        else if (sz(R0) && nR>nL) {
            int r=R0.back();
            R0.pop_back();
            ans.push_back({r, R[r]});
            remove(r, R, L0, dL, nR);
        }
        else if (!sz(R0)) {
            vi Ls, Rs;
            rep(i, 0, ncomps) if(L[i]>=0) {
                Ls.push_back(i);
                Rs.push_back(L[i]);
            }
            rep(i, 0, sz(Ls))
            ans.push_back({Rs[i], Ls[(i+1)%sz(Ls)]});
            break;
        }
        else if (!sz(L0)) {
            vi Ls, Rs;
            rep(i, 0, ncomps) if(R[i]>=0) {
                Rs.push_back(i);
                Ls.push_back(R[i]);
            }
            rep(i, 0, sz(Ls))
            ans.push_back({Rs[i], Ls[(i+1)%sz(Ls)]});
            break;
        }
    }
    cout << sz(ans) << '\n';
    trav(p, ans)
    cout << repr[p.first]+1 << "" "" << repr[p.second]+1 << '\n';
    return 0;
}
"
New Flight Routes,Java,"// https://cses.fi/problemset/task/1685
// New Flight Routes
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1685 extends PrintWriter {
    CSES1685() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1685 o = new CSES1685(); o.main(); o.flush();
    }
    
    ArrayList[] aa, bb;
    boolean[] visited;
    int[] po;
    int npo;
    void dfs1(int i) {
        if (visited[i])
            return;
        visited[i] = true;
        ArrayList<Integer> adj = aa[i];
        for (int j : adj)
            dfs1(j);
        po[npo++] = i;
    }
    ArrayList[] aa_;
    int[] dd;
    int[] cc;
    void dfs2(int j, int c) {
        int c_ = cc[j];
        if (c_ != -1) {
            if (c_ != c) {
                aa_[c_].add(c);
                dd[c]++;
            }
            return;
        }
        cc[j] = c;
        ArrayList<Integer> adj = bb[j];
        for (int i : adj)
            dfs2(i, c);
    }
    int dfs3(int i) {
        if (visited[i])
            return -1;
        visited[i] = true;
        ArrayList<Integer> adj = aa_[i];
        if (adj.size() == 0)
            return i;
        for (int j : adj) {
            int w = dfs3(j);
            if (w != -1)
                return w;
        }
        return -1;
    }
    void add(int i, int j) {
        println((i + 1) + "" "" + (j + 1));
    }
    void augment(int n) {
        int[] vv = new int[n];
        int[] ww = new int[n];
        boolean[] iv = new boolean[n];
        boolean[] iw = new boolean[n];
        int p = 0, q, s, t;
        for (int i = 0; i < n; i++) {
            if (cc[i] != i)
                continue;
            if (dd[i] == 0) {
                int w = dfs3(i);
                if (w != -1) {
                    iv[vv[p] = i] = true;
                    iw[ww[p] = w] = true;
                    p++;
                }
            }
        }
        s = t = p;
        for (int i = 0; i < n; i++) {
            if (cc[i] != i)
                continue;
            if (!iv[i] && dd[i] == 0)
                vv[s++] = i;
            if (!iw[i] && aa_[i].size() == 0)
                ww[t++] = i;
        }
        println(Math.max(s, t));
        for (int h = 0; h < p - 1; h++)
            add(ww[h], vv[h + 1]);
        q = Math.min(s, t);
        for (int h = p; h < q; h++)
            add(ww[h], vv[h]);
        int x = ww[p - 1];
        for (int h = q; h < s; h++) {
            add(x, vv[h]); x = vv[h];
        }
        for (int h = q; h < t; h++) {
            add(x, ww[h]); x = ww[h];
        }
        add(x, vv[0]);
    }
    void main() {
        int n = sc.nextInt();
        int m = sc.nextInt();
        aa = new ArrayList[n];
        bb = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            aa[i] = new ArrayList<Integer>();
            bb[i] = new ArrayList<Integer>();
        }
        while (m-- > 0) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            aa[i].add(j);
            bb[j].add(i);
        }
        visited = new boolean[n];
        po = new int[n];
        for (int i = 0; i < n; i++)
            dfs1(i);
        aa_ = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa_[i] = new ArrayList<Integer>();
        dd = new int[n];
        cc = new int[n];
        Arrays.fill(cc, -1);
        int k = 0;
        for (int h = n - 1; h >= 0; h--) {
            int j = po[h];
            if (cc[j] == -1) {
                dfs2(j, j);
                k++;
            }
        }
        if (k == 1) {
            println(0);
            return;
        }
        Arrays.fill(visited, false);
        augment(n);
    }
}
"
New Flight Routes,C++,"/*
 https://cses.fi/problemset/task/1685
 New Flight Routes
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int j;
} aa[N], bb[N], aa_[N];

void link(int i, int j) {
    static struct L l91[M * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next, aa[i].next = l++;
    l->j = i;
    l->next = bb[j].next, bb[j].next = l++;
}

void link_(int i, int j) {
    static struct L l91[M], *l = l91;
    
    l->j = j;
    l->next = aa_[i].next, aa_[i].next = l++;
}

int po[N], npo;
char visited[N];

void dfs1(int i) {
    struct L *l;
    
    if (visited[i])
        return;
    visited[i] = 1;
    for (l = aa[i].next; l; l = l->next)
        dfs1(l->j);
    po[npo++] = i;
}

int cc[N], dd[N];

void dfs2(int j, int c) {
    struct L *l;
    int c_ = cc[j];
    
    if (c_ != -1) {
        if (c_ != c) {
            link_(c_, c);
            dd[c]++;
        }
        return;
    }
    cc[j] = c;
    for (l = bb[j].next; l; l = l->next)
        dfs2(l->j, c);
}

int dfs3(int i) {
    struct L *l;
    
    if (visited[i])
        return -1;
    visited[i] = 1;
    if (!aa_[i].next)
        return i;
    for (l = aa_[i].next; l; l = l->next) {
        int w = dfs3(l->j);
        
        if (w != -1)
            return w;
    }
    return -1;
}

void add(int i, int j) {
    printf(""%d %d\n"", i + 1, j + 1);
}

void augment(int n) {
    static int vv[N], ww[N];
    static char iv[N], iw[N];
    int h, i, p, q, s, t, x;
    
    p = 0;
    for (i = 0; i < n; i++) {
        if (cc[i] != i)
            continue;
        if (dd[i] == 0) {
            int w = dfs3(i);
            
            if (w != -1) {
                iv[vv[p] = i] = 1;
                iw[ww[p] = w] = 1;
                p++;
            }
        }
    }
    s = t = p;
    for (i = 0; i < n; i++) {
        if (cc[i] != i)
            continue;
        if (!iv[i] && dd[i] == 0)
            vv[s++] = i;
        if (!iw[i] && !aa_[i].next)
            ww[t++] = i;
    }
    printf(""%d\n"", s > t ? s : t);
    for (h = 0; h < p - 1; h++)
        add(ww[h], vv[h + 1]);
    q = s < t ? s : t;
    for (h = p; h < q; h++)
        add(ww[h], vv[h]);
    x = ww[p - 1];
    for (h = q; h < s; h++)
        add(x, vv[h]), x = vv[h];
    for (h = q; h < t; h++)
        add(x, ww[h]), x = ww[h];
    add(x, vv[0]);
}

int main() {
    int n, m, h, i, j, k;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j);
    }
    for (i = 0; i < n; i++)
        dfs1(i);
    memset(cc, -1, n * sizeof *cc);
    k = 0;
    for (h = n - 1; h >= 0; h--) {
        j = po[h];
        if (cc[j] == -1) {
            dfs2(j, j);
            k++;
        }
    }
    if (k == 1) {
        printf(""0\n"");
        return 0;
    }
    memset(visited, 0, n * sizeof *visited);
    augment(n);
    return 0;
}
"
Number Grid,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int a,b;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> a >> b;
    cout << ((a-1)^(b-1));
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Number Grid,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int x, y;
    cin >> x >> y;
    cout << ((x-1)^(y-1)) << '\n';
    return 0;
}
"
Number Grid,Java,"// https://cses.fi/problemset/task/1157
// Number Grid
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1157 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int x = Integer.parseInt(st.nextToken());
        int y = Integer.parseInt(st.nextToken());
        System.out.println(x - 1 ^ y - 1);
    }
}
"
Number Grid,C++,"/*
 https://cses.fi/problemset/task/1157
 Number Grid
 practice with Dukkha
 */
#include <stdio.h>

int main() {
    int x, y;
    
    scanf(""%d%d"", &x, &y);
    printf(""%d\n"", (x - 1) ^ (y - 1));
    return 0;
}
"
Permutations II,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int n;
ll dp[1001][1000][2];

void gen(int ind) {
    F0R(i,ind-1) F0R(j,2) {
        dp[ind-1][i][j] %= MOD;
        // place it next to prev
        // between previous two
        
        if (j) {
            dp[ind][i][1] += dp[ind-1][i][j];
            dp[ind][i+1][1] += dp[ind-1][i][j];
        } else {
            dp[ind][i][1] += 2*dp[ind-1][i][j];
        }
        
        // not between previous two
        // not place it between
        // place it between
        if (i) dp[ind][i-1+j][0] += i*dp[ind-1][i][j];
        if (ind-i-2 > 0) dp[ind][i+j][0] += (ind-i-2)*dp[ind-1][i][j];
    }
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    dp[1][0][0] = 1;
    FOR(i,2,1001) gen(i);
    int n; cin >> n;
    cout << (dp[n][0][0] % MOD) << ""\n"";
    // F0R(i,n-1) cout << dp[n][i][0] << "" "" << dp[n][i][1] << ""\n"";
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Permutations II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr ll P=1e9+7;
    ll n;
    cin >> n;
    vector<vector<ll>> B(n+1, vector<ll>(n+1));
    rep(i, 0, n+1) {
        B[i][0]=1;
        rep(j, 1, i+1) {
            B[i][j]=B[i-1][j]+B[i-1][j-1];
            if (B[i][j]>=P) B[i][j]-=P;
        }
    }
    vector<ll> f(n+1);
    f[0]=1;
    rep(i, 1, n+1) f[i]=f[i-1]*i%P;
    ll ans=0;
    rep(k, 0, n) {
        ll s=0;
        rep(a, 0, k+1) s=(s+B[n-k][a]*B[n-a-1][k-a])%P;
        s=s*f[n-k]%P;
        ans=(ans+(k%2? P-s : s))%P;
    }
    cout << ans << '\n';
    return 0;
}
"
Permutations II,Java,"// https://cses.fi/problemset/task/1075
// Permutations II
// practice with rainboy
import java.io.*;

public class CSES1075 {
    static final int MD = 1000000007;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int[][] dp0 = new int[n + 1][n + 1];
        int[][] dp1 = new int[n + 1][n + 1];
        dp0[1][0] = 1;
        for (int k = 2; k <= n; k++) {
            for (int a = 0; a < k; a++) {
                long x = 0;
                x = (x + (long) dp0[k - 1][a + 1] * (a + 1)) % MD;
                x = (x + (long) dp1[k - 1][a + 1] * a) % MD;
                x = (x + (long) dp0[k - 1][a] * (k - a - 2)) % MD;
                x = (x + (long) dp1[k - 1][a] * (k - a - 1)) % MD;
                dp0[k][a] = (int) x;
                x = dp1[k - 1][a];    // replace
                if (a > 0) {
                    x = (x + (long) dp0[k - 1][a - 1] * 2) % MD;
                    x = (x + (long) dp1[k - 1][a - 1]) % MD;
                }
                dp1[k][a] = (int) x;
            }
        }
        System.out.println(dp0[n][0]);
    }
}
"
Permutations II,C++,"/*
 https://cses.fi/problemset/task/1075
 Permutations II
 practice with Dukkha
 */
#include <stdio.h>

#define N    1000
#define MD    1000000007

int main() {
    static int dp0[N + 1][N + 1], dp1[N + 1][N + 1];
    int n, k, a, x;
    
    scanf(""%d"", &n);
    dp0[1][0] = 1;
    for (k = 2; k <= n; k++)
        for (a = 0; a < k; a++) {
            x = 0;
            x = (x + (long long) dp0[k - 1][a + 1] * (a + 1)) % MD;
            x = (x + (long long) dp1[k - 1][a + 1] * a) % MD;
            x = (x + (long long) dp0[k - 1][a] * (k - a - 2)) % MD;
            x = (x + (long long) dp1[k - 1][a] * (k - a - 1)) % MD;
            dp0[k][a] = x;
            x = dp1[k - 1][a];    /* replace */
            if (a > 0) {
                x = (x + (long long) dp0[k - 1][a - 1] * 2) % MD;
                x = (x + (long long) dp1[k - 1][a - 1]) % MD;
            }
            dp1[k][a] = x;
        }
    printf(""%d\n"", dp0[n][0]);
    return 0;
}
"
Prüfer Code,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;
const int MX = 500001;

int n, lst[MX], a[MX], ad[MX];
priority_queue<int,vi,greater<int>> pq;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n;
    FOR(i,1,n+1) lst[i] = -1;
    F0R(i,n-2) {
        cin >> a[i];
        lst[a[i]] = i;
    }
    FOR(i,1,n+1) {
        if (lst[i] == -1) pq.push(i);
        else ad[lst[i]] = i;
    }
    F0R(i,n-2) {
        cout << pq.top() << "" "" << a[i] << ""\n"";
        pq.pop();
        if (ad[i]) pq.push(ad[i]);
    }
    cout << pq.top() << "" "";
    pq.pop();
    cout << pq.top();
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Prüfer Code,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vi x(n-2), d(n+1, 1);
    rep(i, 0, n-2) {
        cin >> x[i];
        d[x[i]]++;
    }
    priority_queue<int, vi, greater<int>> q;
    rep(i, 1, n+1)
    if (d[i]==1) q.push(i);
    rep(i, 0, n-2) {
        int j=q.top();
        q.pop();
        cout << j << "" "" << x[i] << '\n';
        if (--d[x[i]]==1) q.push(x[i]);
    }
    int i=q.top(); q.pop();
    int j=q.top(); q.pop();
    cout << i << "" "" << j << '\n';
    return 0;
}
"
Prüfer Code,Java,"// https://cses.fi/problemset/task/1134
// PrÃ¼fer Code
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1134 {
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int[] aa = new int[n - 2];
        for (int i = 0; i < n - 2; i++)
            aa[i] = sc.nextInt() - 1;
        int[] last = new int[n];
        Arrays.fill(last, -1);
        for (int i = 0; i < n - 2; i++)
            last[aa[i]] = i;
        TreeSet<Integer> pq = new TreeSet<>();
        for (int a = 0; a < n; a++)
            if (last[a] == -1)
                pq.add(a);
        for (int i = 0; i < n - 2; i++) {
            int a = aa[i];
            int b = pq.pollFirst();
            pw.println((a + 1) + "" "" + (b + 1));
            if (last[a] == i)
                pq.add(a);
        }
        int a = pq.pollFirst();
        int b = pq.pollFirst();
        pw.println((a + 1) + "" "" + (b + 1));
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb); //if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        String next() throws IOException {
            StringBuilder sb = new StringBuilder();
            for (byte b = skip(); b > 32; b = getc())
                sb.append((char) b);
            return sb.toString();
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Prüfer Code,C++,"// https://cses.fi/problemset/task/1134
// PrÃ¼fer Code
// practice with rainboy
#include <algorithm>
#include <iostream>
#include <queue>

using namespace std;

const int N = 500000;

int aa[N], last[N];

int main() {
    int n;
    scanf(""%d"", &n);
    for (int i = 0; i < n - 2; i++) {
        scanf(""%d"", &aa[i]);
        aa[i]--;
    }
    fill_n(last, n, -1);
    for (int i = 0; i < n - 2; i++)
        last[aa[i]] = i;
    priority_queue<int, vector<int>, greater<int>> pq;
    for (int a = 0; a < n; a++)
        if (last[a] == -1)
            pq.push(a);
    for (int i = 0; i < n - 2; i++) {
        int a = aa[i];
        int b = pq.top(); pq.pop();
        printf(""%d %d\n"", a + 1, b + 1);
        if (last[a] == i)
            pq.push(a);
    }
    int a = pq.top(); pq.pop();
    int b = pq.top(); pq.pop();
    printf(""%d %d\n"", a + 1, b + 1);
}
"
Prüfer Code,Java,"// https://cses.fi/problemset/task/1134
// PrÃ¼fer Code
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1134 {
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int[] aa = new int[n - 2];
        for (int i = 0; i < n - 2; i++)
            aa[i] = sc.nextInt() - 1;
        int[] last = new int[n];
        Arrays.fill(last, -1);
        for (int i = 0; i < n - 2; i++)
            last[aa[i]] = i;
        TreeSet<Integer> pq = new TreeSet<>();
        for (int a = 0; a < n; a++)
            if (last[a] == -1)
                pq.add(a);
        for (int i = 0; i < n - 2; i++) {
            int a = aa[i];
            int b = pq.pollFirst();
            pw.println((a + 1) + "" "" + (b + 1));
            if (last[a] == i)
                pq.add(a);
        }
        int a = pq.pollFirst();
        int b = pq.pollFirst();
        pw.println((a + 1) + "" "" + (b + 1));
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Prüfer Code,C++,"/*
 https://cses.fi/problemset/task/1134
 PrÃ¼fer Code
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    500000

struct V {
    int i; /* for heap */
    int a;
} vv[N], *pq[1 + N];

int cnt;

#define LT(u, v) ((u)->a < (v)->a)

int i2(int i) {
    return (i *= 2) > cnt ? 0 : i < cnt && LT(pq[i + 1], pq[i]) ? i + 1 : i;
}

void pq_up(struct V *u) {
    int i, j;
    
    for (i = u->i; (j = i / 2) && LT(u, pq[j]); i = j)
        pq[pq[j]->i = i] = pq[j];
    pq[u->i = i] = u;
}

void pq_dn(struct V *u) {
    int i, j;
    
    for (i = u->i; (j = i2(i)) && LT(pq[j], u); i = j)
        pq[pq[j]->i = i] = pq[j];
    pq[u->i = i] = u;
}

void pq_add(struct V *u) {
    u->i = ++cnt;
    pq_up(u);
}

struct V *pq_remove_first() {
    struct V *u = pq[1], *v = pq[cnt--];
    
    v->i = 1;
    pq_dn(v);
    return u;
}

int main() {
    static int aa[N], last[N];
    int n, i, a, b;
    
    scanf(""%d"", &n);
    for (i = 0; i < n - 2; i++)
        scanf(""%d"", &aa[i]), aa[i]--;
    memset(last, -1, sizeof last);
    for (i = 0; i < n - 2; i++)
        last[aa[i]] = i;
    for (a = 0; a < n; a++)
        vv[a].a = a;
    for (a = 0; a < n; a++)
        if (last[a] == -1)
            pq_add(&vv[a]);
    for (i = 0; i < n - 2; i++) {
        a = aa[i];
        b = pq_remove_first()->a;
        printf(""%d %d\n"", a + 1, b + 1);
        if (last[a] == i)
            pq_add(&vv[a]);
    }
    a = pq_remove_first()->a;
    b = pq_remove_first()->a;
    printf(""%d %d\n"", a + 1, b + 1);
    return 0;
}
"
Pyramid Array,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

Tree<int> T;
map<int,int> pos;
int n;
vi x;
ll ans;

int main() {
    setIO(); re(n); x.resz(n); re(x);
    F0R(i,n) {
        pos[x[i]] = i;
        T.insert(i);
    }
    int lef = n;
    trav(t,pos) {
        int bef = T.order_of_key(t.s);
        ans += min(bef,lef-1-bef);
        T.erase(t.s);
        lef --;
    }
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Pyramid Array,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

#include <bits/extc++.h> /** keep-include */
using namespace __gnu_pbds;

template<class T>
using Tree = tree<T, null_type, less<T>, rb_tree_tag,
tree_order_statistics_node_update>;

void example() {
    Tree<int> t, t2; t.insert(8);
    auto it = t.insert(10).first;
    assert(it == t.lower_bound(9));
    assert(t.order_of_key(10) == 1);
    assert(t.order_of_key(11) == 2);
    assert(*t.find_by_order(0) == 8);
    t.join(t2); // assuming T < T2 or T > T2, merge t2 into t
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    map<int, vi> cnt;
    rep(i, 0, n) {
        int a;
        cin >> a;
        cnt[-a].push_back(i);
    }
    ll ans=0;
    Tree<int> t;
    trav(p, cnt) {
        trav(i, p.second) {
            int L=t.order_of_key(i);
            ans+=min(L, sz(t)-L);
        }
        trav(i, p.second) t.insert(i);
    }
    cout << ans << '\n';
    return 0;
}
"
Pyramid Array,Java,"// https://cses.fi/problemset/task/1747
// Pyramid Array
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1747 extends PrintWriter {
    CSES1747() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1747 c = new CSES1747(); c.main(); c.flush();
    }
    
    int[] tt;
    void update(int i, int n) {
        while (i < n) {
            tt[i]++;
            i |= i + 1;
        }
    }
    int query(int i) {
        int x = 0;
        while (i >= 0) {
            x += tt[i];
            i &= i + 1;
            i--;
        }
        return x;
    }
    void main() {
        int n = sc.nextInt();
        int[] aa = new int[n];
        Integer[] ii = new Integer[n];
        for (int i = 0; i < n; i++) {
            aa[i] = sc.nextInt();
            ii[i] = i;
        }
        Arrays.sort(ii, (i, j) -> aa[i] - aa[j]);
        tt = new int[n];
        long ans = 0;
        for (int h = 0; h < n; h++) {
            int i = ii[h];
            int l = query(i);
            ans += Math.min(i - l, (n - 1 - i) - (h - l));
            update(i, n);
        }
        println(ans);
    }
}
"
Pyramid Array,C++,"/*
 https://cses.fi/problemset/task/1747
 Pyramid Array
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    200000

int min(int a, int b) { return a < b ? a : b; }

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

int aa[N];

int compare(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return aa[i] - aa[j];
}

int tt[N];

void update(int i, int n) {
    while (i < n) {
        tt[i]++;
        i |= i + 1;
    }
}

int query(int i) {
    int sum = 0;
    
    while (i >= 0) {
        sum += tt[i];
        i &= i + 1;
        i--;
    }
    return sum;
}

int main() {
    static int ii[N];
    int n, h, i, j, l, tmp;
    long long ans;
    
    init_rand();
    scanf(""%d"", &n);
    for (i = 0; i < n; i++) {
        scanf(""%d"", &aa[i]);
        ii[i] = i;
    }
    for (j = 0; j < n; j++) {
        i = rand_(j + 1);
        tmp = ii[i], ii[i] = ii[j], ii[j] = tmp;
    }
    qsort(ii, n, sizeof *ii, compare);
    ans = 0;
    for (h = 0; h < n; h++) {
        i = ii[h];
        l = query(i);
        ans += min(i - l, (n - 1 - i) - (h - l));
        update(i, n);
    }
    printf(""%lld\n"", ans);
    return 0;
}
"
Robot Path,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 100005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template <class T, int ...Ns> struct BIT {
    T val = 0;
    void upd(T v) { val += v; }
    T query() { return val; }
};

template <class T, int N, int... Ns> struct BIT<T, N, Ns...> {
    BIT<T,Ns...> bit[N + 1];
    template<typename... Args> void upd(int pos, Args... args) {
        for (; pos <= N; pos += (pos&-pos)) bit[pos].upd(args...);
    }
    template<typename... Args> T sum(int r, Args... args) {
        T res = 0; for (; r; r -= (r&-r)) res += bit[r].query(args...);
        return res;
    }
    template<typename... Args> T query(int l, int r, Args... args) {
        return sum(r,args...)-sum(l-1,args...);
    }
}; // BIT<int,10,10> gives a 2D BIT

int n;
BIT<int,MX> B;

ll ry[MX], rx[MX];
vl dist;
vpl v;
string c;

vector<pair<int,pi>> hori, vert;

bool ok(int mid) {
    hori.clear(), vert.clear();
    F0R(i,mid+1) {
        pl a = v[i], b = v[i+1];
        if (a.s == b.s) {
            if (a.f < b.f) hori.pb({a.s,{i==0?a.f:a.f+1,b.f}});
            else hori.pb({a.s,{b.f,i==0?a.f:a.f-1}});
        } else {
            if (a.s < b.s) vert.pb({a.f,{i==0?a.s:a.s+1,b.s}});
            else vert.pb({a.f,{b.s,i==0?a.s:a.s-1}});
        }
    }
    sort(all(vert)), sort(all(hori));
    for (int i = 0; i < sz(vert); ) {
        int mx = -MOD;
        int I = i;
        while (i < sz(vert) && vert[i].f == vert[I].f) {
            if (vert[i].s.f <= mx) return 0;
            mx = vert[i++].s.s;
        }
    }
    for (int i = 0; i < sz(hori); ) {
        int mx = -MOD;
        int I = i;
        while (i < sz(hori) && hori[i].f == hori[I].f) {
            if (hori[i].s.f <= mx) return 0;
            mx = hori[i++].s.s;
        }
    }
    
    vector<array<int,3>> mod;
    trav(t,vert) {
        mod.pb({t.s.f,t.f,1});
        mod.pb({t.s.s+1,t.f,-1});
    }
    sort(all(mod));
    B = BIT<int,MX>();
    int ind = 0;
    trav(t,hori) {
        while (ind < sz(mod) && mod[ind][0] <= t.f) {
            B.upd(mod[ind][1],mod[ind][2]);
            ind ++;
        }
        if (B.query(t.s.f,t.s.s)) return 0;
    }
    return 1;
}

void init() {
    setIO(); re(n);
    v.pb({0,0});
    F0R(i,n) {
        char d; int x; re(d,x);
        c += d;
        v.pb(v.back());
        if (d == 'U') v.back().s += x;
        if (d == 'D') v.back().s -= x;
        if (d == 'L') v.back().f -= x;
        if (d == 'R') v.back().f += x;
        dist.pb(x);
    }
    map<ll,int> x, y;
    trav(t,v) x[t.f] = y[t.s] = 0;
    int co = 0;
    trav(t,x) {
        t.s = ++co;
        rx[co] = t.f;
    }
    co = 0;
    trav(t,y) {
        t.s = ++co;
        ry[co] = t.f;
    }
    trav(t,v) {
        t.f = x[t.f], t.s = y[t.s];
    }
}

pair<pi,pi> seg(int i) {
    pl a = v[i], b = v[i+1]; if (i == 0) return {a,b};
    if (a.s == b.s) {
        if (a.f < b.f) a.f ++;
        else a.f --;
    } else {
        if (a.s < b.s) a.s ++;
        else a.s --;
    }
    return {a,b};
}

vpi inter(pair<pi,pi> a, pair<pi,pi> b) {
    if (a.f > a.s) swap(a.f,a.s);
    if (b.f > b.s) swap(b.f,b.s);
    if (a > b) swap(a,b);
    if (a.f.s == a.s.s && b.f.s == b.s.s) {
        if (a.f.s != b.f.s) return {};
        if (a.s.f >= b.f.f) return {{max(a.f.f,b.f.f),a.f.s},{min(a.s.f,b.s.f),a.f.s}};
        return {};
    }
    if (a.f.f == a.s.f && b.f.f == b.s.f) {
        swap(a.f.f,a.f.s); swap(a.s.f,a.s.s);
        swap(b.f.f,b.f.s); swap(b.s.f,b.s.s);
        auto v = inter(a,b); trav(t,v) swap(t.f,t.s);
        return v;
    }
    if (a.f.s != a.s.s || b.f.f != b.s.f) swap(a,b);
    if (!(a.f.s == a.s.s && b.f.f == b.s.f)) {
        ps(1,a,b);
        exit(0);
    }
    if (b.f.s <= a.f.s && a.f.s <= b.s.s && a.f.f <= b.f.f && b.f.f <= a.s.f) {
        return {{b.f.f,a.f.s}};
    }
    return {};
}

int dis(pi a, pi b) {
    if (a.f == b.f) {
        return abs(ry[a.s]-ry[b.s]);
    } else {
        if (!(a.s == b.s)) {
            ps(2,a,b);
            exit(0);
        }
        return abs(rx[a.f]-rx[b.f]);
    }
}

bool opposite(char a, char b) {
    if (a > b) swap(a,b);
    if (a == 'D' && b == 'U') return 1;
    if (a == 'L' && b == 'R') return 1;
    return 0;
}

int brute(int ind) {
    // v[ind] to v[ind+1]
    if (opposite(c[ind],c[ind-1])) return 0;
    int ret = MOD;
    F0R(i,ind) {
        vpi t = inter(seg(i),seg(ind));
        // ps(""??"",i,ind,seg(i),seg(ind),t);
        trav(T,t) ckmin(ret,dis(T,v[ind]));
    }
    assert(ret != MOD);
    return ret;
}

int main() {
    init();
    int lo = 0, hi = n-1;
    while (lo < hi) {
        int mid = (lo+hi+1)/2;
        if (ok(mid)) lo = mid;
        else hi = mid-1;
    }
    ll ans = 0;
    F0R(i,lo+1) ans += dist[i];
    if (lo < n-1) ans += brute(lo+1);
    ps(ans);
    // you should actually read the stuff at the bottom
}
"
Robot Path,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef pair<ll, ll> pll;

struct T {
    ll x1, y1, x2, y2;
    int id;
};

constexpr ll inf=1e18;
map<char, int> c2dir{{'U', 0}, {'D', 1}, {'L', 2}, {'R', 3}};
vi dx{0, 0, -1, 1}, dy{1, -1, 0, 0};
vector<T> f;

int isect(ll id, ll L, ll R) {
    ll y1=f[id].y1, y2=f[id].y2;
    ll l=min(y1, y2), r=max(y1, y2);
    return (r>=L && l<=R);
}

ll isectd(int id, int w) {
    ll x1=f[id].x1, y1=f[id].y1, x2=f[id].x2, y2=f[id].y2;
    ll X1=f[w].x1, Y1=f[w].y1, X2=f[w].x2, Y2=f[w].y2;
    if (x1!=x2) {
        swap(x1, y1); swap(x2, y2);
        swap(X1, Y1); swap(X2, Y2);
    }
    if (X1!=X2) {
        if (Y1<min(y1, y2) || Y1>max(y1, y2)) return inf;
        if (max(X1, X2)<x1 || min(X1, X2)>x1) return inf;
        return abs(y1-Y1);
    }
    else {
        if (x1!=X1) return inf;
        if (max(y1, y2)<min(Y1, Y2)) return inf;
        if (min(y1, y2)>max(Y1, Y2)) return inf;
        if (y1>=min(Y1, Y2) && y1<=max(Y1, Y2)) return 0;
        if (Y1>y1) return min(Y1, Y2)-y1;
        if (Y1<y1) return y1-max(Y1, Y2);
    }
    return inf;
}

int processXX(int M) {
    map<ll, set<pll>> s;
    rep(i, 0, M) if (f[i].x1==f[i].x2) {
        T q=f[i];
        auto &t=s[q.x1];
        auto p=t.lower_bound({q.y1, -inf});
        if (p!=end(t) && isect(q.id, p->first, p->second))
            return 1;
        if (p!=begin(t) && isect(q.id, prev(p)->first, prev(p)->second))
            return 1;
        t.insert({min(q.y1, q.y2), max(q.y1, q.y2)});
    }
    return 0;
}

int processXY(int M) {
    vector<pll> e;
    rep(i, 0, M) {
        T q=f[i];
        if (q.x1==q.x2)
            e.push_back({q.x1, q.id});
        else {
            e.push_back({min(q.x1, q.x2), -inf-q.id});
            e.push_back({max(q.x1, q.x2), +inf+q.id});
        }
    }
    sort(all(e));
    map<ll, ll> t;
    trav(q, e) {
        ll id=q.second;
        if (id<=-inf) {
            ll y=f[-inf-id].y1;
            ++t[y];
        }
        else if (id>=+inf) {
            ll y=f[id-inf].y1;
            if (--t[y]==0) t.erase(y);
        }
        else {
            auto p=t.lower_bound(f[id].y1);
            if (p!=end(t) && isect(id, p->first, p->first))
                return 1;
            if (p!=begin(t) && isect(id, prev(p)->first, prev(p)->first))
                return 1;
        }
    }
    return 0;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    f.resize(n);
    string s(n, 0);
    ll x=0, y=0;
    rep(i, 0, n) {
        ll d;
        cin >> s[i] >> d;
        int dir=c2dir[s[i]];
        f[i].x1=x+(i>0)*dx[dir];
        f[i].y1=y+(i>0)*dy[dir];
        x=f[i].x2=x+d*dx[dir];
        y=f[i].y2=y+d*dy[dir];
        f[i].id=i;
    }
    int L=0, R=n;
    while (L<R) {
        int M=(L+R)/2;
        int fail=processXX(M+1) || processXY(M+1);
        trav(q, f) {
            swap(q.x1, q.y1);
            swap(q.x2, q.y2);
        }
        if (!fail)
            fail|=processXX(M+1) || processXY(M+1);
        if (fail) R=M;
        else L=M+1;
    }
    ll ans=0;
    rep(i, 0, L)
    ans+=(i>0)+abs(f[i].x1-f[i].x2)+abs(f[i].y1-f[i].y2);
    if (L<n) {
        ll d=inf;
        rep(i, 0, L)
        d=min(d, isectd(L, i));
        ans+=1+d;
    }
    if (L<n && (c2dir[s[L]]^c2dir[s[L-1]])==1)
        ans--;
    cout << ans << '\n';
    return 0;
}
"
Robot Path,Java,"// https://cses.fi/problemset/task/1742
// Robot Path
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1742 extends PrintWriter {
    CSES1742() { super(System.out); }
    byte[] __; int $;
    { try { __ = System.in.readAllBytes(); } catch (IOException e) {} }
    int nextInt() {
        while ($ < __.length && __[$] <= 32) $++;
        int a = 0;
        while ($ < __.length && __[$] > 32) a = a * 10 + __[$++] - '0';
        return a;
    }
    byte nextByte() {
        while ($ < __.length && __[$] <= 32) $++;
        return __[$++];
    }
    public static void main(String[] $) {
        CSES1742 o = new CSES1742(); o.main(); o.flush();
    }
    
    static final int INF = 0x3f3f3f3f;
    int[] tt;
    int nt;
    void update(int i, int x) {
        while (i < nt) {
            tt[i] += x;
            i |= i + 1;
        }
    }
    int query(int i) {
        int x = 0;
        while (i >= 0) {
            x += tt[i];
            i &= i + 1;
            i--;
        }
        return x;
    }
    static class V {
        int y, l, r;
        V(int y, int l, int r) {
            this.y = y; this.l = l; this.r = r;
        }
    }
    V[] vv;
    int[] xl, xr, yd, yu;
    boolean check(int n) {
        int bound = n - 1;
        int n_ = 0;
        for (int i = 0; i < n; i++)
            if (xl[i] != xr[i])
                vv[n_++] = new V(yd[i], xl[i], xr[i]);
            else {
                vv[n_++] = new V(yd[i], xl[i], -INF);
                vv[n_++] = new V(yu[i], xl[i], INF);
            }
        n = n_;
        Arrays.sort(vv, 0, n, (u, v) -> u.y != v.y ? u.y - v.y : u.r - v.r);
        Arrays.fill(tt, 0);
        int r = -INF;
        for (int i = 0; i < n; i++) {
            V v = vv[i];
            if (i > 0 && vv[i - 1].y != vv[i].y)
                r = -INF;
            if (v.r == -INF) {
                if (query(v.l) - query(v.l - 1) != 0)
                    return false;
                update(v.l, 1);
            } else if (v.r == INF) {
                update(v.l, -1);
            } else {
                if (r >= v.l)
                    return false;
                bound -= query(v.r) - query(v.l - 1);
                if (bound < 0)
                    return false;
                r = v.r;
            }
        }
        return true;
    }
    boolean opposite(byte a, byte b) {
        return a == 'L' && b == 'R' || a == 'R' && b == 'L' || a == 'D' && b == 'U' || a == 'U' && b == 'D';
    }
    void main() {
        int n = nextInt();
        long[] xx_ = new long[n + 1];
        long[] yy_ = new long[n + 1];
        long x_, y_;
        xx_[0] = x_ = 0;
        yy_[0] = y_ = 0;
        byte dir_ = ' ';
        int n_ = 1;
        for (int i = 0; i < n; i++) {
            byte dir = nextByte();
            if (opposite(dir, dir_))
                break;
            int z = nextInt();
            if (dir == 'L')
                x_ -= z;
            else if (dir == 'R')
                x_ += z;
            else if (dir == 'D')
                y_ -= z;
            else
                y_ += z;
            if (dir_ != dir) {
                dir_ = dir;
                n_++;
            }
            xx_[n_ - 1] = x_;
            yy_[n_ - 1] = y_;
        }
        n = n_ - 1;
        
        int[] xx = new int[n + 1];
        int[] yy = new int[n + 1];
        Integer[] ii = new Integer[n + 1];
        for (int i = 0; i <= n; i++)
            ii[i] = i;
        Arrays.sort(ii, (i, j) -> Long.signum(xx_[i] - xx_[j]));
        for (int h = 0, x = 0; h <= n; h++)
            xx[ii[h]] = h == n || xx_[ii[h]] != xx_[ii[h + 1]] ? x++ : x;
        Arrays.sort(ii, (i, j) -> Long.signum(yy_[i] - yy_[j]));
        for (int h = 0, y = 0; h <= n; h++)
            yy[ii[h]] = h == n || yy_[ii[h]] != yy_[ii[h + 1]] ? y++ : y;
        
        xl = new int[n];
        xr = new int[n];
        yd = new int[n];
        yu = new int[n];
        for (int i = 0; i < n; i++) {
            xl[i] = xx[i]; xr[i] = xx[i + 1];
            if (xl[i] > xr[i]) { int tmp = xl[i]; xl[i] = xr[i]; xr[i] = tmp; }
            yd[i] = yy[i]; yu[i] = yy[i + 1];
            if (yd[i] > yu[i]) { int tmp = yd[i]; yd[i] = yu[i]; yu[i] = tmp; }
        }
        
        tt = new int[nt = n + 1];
        vv = new V[n * 2];
        int lower = 0, upper = n;
        while (upper - lower > 1) {
            n_ = (lower + upper) / 2;
            if (!check(n_))
                upper = n_;
            else
                lower = n_;
        }
        int j = upper - 1;
        
        x_ = xx_[j];
        y_ = yy_[j];
        long[] xl_ = new long[n];
        long[] xr_ = new long[n];
        long[] yd_ = new long[n];
        long[] yu_ = new long[n];
        for (int i = 0; i < n; i++) {
            xl_[i] = xx_[i]; xr_[i] = xx_[i + 1];
            if (xl_[i] > xr_[i]) { long tmp = xl_[i]; xl_[i] = xr_[i]; xr_[i] = tmp; }
            yd_[i] = yy_[i]; yu_[i] = yy_[i + 1];
            if (yd_[i] > yu_[i]) { long tmp = yd_[i]; yd_[i] = yu_[i]; yu_[i] = tmp; }
        }
        long w = 0, wj = xr_[j] - xl_[j] + yu_[j] - yd_[j];
        for (int i = 0; i < j; i++) {
            w += xr_[i] - xl_[i] + yu_[i] - yd_[i];
            if (i < j - 1) {
                long l = Math.max(xl_[i], xl_[j]);
                long r = Math.min(xr_[i], xr_[j]);
                if (l > r)
                    continue;
                long d = Math.max(yd_[i], yd_[j]);
                long u = Math.min(yu_[i], yu_[j]);
                if (d > u)
                    continue;
                wj = Math.min(wj, Math.abs(l - x_) + Math.abs(d - y_));
                wj = Math.min(wj, Math.abs(r - x_) + Math.abs(u - y_));
            }
        }
        w += wj;
        println(w);
    }
}
"
Robot Path,C++,"// https://cses.fi/problemset/task/1742
// Robot Path
// practice with rainboy
#include <algorithm>
#include <iostream>

using namespace std;

const int N = 100000, INF = 0x3f3f3f3f;

int tt[N + 1], nt;

void update(int i, int x) {
    while (i < nt) {
        tt[i] += x;
        i |= i + 1;
    }
}

int query(int i) {
    int x = 0;
    while (i >= 0) {
        x += tt[i];
        i &= i + 1;
        i--;
    }
    return x;
}

struct V {
    int y, l, r;
} vv[N * 2];

int xl[N], xr[N], yd[N], yu[N];

bool check(int n) {
    int bound = n - 1;
    int n_ = 0;
    for (int i = 0; i < n; i++)
        if (xl[i] != xr[i])
            vv[n_++] = { yd[i], xl[i], xr[i] };
        else {
            vv[n_++] = { yd[i], xl[i], -INF };
            vv[n_++] = { yu[i], xl[i], INF };
        }
    n = n_;
    sort(vv, vv + n, [] (auto &u, auto &v) { return u.y < v.y || u.y == v.y && u.r < v.r; });
    fill_n(tt, nt, 0);
    int r = -INF;
    for (int i = 0; i < n; i++) {
        auto &v = vv[i];
        if (i > 0 && vv[i - 1].y != vv[i].y)
            r = -INF;
        if (v.r == -INF) {
            if (query(v.l) - query(v.l - 1) != 0)
                return false;
            update(v.l, 1);
        } else if (v.r == INF) {
            update(v.l, -1);
        } else {
            if (r >= v.l)
                return false;
            bound -= query(v.r) - query(v.l - 1);
            if (bound < 0)
                return false;
            r = v.r;
        }
    }
    return true;
}

bool opposite(char a, char b) {
    return a == 'L' && b == 'R' || a == 'R' && b == 'L' || a == 'D' && b == 'U' || a == 'U' && b == 'D';
}

int main() {
    static long long xx_[N + 1], yy_[N + 1];
    int n;
    scanf(""%d"", &n);
    long long x_, y_;
    xx_[0] = x_ = 0;
    yy_[0] = y_ = 0;
    char dir_ = ' ';
    int n_ = 1;
    for (int i = 0; i < n; i++) {
        char s[2];
        int z;
        scanf(""%s%d"", s, &z);
        char dir = s[0];
        if (opposite(dir, dir_))
            break;
        if (dir == 'L')
            x_ -= z;
        else if (dir == 'R')
            x_ += z;
        else if (dir == 'D')
            y_ -= z;
        else
            y_ += z;
        if (dir_ != dir) {
            dir_ = dir;
            n_++;
        }
        xx_[n_ - 1] = x_;
        yy_[n_ - 1] = y_;
    }
    n = n_ - 1;
    static int xx[N + 1], yy[N + 1], ii[N + 1];
    for (int i = 0; i <= n; i++)
        ii[i] = i;
    sort(ii, ii + n + 1, [] (int i, int j) { return xx_[i] < xx_[j]; });
    for (int h = 0, x = 0; h <= n; h++)
        xx[ii[h]] = h == n || xx_[ii[h]] != xx_[ii[h + 1]] ? x++ : x;
    sort(ii, ii + n + 1, [] (int i, int j) { return yy_[i] < yy_[j]; });
    for (int h = 0, y = 0; h <= n; h++)
        yy[ii[h]] = h == n || yy_[ii[h]] != yy_[ii[h + 1]] ? y++ : y;
    for (int i = 0; i < n; i++) {
        xl[i] = xx[i]; xr[i] = xx[i + 1];
        if (xl[i] > xr[i]) { swap(xl[i], xr[i]); }
        yd[i] = yy[i]; yu[i] = yy[i + 1];
        if (yd[i] > yu[i]) { swap(yd[i], yu[i]); }
    }
    nt = n + 1;
    int lower = 0, upper = n;
    while (upper - lower > 1) {
        n_ = (lower + upper) / 2;
        if (!check(n_))
            upper = n_;
        else
            lower = n_;
    }
    int j = upper - 1;
    x_ = xx_[j];
    y_ = yy_[j];
    static long long xl_[N], xr_[N], yd_[N], yu_[N];
    for (int i = 0; i < n; i++) {
        xl_[i] = xx_[i]; xr_[i] = xx_[i + 1];
        if (xl_[i] > xr_[i]) { swap(xl_[i], xr_[i]); }
        yd_[i] = yy_[i]; yu_[i] = yy_[i + 1];
        if (yd_[i] > yu_[i]) { swap(yd_[i], yu_[i]); }
    }
    long long w = 0, wj = xr_[j] - xl_[j] + yu_[j] - yd_[j];
    for (int i = 0; i < j; i++) {
        w += xr_[i] - xl_[i] + yu_[i] - yd_[i];
        if (i < j - 1) {
            long long l = max(xl_[i], xl_[j]);
            long long r = min(xr_[i], xr_[j]);
            if (l > r)
                continue;
            long long d = max(yd_[i], yd_[j]);
            long long u = min(yu_[i], yu_[j]);
            if (d > u)
                continue;
            wj = min(wj, abs(l - x_) + abs(d - y_));
            wj = min(wj, abs(r - x_) + abs(u - y_));
        }
    }
    w += wj;
    printf(""%lld\n"", w);
    return 0;
}
"
Robot Path,C++,"/*
 https://cses.fi/problemset/task/1742
 Robot Path
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>

#define N    100000
#define INF    0x3f3f3f3f

long long ab(long long a) { return a < 0 ? -a : a; }
long long min(long long a, long long b) { return a < b ? a : b; }
long long max(long long a, long long b) { return a > b ? a : b; }
int signum(long long x) { return x == 0 ? 0 : x < 0 ? -1 : 1; }

int tt[N + 1], nt;

void update(int i, int x) {
    while (i < nt) {
        tt[i] += x;
        i |= i + 1;
    }
}

int query(int i) {
    int x = 0;
    
    while (i >= 0) {
        x += tt[i];
        i &= i + 1;
        i--;
    }
    return x;
}

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

int xl[N], xr[N], yd[N], yu[N];
long long xx_[N + 1], yy_[N + 1];
int xx[N + 1], yy[N + 1];

struct V {
    int y, l, r;
} vv[N * 2];

int compare_x(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return signum(xx_[i] - xx_[j]);
}

int compare_y(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return signum(yy_[i] - yy_[j]);
}

int compare_yr(const void *a, const void *b) {
    struct V *u = (struct V *) a;
    struct V *v = (struct V *) b;
    
    return u->y != v->y ? u->y - v->y : u->r - v->r;
}

void shuffle(int *aa, int n) {
    int i, j, tmp;
    
    for (j = 0; j < n; j++) {
        i = rand_(j + 1);
        tmp = aa[i], aa[i] = aa[j], aa[j] = tmp;
    }
}

void shuffle_(struct V *aa, int n) {
    int i, j;
    struct V tmp;
    
    for (j = 0; j < n; j++) {
        i = rand_(j + 1);
        tmp = aa[i], aa[i] = aa[j], aa[j] = tmp;
    }
}

long long check(int n) {
    int n_, i, r, bound;
    struct V *v;
    
    bound = n - 1;
    n_ = 0;
    for (i = 0; i < n; i++)
        if (xl[i] != xr[i]) {
            v = &vv[n_++];
            v->y = yd[i], v->l = xl[i], v->r = xr[i];
        } else {
            v = &vv[n_++];
            v->y = yd[i], v->l = xl[i], v->r = -INF;
            v = &vv[n_++];
            v->y = yu[i], v->l = xl[i], v->r = INF;
        }
    n = n_;
    shuffle_(vv, n), qsort(vv, n, sizeof *vv, compare_yr);
    memset(tt, 0, nt * sizeof *tt);
    r = -INF;
    for (i = 0; i < n; i++) {
        struct V *v = &vv[i];
        
        if (i > 0 && vv[i - 1].y != vv[i].y)
            r = -INF;
        if (v->r == -INF) {
            if (query(v->l) - query(v->l - 1) != 0)
                return 0;
            update(v->l, 1);
        } else if (v->r == INF) {
            update(v->l, -1);
        } else {
            if (r >= v->l)
                return 0;
            bound -= query(v->r) - query(v->l - 1);
            if (bound < 0)
                return 0;
            r = v->r;
        }
    }
    return 1;
}

int opposite(char a, char b) {
    return a == 'L' && b == 'R' || a == 'R' && b == 'L' || a == 'D' && b == 'U' || a == 'U' && b == 'D';
}

int main() {
    static long long xl_[N], xr_[N], yd_[N], yu_[N];
    static int ii[N + 1];
    int n, n_, h, i, j, x, y, lower, upper;
    long long x_, y_, w, wj, l, r, u, d;
    char dir_;
    
    scanf(""%d\n"", &n);
    xx_[0] = x_ = 0;
    yy_[0] = y_ = 0;
    dir_ = ' ';
    n_ = 1;
    for (i = 0; i < n; i++) {
        char dir;
        int z;
        
        scanf(""%c %d\n"", &dir, &z);
        if (opposite(dir, dir_))
            break;
        if (dir == 'L')
            x_ -= z;
        else if (dir == 'R')
            x_ += z;
        else if (dir == 'D')
            y_ -= z;
        else
            y_ += z;
        if (dir_ != dir) {
            dir_ = dir;
            n_++;
        }
        xx_[n_ - 1] = x_;
        yy_[n_ - 1] = y_;
    }
    n = n_ - 1;
    for (i = 0; i <= n; i++)
        ii[i] = i;
    shuffle(ii, n + 1), qsort(ii, n + 1, sizeof *ii, compare_x);
    for (h = 0, x = 0; h <= n; h++)
        xx[ii[h]] = h == n || xx_[ii[h]] != xx_[ii[h + 1]] ? x++ : x;
    shuffle(ii, n + 1), qsort(ii, n + 1, sizeof *ii, compare_y);
    for (h = 0, y = 0; h <= n; h++)
        yy[ii[h]] = h == n || yy_[ii[h]] != yy_[ii[h + 1]] ? y++ : y;
    for (i = 0; i < n; i++) {
        int tmp;
        
        xl[i] = xx[i], xr[i] = xx[i + 1];
        if (xl[i] > xr[i]) tmp = xl[i], xl[i] = xr[i], xr[i] = tmp;
        yd[i] = yy[i], yu[i] = yy[i + 1];
        if (yd[i] > yu[i]) tmp = yd[i], yd[i] = yu[i], yu[i] = tmp;
    }
    nt = n + 1;
    lower = 0, upper = n;
    while (upper - lower > 1) {
        n_ = (lower + upper) / 2;
        if (!check(n_))
            upper = n_;
        else
            lower = n_;
    }
    j = upper - 1;
    x_ = xx_[j];
    y_ = yy_[j];
    for (i = 0; i < n; i++) {
        long long tmp;
        
        xl_[i] = xx_[i], xr_[i] = xx_[i + 1];
        if (xl_[i] > xr_[i]) tmp = xl_[i], xl_[i] = xr_[i], xr_[i] = tmp;
        yd_[i] = yy_[i], yu_[i] = yy_[i + 1];
        if (yd_[i] > yu_[i]) tmp = yd_[i], yd_[i] = yu_[i], yu_[i] = tmp;
    }
    w = 0, wj = xr_[j] - xl_[j] + yu_[j] - yd_[j];
    for (i = 0; i < j; i++) {
        w += xr_[i] - xl_[i] + yu_[i] - yd_[i];
        if (i < j - 1) {
            l = max(xl_[i], xl_[j]), r = min(xr_[i], xr_[j]);
            if (l > r)
                continue;
            d = max(yd_[i], yd_[j]), u = min(yu_[i], yu_[j]);
            if (d > u)
                continue;
            wj = min(wj, min(ab(l - x_) + ab(d - y_), ab(r - x_) + ab(u - y_)));
        }
    }
    w += wj;
    printf(""%lld\n"", w);
    return 0;
}
"
School Excursion,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<int SZ> struct DSU {
    int par[SZ], sz[SZ];
    
    DSU() {
        F0R(i,SZ) par[i] = i, sz[i] = 1;
    }
    
    int get(int x) { // path compression
        if (par[x] != x) par[x] = get(par[x]);
        return par[x];
    }
    
    bool unite(int x, int y) { // union-by-rank
        x = get(x), y = get(y);
        if (x == y) return 0;
        if (sz[x] < sz[y]) swap(x,y);
        sz[x] += sz[y], par[y] = x;
        return 1;
    }
};

DSU<MX> D;

int n,m;
bitset<100001> ans;

int main() {
    setIO();  re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        D.unite(a,b);
    }
    ans[0] = 1;
    FOR(i,1,n+1) if (D.get(i) == i) ans |= ans<<D.sz[i];
    FOR(i,1,n+1) pr(ans[i]);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
School Excursion,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<int SZ> struct DSU {
    int par[SZ], sz[SZ];
    
    DSU() {
        F0R(i,SZ) par[i] = i, sz[i] = 1;
    }
    
    int get(int x) { // path compression
        if (par[x] != x) par[x] = get(par[x]);
        return par[x];
    }
    
    bool unite(int x, int y) { // union-by-rank
        x = get(x), y = get(y);
        if (x == y) return 0;
        if (sz[x] < sz[y]) swap(x,y);
        sz[x] += sz[y], par[y] = x;
        return 1;
    }
};

DSU<MX> D;

int n,m, cnt[100001];
bitset<100001> ans;

int main() {
    setIO();  re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        D.unite(a,b);
    }
    ans[0] = 1;
    FOR(i,1,n+1) if (D.get(i) == i) cnt[D.sz[i]] ++;
    FOR(i,1,n+1) {
        int c = cnt[i]; cnt[i] = 0; int j = 1;
        while (c) {
            cnt[i*min(j,c)] ++;
            c -= min(j,c); j *= 2;
        }
        F0R(j,cnt[i]) ans |= ans<<i;
    }
    FOR(i,1,n+1) pr(ans[i]);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
School Excursion,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

struct UF {
    vi e;
    UF(int n) : e(n, -1) {}
    bool same_set(int a, int b) { return find(a) == find(b); }
    int size(int x) { return -e[find(x)]; }
    int find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }
    bool join(int a, int b) {
        a = find(a), b = find(b);
        if (a == b) return false;
        if (e[a] > e[b]) swap(a, b);
        e[a] += e[b]; e[b] = a;
        return true;
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    UF dsu(n);
    rep(i, 0, m) {
        int a, b;
        cin >> a >> b;
        dsu.join(a-1, b-1);
    }
    map<int, int> cnt;
    trav(a, dsu.e)
    if (a<0) cnt[-a]++;
    vi dp(n+1), s(n+1);
    dp[0]=1;
    trav(a, cnt) {
        int x=a.first, m=a.second+1;
        rep(i, 0, n+1) {
            s[i]=dp[i];
            if (i>=x) s[i]+=s[i-x];
            dp[i]=(s[i] > (i>=m*x? s[i-m*x]:0));
        }
    }
    rep(i, 1, n+1)
    cout << dp[i];
    cout << '\n';
    return 0;
}
"
School Excursion,Java,"// https://cses.fi/problemset/task/1706
// School Excursion
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1706 extends PrintWriter {
    CSES1706() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1706 o = new CSES1706(); o.main(); o.flush();
    }
    
    int[] dsu;
    int find(int i) {
        return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));
    }
    void join(int i, int j) {
        i = find(i);
        j = find(j);
        if (i == j)
            return;
        if (dsu[i] > dsu[j]) {
            dsu[j] += dsu[i];
            dsu[i] = j;
        } else {
            dsu[i] += dsu[j];
            dsu[j] = i;
        }
    }
    void main() {
        int n = sc.nextInt();
        int m = sc.nextInt();
        dsu = new int[n];
        Arrays.fill(dsu, -1);
        while (m-- > 0) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            join(i, j);
        }
        int[] kk = new int[n + 1];
        for (int i = 0; i < n; i++)
            if (dsu[i] < 0) {
                int c = -dsu[i];
                kk[c]++;
            }
        int[] dp = new int[n + 1];
        int inf = n + 1;
        Arrays.fill(dp, inf);
        dp[0] = 0;
        for (int c = 1; c <= n; c++) {
            int k = kk[c];
            if (k == 0)
                continue;
            for (int a = 0; a <= n; a++) {
                if (dp[a] < k)
                    dp[a + c] = Math.min(dp[a + c], dp[a] + 1);
                dp[a] = dp[a] <= k ? 0 : inf;
            }
        }
        char[] cc = new char[n];
        for (int c = 1; c <= n; c++)
            cc[c - 1] = dp[c] == 0 ? '1' : '0';
        println(cc);
    }
}
"
School Excursion,C++,"/*
 https://cses.fi/problemset/task/1706
 School Excursion
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100000

int min(int a, int b) { return a < b ? a : b; }

int dsu[N];

int find(int i) {
    return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));
}

void join(int i, int j) {
    i = find(i);
    j = find(j);
    if (i == j)
        return;
    if (dsu[i] > dsu[j]) {
        dsu[j] += dsu[i];
        dsu[i] = j;
    } else {
        dsu[i] += dsu[j];
        dsu[j] = i;
    }
}

int main() {
    static int kk[N + 1], dp[N + 1];
    static char cc[N + 1];
    int n, m, i, j, k, c, a, inf;
    
    scanf(""%d%d"", &n, &m);
    memset(dsu, -1, sizeof dsu);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        join(i, j);
    }
    for (i = 0; i < n; i++)
        if (dsu[i] < 0) {
            c = -dsu[i];
            kk[c]++;
        }
    inf = n + 1;
    for (i = 1; i <= n; i++)
        dp[i] = inf;
    dp[0] = 0;
    for (c = 1; c <= n; c++) {
        k = kk[c];
        if (k == 0)
            continue;
        for (a = 0; a <= n; a++) {
            if (dp[a] < k)
                dp[a + c] = min(dp[a + c], dp[a] + 1);
            dp[a] = dp[a] <= k ? 0 : inf;
        }
    }
    for (a = 1; a <= n; a++)
        cc[a - 1] = '0' + (dp[a] == 0);
    printf(""%s\n"", cc);
    return 0;
}
"
Shortest Subsequence,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

string s;
int S[1<<20], nex[1<<20][4];

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> s;
    F0R(i,sz(s)) {
        switch (s[i]) {
            case 'A':
                S[i] = 0;
                break;
            case 'C':
                S[i] = 1;
                break;
            case 'G':
                S[i] = 2;
                break;
            default:
                S[i] = 3;
        }
    }
    F0R(i,4) nex[sz(s)][i] = sz(s)+1;
    F0Rd(i,sz(s)) {
        F0R(j,4) nex[i][j] = nex[i+1][j];
        nex[i][S[i]] = i+1;
    }
    int cur = 0;
    string ret = ""ACGT"";
    while (cur < sz(s)+1) {
        pii bes = {-1,-1};
        F0R(i,4) bes = max(bes,{nex[cur][i],i});
        cout << ret[bes.s];
        cur = bes.f;
    }
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Shortest Subsequence,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    string s,  ans;
    cin >> s;
    set<char> x;
    trav(c, s) {
        x.insert(c);
        if (sz(x)==4)
            ans+=c, x.clear();
    }
    trav(c, string(""AGCT""))
    if (!x.count(c)) {
        ans+=c;
        break;
    }
    cout << ans << '\n';
    return 0;
}
"
Shortest Subsequence,Java,"// https://cses.fi/problemset/task/1087
// Subsequence
import java.io.*;

public class CSES1087 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        char[] cc = br.readLine().toCharArray();
        int n = cc.length, k = 0, a, c, g, t;
        char x;
        a = c = g = t = -1;
        for (int i = 0; i < n; i++) {
            x = cc[i];
            if (x == 'A')
                a = i;
            else if (x == 'C')
                c = i;
            else if (x == 'G')
                g = i;
            else
                t = i;
            if (a != -1 && c != -1 && g != -1 && t != -1) {
                cc[k++] = x;
                a = c = g = t = -1;
            }
        }
        if (a == -1)
            x = 'A';
        else if (c == -1)
            x = 'C';
        else if (g == -1)
            x = 'G';
        else
            x = 'T';
        cc[k++] = x;
        System.out.println(new String(cc, 0, k));
    }
}
"
Shortest Subsequence,C++,"/*
 https://cses.fi/problemset/task/1087
 Subsequence
 */
#include <stdio.h>
#include <string.h>

#define N    1000000

int main() {
    static char cc[N + 1];
    int n, i, a, c, g, t, k;
    char x;
    
    scanf(""%s"", cc);
    n = strlen(cc);
    k = 0;
    a = c = g = t = -1;
    for (i = 0; i < n; i++) {
        x = cc[i];
        if (x == 'A')
            a = i;
        else if (x == 'C')
            c = i;
        else if (x == 'G')
            g = i;
        else
            t = i;
        if (a != -1 && c != -1 && g != -1 && t != -1) {
            cc[k++] = x;
            a = c = g = t = -1;
        }
    }
    if (a == -1)
        x = 'A';
    else if (c == -1)
        x = 'C';
    else if (g == -1)
        x = 'G';
    else
        x = 'T';
    cc[k++] = x;
    cc[k] = '\0';
    printf(""%s\n"", cc);
    return 0;
}
"
Sorting Methods,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
typedef pair<ll,ll> pll;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MX = 200001;
const int MOD = 1000000007;

int n, p[MX], pos[MX];

ll solve1() {
    Tree<int> T;
    ll ans = 0;
    FOR(i,1,n+1) {
        ans += sz(T)-T.order_of_key(p[i]);
        T.insert(p[i]);
    }
    return ans;
}

bool done[MX];

int solve2() {
    int ans = 0;
    FOR(i,1,n+1) if (!done[i]) {
        int cur = p[i];
        int z = 0;
        while (cur != i) {
            done[cur] = 1;
            cur = p[cur];
            z ++;
        }
        done[cur] = 1;
        ans += z;
    }
    return ans;
}


vi bes = {0};

void ad(int x) {
    int lo = 0, hi = sz(bes)-1;
    while (lo < hi) {
        int mid = (lo+hi+1)/2;
        if (bes[mid] < x) lo = mid;
        else hi = mid-1;
    }
    if (lo == sz(bes)-1) bes.pb(0);
    bes[lo+1] = x;
}

int solve3() {
    FOR(i,1,n+1) ad(p[i]);
    return n-(sz(bes)-1);
}

int solve4() {
    int cur = MOD;
    FORd(i,1,n+1) {
        if (pos[i] < cur) cur = pos[i];
        else return i;
    }
    return 0;
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n;
    FOR(i,1,n+1) {
        cin >> p[i];
        pos[p[i]] = i;
    }
    cout << solve1() << "" "" << solve2() << "" "" << solve3() << "" "" << solve4();
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Sorting Methods,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

struct FT {
    vector<ll> s;
    FT(int n) : s(n) {}
    void update(int pos, ll dif) { // a[pos] += dif
        for (; pos < sz(s); pos |= pos + 1) s[pos] += dif;
    }
    ll query(int pos) { // sum of values in [0, pos)
        ll res = 0;
        for (; pos > 0; pos &= pos - 1) res += s[pos-1];
        return res;
    }
    int lower_bound(ll sum) {// min pos st sum of [0, pos] >= sum
        // Returns n if no sum is >= sum, or -1 if empty sum is.
        if (sum <= 0) return -1;
        int pos = 0;
        for (int pw = 1 << 25; pw; pw >>= 1) {
            if (pos + pw <= sz(s) && s[pos + pw-1] < sum)
                pos += pw, sum -= s[pos-1];
        }
        return pos;
    }
};

vi val, comp, z, cont;
int Time, ncomps;
template<class G, class F> int dfs(int j, G& g, F& f) {
    int low = val[j] = ++Time, x; z.push_back(j);
    trav(e,g[j]) if (comp[e] < 0)
        low = min(low, val[e] ?: dfs(e,g,f));
    
    if (low == val[j]) {
        do {
            x = z.back(); z.pop_back();
            comp[x] = ncomps;
            cont.push_back(x);
        } while (x != j);
        f(cont); cont.clear();
        ncomps++;
    }
    return val[j] = low;
}
template<class G, class F> void scc(G& g, F f) {
    int n = sz(g);
    val.assign(n, 0); comp.assign(n, -1);
    Time = ncomps = 0;
    rep(i,0,n) if (comp[i] < 0) dfs(i, g, f);
}

template<class I> vi lis(vector<I> S) {
    vi prev(sz(S));
    typedef pair<I, int> p;
    vector<p> res;
    rep(i,0,sz(S)) {
        p el { S[i], i };
        //S[i]+1 for non-decreasing
        auto it = lower_bound(all(res), p { S[i], 0 });
        if (it == res.end()) res.push_back(el), it = --res.end();
        *it = el;
        prev[i] = it==res.begin() ?0:(it-1)->second;
    }
    int L = sz(res), cur = res.back().second;
    vi ans(L);
    while (L--) ans[L] = cur, cur = prev[cur];
    return ans;
}

ll f1(vi &x) {
    int n=sz(x);
    ll ans=0;
    FT t(n);
    rep(i, 0, n) {
        ans+=i-t.query(x[i]-1);
        t.update(x[i]-1, 1);
    }
    return ans;
}

ll f2(vi &x) {
    int n=sz(x);
    vector<vi> g(n);
    rep(i, 0, n) g[i].push_back(x[i]-1);
    scc(g, [](vi&){});
    return n-ncomps;
}

ll f3(vi &x) {
    return sz(x)-sz(lis(x));
}

ll f4(vi &x) {
    int i=0, n=sz(x);
    rep(j, 0, n)
    if (x[n-1-j]==n-i) i++;
    return n-i;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vi x(n);
    rep(i, 0, n) cin >> x[i];
    cout << f1(x) << "" "" << f2(x) << "" "" << f3(x) << "" "" << f4(x) << '\n';
    return 0;
}
"
Sorting Methods,Java,"// https://cses.fi/problemset/task/1162
// Sorting Methods
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1162 {
    static int[] tt;
    static void update(int i, int n) {
        while (i < n) {
            tt[i]++;
            i |= i + 1;
        }
    }
    static int query(int i) {
        int cnt = 0;
        while (i >= 0) {
            cnt += tt[i];
            i &= i + 1;
            i--;
        }
        return cnt;
    }
    static void update_max(int i, int n, int x) {
        while (i < n) {
            tt[i] = Math.max(tt[i], x);
            i |= i + 1;
        }
    }
    static int query_max(int i) {
        int max = 0;
        while (i >= 0) {
            max = Math.max(max, tt[i]);
            i &= i + 1;
            i--;
        }
        return max;
    }
    static long solve1(int[] aa, int n) {
        Arrays.fill(tt, 0);
        long sum = 0;
        for (int i = 0; i < n; i++) {
            sum += query(aa[i]);
            update(aa[i], n);
        }
        return (long) n * (n - 1) / 2 - sum;
    }
    static int solve2(int[] aa, int n) {
        boolean[] used = new boolean[n];
        int cnt = 0;
        for (int i = 0; i < n; i++)
            if (!used[i]) {
                cnt++;
                for (int j = i; !used[j]; j = aa[j])
                    used[j] = true;
            }
        return n - cnt;
    }
    static int solve3(int[] aa, int n) {
        Arrays.fill(tt, 0);
        for (int i = 0; i < n; i++)
            update_max(aa[i], n, query_max(aa[i]) + 1);
        return n - query_max(n - 1);
    }
    static int solve4(int[] aa, int n) {
        int[] pp = new int[n];
        for (int i = 0; i < n; i++)
            pp[aa[i]] = i;
        int i = n - 1;
        while (i > 0 && pp[i - 1] < pp[i])
            i--;
        return i;
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = sc.nextInt() - 1;
        tt = new int[n];
        long ans1 = solve1(aa, n);
        int ans2 = solve2(aa, n);
        int ans3 = solve3(aa, n);
        int ans4 = solve4(aa, n);
        System.out.println(ans1 + "" "" + ans2 + "" "" + ans3 + "" "" + ans4);
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb); //if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        String next() throws IOException {
            StringBuilder sb = new StringBuilder();
            for (byte b = skip(); b > 32; b = getc())
                sb.append((char) b);
            return sb.toString();
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Sorting Methods,Java,"// https://cses.fi/problemset/task/1162
// Sorting Methods
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1162 {
    static int[] tt;
    static void update(int i, int n) {
        while (i < n) {
            tt[i]++;
            i |= i + 1;
        }
    }
    static int query(int i) {
        int cnt = 0;
        while (i >= 0) {
            cnt += tt[i];
            i &= i + 1;
            i--;
        }
        return cnt;
    }
    static void update_max(int i, int n, int x) {
        while (i < n) {
            tt[i] = Math.max(tt[i], x);
            i |= i + 1;
        }
    }
    static int query_max(int i) {
        int max = 0;
        while (i >= 0) {
            max = Math.max(max, tt[i]);
            i &= i + 1;
            i--;
        }
        return max;
    }
    static long solve1(int[] aa, int n) {
        Arrays.fill(tt, 0);
        long sum = 0;
        for (int i = 0; i < n; i++) {
            sum += query(aa[i]);
            update(aa[i], n);
        }
        return (long) n * (n - 1) / 2 - sum;
    }
    static int solve2(int[] aa, int n) {
        boolean[] used = new boolean[n];
        int cnt = 0;
        for (int i = 0; i < n; i++)
            if (!used[i]) {
                cnt++;
                for (int j = i; !used[j]; j = aa[j])
                    used[j] = true;
            }
        return n - cnt;
    }
    static int solve3(int[] aa, int n) {
        Arrays.fill(tt, 0);
        for (int i = 0; i < n; i++)
            update_max(aa[i], n, query_max(aa[i]) + 1);
        return n - query_max(n - 1);
    }
    static int solve4(int[] aa, int n) {
        int[] pp = new int[n];
        for (int i = 0; i < n; i++)
            pp[aa[i]] = i;
        int i = n - 1;
        while (i > 0 && pp[i - 1] < pp[i])
            i--;
        return i;
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = sc.nextInt() - 1;
        tt = new int[n];
        long ans1 = solve1(aa, n);
        int ans2 = solve2(aa, n);
        int ans3 = solve3(aa, n);
        int ans4 = solve4(aa, n);
        System.out.println(ans1 + "" "" + ans2 + "" "" + ans3 + "" "" + ans4);
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Sorting Methods,C++,"/*
 https://cses.fi/problemset/task/1162
 Sorting Methods
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    200000

int tt[N];

void update(int i, int n) {
    while (i < n) {
        tt[i]++;
        i |= i + 1;
    }
}

int query(int i) {
    int cnt = 0;
    
    while (i >= 0) {
        cnt += tt[i];
        i &= i + 1;
        i--;
    }
    return cnt;
}

void update_max(int i, int n, int x) {
    while (i < n) {
        if (tt[i] < x)
            tt[i] = x;
        i |= i + 1;
    }
}

int query_max(int i) {
    int max = 0;
    
    while (i >= 0) {
        if (max < tt[i])
            max = tt[i];
        i &= i + 1;
        i--;
    }
    return max;
}

long long solve1(int *aa, int n) {
    long long sum = 0;
    int i;
    
    memset(tt, 0, sizeof tt);
    for (i = 0; i < n; i++) {
        sum += query(aa[i]);
        update(aa[i], n);
    }
    return (long long) n * (n - 1) / 2 - sum;
}

int solve2(int *aa, int n) {
    static char used[N];
    int i, j, cnt;
    
    memset(used, 0, sizeof used);
    cnt = 0;
    for (i = 0; i < n; i++)
        if (!used[i]) {
            cnt++;
            for (j = i; !used[j]; j = aa[j])
                used[j] = 1;
        }
    return n - cnt;
}

int solve3(int *aa, int n) {
    int i;
    
    memset(tt, 0, sizeof tt);
    for (i = 0; i < n; i++)
        update_max(aa[i], n, query_max(aa[i]) + 1);
    return n - query_max(n - 1);
}

int solve4(int *aa, int n) {
    static int pp[N];
    int i;
    
    for (i = 0; i < n; i++)
        pp[aa[i]] = i;
    i = n - 1;
    while (i > 0 && pp[i - 1] < pp[i])
        i--;
    return i;
}

int main() {
    static int aa[N];
    int n, i, ans2, ans3, ans4;
    long long ans1;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]), aa[i]--;
    ans1 = solve1(aa, n);
    ans2 = solve2(aa, n);
    ans3 = solve3(aa, n);
    ans4 = solve4(aa, n);
    printf(""%lld %d %d %d\n"", ans1, ans2, ans3, ans4);
    return 0;
}
"
Stick Divisions,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int x,n;
priority_queue<int,vi,greater<int>> pq;
ll ans = 0;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> x >> n;
    F0R(i,n) {
        int z; cin >> z;
        pq.push(z);
    }
    while (pq.size() > 1) {
        int a = pq.top(); pq.pop();
        int b = pq.top(); pq.pop();
        ans += a+b;
        pq.push(a+b);
    }
    cout << ans;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Stick Divisions,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int x, n;
    cin >> x >> n;
    priority_queue<ll, vector<ll>, greater<ll>> q;
    while (n--) {
        ll a;
        cin >> a;
        q.push(a);
    }
    ll ans=0;
    while (sz(q)>=2) {
        ll a=q.top(); q.pop();
        ll b=q.top(); q.pop();
        ans+=a+b;
        q.push(a+b);
    }
    cout << ans << '\n';
    return 0;
}
"
Stick Divisions,C++,"// https://cses.fi/problemset/task/1161
// Stick Divisions
// practice with rainboy
#include <iostream>
#include <map>

using namespace std;

map<int, int> mp;

int get() {
    auto it = mp.begin();
    int x = it->first;
    if (it->second == 1)
        mp.erase(it);
    else
        it->second--;
    return x;
}

int main() {
    int x, n;
    scanf(""%d%d"", &x, &n);
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &x);
        mp[x]++;
    }
    long long ans = 0;
    for (int i = 0; i < n - 1; i++) {
        int x = get() + get();
        mp[x]++;
        ans += x;
    }
    printf(""%lld\n"", ans);
    return 0;
}
"
Stick Divisions,C++,"/*
 https://cses.fi/problemset/task/1161
 Stick Divisions
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000

struct V {
    int i; /* for heap */
    int x;
} vv[N], *pq[1 + N];

int cnt;

#define LT(u, v) ((u)->x < (v)->x)

int i2(int i) {
    return (i *= 2) > cnt ? 0 : i < cnt && LT(pq[i + 1], pq[i]) ? i + 1 : i;
}

void pq_up(struct V *u) {
    int i, j;
    
    for (i = u->i; (j = i / 2) && LT(u, pq[j]); i = j)
        pq[pq[j]->i = i] = pq[j];
    pq[u->i = i] = u;
}

void pq_dn(struct V *u) {
    int i, j;
    
    for (i = u->i; (j = i2(i)) && LT(pq[j], u); i = j)
        pq[pq[j]->i = i] = pq[j];
    pq[u->i = i] = u;
}

void pq_add(struct V *u) {
    u->i = ++cnt;
    pq_up(u);
}

struct V *pq_remove_first() {
    struct V *u = pq[1], *v = pq[cnt--];
    
    v->i = 1;
    pq_dn(v);
    return u;
}

int main() {
    int x, n, i;
    long long ans;
    
    scanf(""%d%d"", &x, &n);
    for (i = 0; i < n; i++) {
        scanf(""%d"", &x);
        vv[i].x = x;
        pq_add(&vv[i]);
    }
    ans = 0;
    while (--n) {
        struct V *u = pq_remove_first(), *v = pq_remove_first();
        
        ans += u->x += v->x;
        pq_add(u);
    }
    printf(""%lld\n"", ans);
    return 0;
}
"
String Removals,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;


int distinct(string S) {
    vi tot(26);
    int ans = 1;
    for (char c: S) {
        int t = (ans-tot[c-'a']+MOD)%MOD;
        tot[c-'a'] = (tot[c-'a']+t)%MOD;
        ans = (ans+t)%MOD;
    }
    return ans;
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    string s; cin >> s;
    cout << (distinct(s)+MOD-1)%MOD;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
String Removals,C++,"#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 100001;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

template<class A, class B> A operator+=(A& l, const B& r) { return l = l+r; }
template<class A, class B> A operator-=(A& l, const B& r) { return l = l-r; }
template<class A, class B> A operator*=(A& l, const B& r) { return l = l*r; }
template<class A, class B> A operator/=(A& l, const B& r) { return l = l/r; }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; trav(a,x) pr(!fst?"", "":"""",a), fst = 0;
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modInt {
    T val;
    T mod = 0;
    // static const T mod = MOD;
    
    void normalize() {
        if (mod == 0) return;
        val %= mod; if (val < 0) val += mod;
    }
    modInt(T v = 0, T m = 0) : val(v), mod(m) { normalize(); }
    // modInt(T v = 0, T m = 0) : val(v) { normalize(); }
    
    explicit operator T() const { return val; }
    friend ostream& operator<<(ostream& os, const modInt& a) { return os << a.val; }
    friend bool operator==(const modInt& a, const modInt& b) { return a.val == b.val; }
    friend bool operator!=(const modInt& a, const modInt& b) { return !(a == b); }
    
    friend void check(modInt& a, modInt& b) { // make sure all operations are valid
        // comment out if mod is static const
        if (a.mod > 0 && b.mod > 0) { assert(a.mod == b.mod); return; }
        T mod = max(a.mod,b.mod); if (mod == 0) mod = MOD;
        if (a.mod != mod) { a.mod = mod; a.normalize(); }
        if (b.mod != mod) { b.mod = mod; b.normalize(); }
    }
    friend modInt operator+(modInt a, modInt b) {
        check(a,b); a.val += (T)b;
        if (a.val >= a.mod) a.val -= a.mod;
        return a;
    }
    friend modInt operator-(modInt a, modInt b) {
        check(a,b); a.val -= (T)b;
        if (a.val < 0) a.val += a.mod;
        return a;
    }
    friend modInt operator-(const modInt& a) { return modInt(0)-a; }
    
    friend modInt operator*(modInt a, modInt b) {
        check(a,b); a.val = (ll)a.val*(T)b%a.mod; return a;
    }
    friend modInt exp(modInt a, ll p) {
        modInt ans(1,a.mod);
        for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modInt inv(const modInt& a) {
        return {invGeneral(a.val,a.mod),a.mod};
        // return exp(b,b.mod-2) if prime
    }
    friend modInt operator/(modInt a, modInt b) {
        check(a,b); return a*inv(b);
    }
};

typedef modInt<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

mi distinct(const string& S) {
    vmi tot(26); mi ans = 1;
    trav(c,S) {
        mi t = ans-tot[c-'a'];
        tot[c-'a'] += t, ans += t;
    }
    return ans;
}

int main() {
    // you should actually read the stuff at the bottom
    setIO(); string s; re(s); ps(distinct(s)-1);
    
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
String Removals,C++,"#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 100001;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

template<class A, class B> A operator+=(A& l, const B& r) { return l = l+r; }
template<class A, class B> A operator-=(A& l, const B& r) { return l = l-r; }
template<class A, class B> A operator*=(A& l, const B& r) { return l = l*r; }
template<class A, class B> A operator/=(A& l, const B& r) { return l = l/r; }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; trav(a,x) pr(!fst?"", "":"""",a), fst = 0;
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modInt {
    T val;
    T mod = 0;
    // static const T mod = MOD;
    
    void normalize() {
        if (mod == 0) return;
        val %= mod; if (val < 0) val += mod;
    }
    modInt(T v = 0, T m = 0) : val(v), mod(m) { normalize(); }
    // modInt(T v = 0, T m = 0) : val(v) { normalize(); }
    
    explicit operator T() const { return val; }
    friend ostream& operator<<(ostream& os, const modInt& a) { return os << a.val; }
    friend bool operator==(const modInt& a, const modInt& b) { return a.val == b.val; }
    friend bool operator!=(const modInt& a, const modInt& b) { return !(a == b); }
    
    friend void check(modInt& a, modInt& b) { // make sure all operations are valid
        // comment out if mod is static const
        if (a.mod > 0 && b.mod > 0) { assert(a.mod == b.mod); return; }
        T mod = max(a.mod,b.mod); if (mod == 0) mod = MOD;
        if (a.mod != mod) { a.mod = mod; a.normalize(); }
        if (b.mod != mod) { b.mod = mod; b.normalize(); }
    }
    friend modInt operator+(modInt a, modInt b) {
        check(a,b); a.val += (T)b;
        if (a.val >= a.mod) a.val -= a.mod;
        return a;
    }
    friend modInt operator-(modInt a, modInt b) {
        check(a,b); a.val -= (T)b;
        if (a.val < 0) a.val += a.mod;
        return a;
    }
    friend modInt operator-(const modInt& a) { return modInt(0)-a; }
    
    friend modInt operator*(modInt a, modInt b) {
        check(a,b); a.val = (ll)a.val*(T)b%a.mod; return a;
    }
    friend modInt exp(modInt a, ll p) {
        modInt ans(1,a.mod);
        for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modInt inv(const modInt& a) {
        return {invGeneral(a.val,a.mod),a.mod};
        // return exp(b,b.mod-2) if prime
    }
    friend modInt operator/(modInt a, modInt b) {
        check(a,b); return a*inv(b);
    }
};

typedef modInt<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

mi distinct(const string& S) {
    vmi tot(26); mi ans = 1;
    trav(c,S) tie(ans,tot[c-'a']) = mp(2*ans-tot[c-'a'],ans);
    return ans;
}

int main() {
    // you should actually read the stuff at the bottom
    setIO(); string s; re(s); ps(distinct(s)-1);
    
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
String Removals,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int P=1e9+7;
    string s;
    cin >> s;
    vi x(26);
    int t=0;
    trav(c, s) {
        int cur=x[c-'a'];
        x[c-'a']=(t+1)%P;
        t=(2LL*t+P+1-cur)%P;
    }
    cout << t << '\n';
    return 0;
}
"
String Removals,C++,"// https://cses.fi/problemset/task/1149
// String Removals
// practice with rainboy
#include <iostream>

using namespace std;

const int MD = 1000000007;

int main() {
    static char cc[500001];
    scanf(""%s"", cc);
    static int kk[26];
    int k = 0;
    for (int i = 0; cc[i]; i++) {
        int c = cc[i] - 'a';
        int kc = kk[c];
        kk[c] = k + 1;
        k = (k + (kk[c] - kc) % MD) % MD;
    }
    printf(""%d\n"", (k + MD) % MD);
    return 0;
}
"
String Removals,C++,"/*
 https://cses.fi/problemset/task/1149
 String Removals
 practice with Dukkha
 */
#include <stdio.h>

#define N    500000
#define MD    1000000007

int main() {
    static char cc[N + 1];
    static int kk[26];
    int i, k, c, kc;
    
    scanf(""%s"", cc);
    k = 0;
    for (i = 0; cc[i]; i++) {
        c = cc[i] - 'a';
        kc = kk[c];
        kk[c] = k + 1;
        k = (k + (kk[c] - kc) % MD) % MD;
    }
    printf(""%d\n"", (k + MD) % MD);
    return 0;
}
"
String Reorder,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

string ans;
int co[26];

bool ok() {
    int sum = 0, mx = 0;
    F0R(i,26) {
        if (co[i] > co[mx]) mx = i;
        sum += co[i];
    }
    if (2*co[mx] <= sum) return 1;
    if (2*co[mx]-1 == sum && !(sz(ans) && (ans.back()-'A') == mx)) return 1;
    return 0;
}

int main() {
    setIO(); string s; re(s); trav(t,s) co[t-'A'] ++;
    if (!ok()) {
        ps(-1);
        exit(0);
    }
    while (sz(ans) < sz(s)) {
        F0R(i,26) if (co[i]) {
            if (sz(ans) && ans.back()-'A' == i) continue;
            ans += char('A'+i); co[i] --;
            if (ok()) break;
            ans.pop_back(); co[i] ++;
        }
    }
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
String Reorder,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    string s;
    cin >> s;
    vi f(26);
    trav(c, s) f[c-'A']++;
    string ans;
    int n=sz(s), last=-1;
    rep(i, 0, n) {
        int j=-1, k=0;
        rep(c, 0, 26) {
            if (j==-1 && f[c] && c!=last) j=c;
            if (f[c]>f[k]) k=c;
        }
        if (j==-1) {
            cout << ""-1\n"";
            return 0;
        }
        last=(k==last || 2*f[k]-1<n-i? j:k);
        ans+='A'+last;
        f[last]--;
    }
    cout << ans << '\n';
    return 0;
}
"
String Reorder,Java,"// https://cses.fi/problemset/task/1743
// String Reorder
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1743 extends PrintWriter {
    CSES1743() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int m = 1 << 7; byte[] cc = new byte[m];
        int read() {
            byte c = 0; while (c <= 32) c = getc();
            int n = 0;
            while (c > 32) {
                if (n == m) cc = Arrays.copyOf(cc, m <<= 1);
                cc[n++] = c; c = getc();
            }
            return n;
        }
        byte[] nextBytes() { int n = read(); return Arrays.copyOf(cc, n); }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1743 c = new CSES1743(); c.main(); c.flush();
    }
    
    static final int A = 26;
    void main() {
        byte[] cc = sc.nextBytes();
        int n = cc.length;
        int[] kk = new int[A];
        for (int i = 0; i < n; i++) {
            int a = cc[i] - 'A';
            kk[a]++;
        }
        for (int a = 0; a < A; a++)
            if (n < kk[a] * 2 - 1) {
                println(-1);
                return;
            }
        int p = -1;
        for (int i = 0; i < n; i++) {
            int a = 0;
            while (a < A && (a == p || kk[a] == 0))
                a++;
            int b = 0;
            for (int c = 1; c < A; c++)
                if (kk[b] < kk[c])
                    b = c;
            a = a != b && n - i - 1 < kk[b] * 2 - 1 ? b : a;
            kk[a]--;
            cc[i] = (byte) (a + 'A');
            p = a;
        }
        println(new String(cc));
    }
}
"
String Reorder,C++,"/*
 https://cses.fi/problemset/task/1743
 String Reorder
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    1000000
#define A    26

int main() {
    static char cc[N + 1];
    static int kk[A];
    int n, i, p, a, b, c;
    
    scanf(""%s"", cc);
    n = strlen(cc);
    for (i = 0; i < n; i++) {
        a = cc[i] - 'A';
        kk[a]++;
    }
    for (a = 0; a < A; a++)
        if (n < kk[a] * 2 - 1) {
            printf(""-1\n"");
            return 0;
        }
    p = -1;
    for (i = 0; i < n; i++) {
        a = 0;
        while (a < A && (a == p || kk[a] == 0))
            a++;
        b = 0;
        for (c = 1; c < A; c++)
            if (kk[b] < kk[c])
                b = c;
        a = a != b && n - i - 1 < kk[b] * 2 - 1 ? b : a;
        kk[a]--;
        cc[i] = a + 'A';
        p = a;
    }
    printf(""%s\n"", cc);
    return 0;
}
"
String Transform,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

string s;
vector<pair<char,int>> v;
int nex[1000001];

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> s;
    F0R(i,sz(s)) v.pb({s[i],i});
    sort(all(v));
    F0R(i,sz(v)) nex[i] = v[i].s;
    int cur = nex[0];
    while (cur != 0) {
        cout << v[cur].f;
        cur = nex[cur];
    }
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
String Transform,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    string s;
    cin >> s;
    int n=sz(s);
    vector<pii> x(n);
    rep(i, 0, n) x[i]={s[i], i};
    sort(all(x));
    string ans;
    int j=0;
    rep(i, 0, n) {
        ans+=x[j].first;
        j=x[j].second;
    }
    cout << ans.substr(1) << '\n';
    return 0;
}
"
String Transform,Java,"// https://cses.fi/problemset/task/1113
// String Transform
// practice with rainboy
import java.io.*;

public class CSES1113 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        char[] cc = br.readLine().toCharArray();
        int[] kk = new int[26];
        int n = cc.length - 1;
        for (int i = 0; i <= n; i++)
            if (cc[i] != '#')
                kk[cc[i] - 'a']++;
        for (int c = 1; c < 26; c++)
            kk[c] += kk[c - 1];
        for (int c = 25; c > 0; c--)
            kk[c] = kk[c - 1];
        kk[0] = 0;
        int[] pp = new int[n + 1];
        for (int i = 0; i <= n; i++)
            if (cc[i] != '#')
                pp[i] = ++kk[cc[i] - 'a'];
        int[] ii = new int[n + 1];
        for (int i = 0; i <= n; i++)
            ii[pp[i]] = i;
        StringBuilder sb = new StringBuilder();
        for (int i = ii[0]; i != 0; i = ii[i])
            sb.append(cc[ii[i]]);
        System.out.println(sb);
    }
}
"
String Transform,C++,"/*
 https://cses.fi/problemset/task/1113
 String Transform
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    1000000

int main() {
    static char cc[N + 2], s[N + 1];
    static int kk[26], pp[N + 1], ii[N + 1];
    int n, i, c, k;
    
    scanf(""%s"", cc);
    n = strlen(cc) - 1;
    for (i = 0; i <= n; i++)
        if (cc[i] != '#')
            kk[cc[i] - 'a']++;
    for (c = 1; c < 26; c++)
        kk[c] += kk[c - 1];
    for (c = 25; c > 0; c--)
        kk[c] = kk[c - 1];
    kk[0] = 0;
    for (i = 0; i <= n; i++)
        if (cc[i] != '#')
            pp[i] = ++kk[cc[i] - 'a'];
    for (i = 0; i <= n; i++)
        ii[pp[i]] = i;
    k = 0;
    for (i = ii[0]; i != 0; i = ii[i])
        s[k++] = cc[ii[i]];
    printf(""%s\n"", s);
    return 0;
}
"
Swap Game,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

unordered_map<int,int> m;
queue<int> q;

int enc(vi v) {
    int res = 0;
    F0Rd(i,9) res = 10*res+v[i];
    return res;
}

vi dec(int a) {
    vi v;
    F0R(i,9) {
        v.pb(a%10);
        a /= 10;
    }
    return v;
}

void tri(int e, int b) {
    if (m.count(e)) return;
    m[e] = b; q.push(e);
}

void fin(vi v) {
    F0R(i,9) if (v[i] != i+1) return;
    ps(m[enc(v)]); exit(0);
}

int po10[10];

int swa(int z, int a, int b) {
    int A = z/po10[a]%10, B = z/po10[b]%10;
    z -= A*po10[a], z -= B*po10[b];
    z += A*po10[b], z += B*po10[a];
    return z;
}

int main() {
    po10[0] = 1; FOR(i,1,10) po10[i] = 10*po10[i-1];
    setIO(); vi v(9); re(v);
    q.push(enc(v)); m[enc(v)] = 0;
    while (sz(q)) {
        auto z = q.front(); q.pop();
        auto a = dec(z);
        fin(a);
        int dist = m[z]+1;
        F0R(i,3) F0R(j,2) {
            auto A = swa(z,3*i+j,3*i+j+1);
            tri(A,dist);
        }
        F0R(i,2) F0R(j,3) {
            auto A = swa(z,3*i+j,3*i+j+3);
            tri(A,dist);
        }
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Swap Game,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

#include <bits/extc++.h>
__gnu_pbds::gp_hash_table<string,int,hash<string>>
d({},{},{},{},{1<<16});

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    string t, ta;
    rep(i, 0, 9) {
        cin >> ta;
        t+=ta;
    }
    vector<pii> sw;
    rep(i, 0, 3) rep(j, 0, 2) {
        sw.push_back({3*i+j, 3*i+j+1});
        sw.push_back({3*j+i, 3*(j+1)+i});
    }
    string s=""123456789"";
    d[s]=1;
    queue<string> q;
    for(q.push(s); !q.empty(); q.pop()) {
        s=q.front();
        int cur=d[s];
        if (s==t) break;
        trav(p, sw) {
            swap(s[p.first], s[p.second]);
            if (!d[s])
                d[s]=cur+1, q.push(s);
            swap(s[p.first], s[p.second]);
        }
    }
    cout << d[t]-1 << '\n';
    return 0;
}
"
Swap Game,Java,"// https://cses.fi/problemset/task/1670
// Swap Game
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1670 extends PrintWriter {
    CSES1670() {
        super(System.out, true);
        try { _bb = System.in.readAllBytes(); } catch (IOException e) {}
    }
    byte[] _bb; int _i;
    byte getc() {
        int n = _bb.length;
        while (_i < n && _bb[_i] < 33) _i++;
        return _bb[_i++];
    }
    public static void main(String[] __) { new CSES1670().main(); }
    
    int[] ff = { 1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880 };
    byte[] cc = new byte[9];
    int rank() {
        int k = 0;
        for (int i = 0; i < 9; i++) {
            int l = 0;
            for (int j = i + 1; j < 9; j++)
                if (cc[j] < cc[i])
                    l++;
            k += l * ff[8 - i];
        }
        return k;
    }
    void inc() {
        int i = 7;
        while (cc[i] > cc[i + 1])
            i--;
        int j = i + 1;
        while (j + 1 < 9 && cc[j + 1] > cc[i])
            j++;
        byte tmp = cc[i]; cc[i] = cc[j]; cc[j] = tmp;
        for (i++, j = 8; i < j; i++, j--) {
            tmp = cc[i]; cc[i] = cc[j]; cc[j] = tmp;
        }
    }
    int[][] aa;
    void link(int i, int h, int u, int v) {
        byte tmp;
        tmp = cc[u]; cc[u] = cc[v]; cc[v] = tmp;
        aa[i][h] = rank();
        tmp = cc[u]; cc[u] = cc[v]; cc[v] = tmp;
    }
    void main() {
        for (int h = 0; h < 9; h++)
            cc[h] = (byte) (getc() - '1');
        int t = rank();
        if (t == 0) {
            println(0);
            return;
        }
        for (int h = 0; h < 9; h++)
            cc[h] = (byte) h;
        int n = ff[9];
        aa = new int[n][12];
        for (int i = 0; i < n; i++) {
            int h = 0;
            for (int r = 0; r < 3; r++)
                for (int c = 0; c < 3; c++) {
                    int u = r * 3 + c;
                    if (r < 2)
                        link(i, h++, u, u + 3);
                    if (c < 2)
                        link(i, h++, u, u + 1);
                }
            if (i + 1 < n)
                inc();
        }
        int[] dd = new int[n];
        Arrays.fill(dd, n);
        dd[0] = 0;
        int[] qq = new int[n];
        int head = 0, cnt = 0;
        qq[head + cnt++] = 0;
        while (cnt > 0) {
            int i = qq[head++]; cnt--;
            int d = dd[i] + 1;
            for (int h = 0; h < 12; h++) {
                int j = aa[i][h];
                if (dd[j] > d) {
                    dd[j] = d;
                    if (j == t) {
                        println(d);
                        return;
                    }
                    qq[head + cnt++] = j;
                }
            }
        }
    }
}
"
Swap Game,C++,"/*
 https://cses.fi/problemset/task/1670
 Swap Game
 practice with Dukkha
 */
#include <stdio.h>

#define N    362880    /* N = 9! */

int ff[] = { 1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880 };

int cc[9];

int rank() {
    int i, j, k = 0;
    
    for (i = 0; i < 9; i++) {
        int l = 0;
        
        for (j = i + 1; j < 9; j++)
            if (cc[j] < cc[i])
                l++;
        k += l * ff[8 - i];
    }
    return k;
}

void inc() {
    int i, j, tmp;
    
    i = 7;
    while (cc[i] > cc[i + 1])
        i--;
    j = i + 1;
    while (j + 1 < 9 && cc[j + 1] > cc[i])
        j++;
    tmp = cc[i], cc[i] = cc[j], cc[j] = tmp;
    for (i++, j = 8; i < j; i++, j--)
        tmp = cc[i], cc[i] = cc[j], cc[j] = tmp;
}

int aa[N][12];

void link(int i, int h, int u, int v) {
    int tmp;
    
    tmp = cc[u], cc[u] = cc[v], cc[v] = tmp;
    aa[i][h] = rank();
    tmp = cc[u], cc[u] = cc[v], cc[v] = tmp;
}

int main() {
    static int qq[N], dd[N];
    int h, i, j, t, r, c, u, head, cnt, d;
    
    for (h = 0; h < 9; h++)
        scanf(""%d"", &cc[h]);
    t = rank();
    if (t == 0) {
        printf(""0\n"");
        return 0;
    }
    for (h = 0; h < 9; h++)
        cc[h] = h;
    for (i = 0; i < N; i++) {
        h = 0;
        for (r = 0; r < 3; r++)
            for (c = 0; c < 3; c++) {
                u = r * 3 + c;
                if (r < 2)
                    link(i, h++, u, u + 3);
                if (c < 2)
                    link(i, h++, u, u + 1);
            }
        if (i + 1 < N)
            inc();
    }
    for (i = 0; i < N; i++)
        dd[i] = N;
    dd[0] = 0;
    head = cnt = 0;
    qq[head + cnt++] = 0;
    while (cnt) {
        i = qq[cnt--, head++];
        d = dd[i] + 1;
        for (h = 0; h < 12; h++)
            if (dd[j = aa[i][h]] > d) {
                dd[j] = d;
                if (j == t) {
                    printf(""%d\n"", d);
                    return 0;
                }
                qq[head + cnt++] = j;
            }
    }
    return 0;
}
"
Swap Round Sorting,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n, p[MX];
vector<vpi> mov;

void fin() {
    ps(sz(mov));
    trav(a,mov) {
        ps(sz(a));
        trav(b,a) {
            swap(p[b.f],p[b.s]);
            ps(b.f,b.s);
        }
    }
    FOR(i,1,n+1) if (p[i] != i) {
        ps(""OOPS"",p);
        exit(0);
    }
}

void init() {
    setIO(); re(n); FOR(i,1,n+1) re(p[i]);
    int cur = 0;
    FOR(i,1,n+1) {
        if (p[i] == i) continue;
        if (p[p[i]] == i) ckmax(cur,1);
        else ckmax(cur,MOD);
    }
    if (cur == 1) {
        vpi swa;
        FOR(i,1,n+1) if (p[i] > i) swa.pb({p[i],i});
        mov.pb(swa);
    }
    if (cur <= 1) fin();
}

bool vis[MX];

void deal(vi v) {
    if (sz(v) <= 1) return;
    if (sz(v) == 2) {
        mov[0].pb({v[0],v[1]});
        return;
    }
    for (int i = 1; i < sz(v)-i; ++i) {
        mov[0].pb({v[i-1],v[sz(v)-i-1]});
    }
    for (int i = 1; i < sz(v)-i; ++i) swap(v[i],v[sz(v)-i]);
    mov[1].pb({v[0],v[1]});
    for (int j = 2; j < sz(v)+1-j; ++j) mov[1].pb({v[j],v[sz(v)+1-j]});
    // ps(v);
}

int main() {
    init();
    mov.resz(2);
    FOR(i,1,n+1) if (!vis[i]) {
        vi v = {i};
        while (p[v.back()] != i) v.pb(p[v.back()]);
        trav(t,v) vis[t] = 1;
        deal(v);
    }
    // exit(0);
    fin();
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Swap Round Sorting,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

void outp(vector<pii> &r) {
    cout << sz(r) << '\n';
    trav(p, r)
    cout << p.first << "" "" << p.second << '\n';
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vi x(n+1);
    rep(i, 1, n+1) cin >> x[i];
    vector<vi> c;
    int mc=0;
    rep(i, 1, n+1) if (x[i]) {
        vi cur;
        int j=i;
        do {
            cur.push_back(j);
            j=x[j];
        } while (j!=i);
        trav(j, cur) x[j]=0;
        c.push_back(cur);
        mc=max(mc, sz(cur));
    }
    if (mc==1) {
        cout << ""0\n"";
    }
    else if (mc==2) {
        vector<pii> r;
        cout << ""1\n"";
        trav(p, c) if (sz(p)==2)
            r.push_back({p[0], p[1]});
        outp(r);
    }
    else {
        cout << ""2\n"";
        vector<pii> r;
        trav(p, c) {
            int m=sz(p);
            if (m==2)
                r.push_back({p[0], p[1]});
            if (m>2) {
                rep(i, 0, m) if (i<(m-i)%m)
                    r.push_back({p[i], p[(m-i)%m]});
            }
        }
        outp(r);
        r.clear();
        trav(p, c) {
            int m=sz(p);
            if (m>2) {
                rep(i, 0, m) if (i<(m+1-i)%m)
                    r.push_back({p[i], p[(m+1-i)%m]});
            }
        }
        outp(r);
    }
    return 0;
}
"
Swap Round Sorting,Java,"// https://cses.fi/problemset/task/1698
// Swap Round Sorting
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1698 extends PrintWriter {
    CSES1698() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1698 o = new CSES1698(); o.main(); o.flush();
    }
    
    void main() {
        int n = sc.nextInt();
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = sc.nextInt() - 1;
        int[] s1 = new int[n];
        int[] s2 = new int[n];
        int[] qq = new int[n];
        int k1 = 0, k2 = 0;
        for (int i = 0; i < n; i++) {
            if (aa[i] < 0 || aa[i] == i)
                continue;
            int cnt = 0;
            for (int j = i; aa[j] >= 0; aa[j] = -aa[j], j = -aa[j])
                qq[cnt++] = j;
            for (int u = 0, v = cnt - 2; u < v; u++, v--) {
                s1[k1++] = qq[u];
                s1[k1++] = qq[v];
            }
            for (int u = 0, v = cnt - 1; u < v; u++, v--) {
                s2[k2++] = qq[u];
                s2[k2++] = qq[v];
            }
        }
        println(k2 == 0 ? 0 : k1 == 0 ? 1 : 2);
        if (k1 != 0) {
            println(k1 / 2);
            while (k1 > 0) {
                println((s1[k1 - 1] + 1) + "" "" + (s1[k1 - 2] + 1));
                k1 -= 2;
            }
        }
        if (k2 != 0) {
            println(k2 / 2);
            while (k2 > 0) {
                println((s2[k2 - 1] + 1) + "" "" + (s2[k2 - 2] + 1));
                k2 -= 2;
            }
        }
    }
}
"
Swap Round Sorting,C++,"/*
 https://cses.fi/problemset/task/1698
 Swap Round Sorting
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000

int main() {
    static int aa[N], s1[N], s2[N], qq[N];
    int n, i, j, cnt, k1, k2, u, v;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]), aa[i]--;
    k1 = k2 = 0;
    for (i = 0; i < n; i++) {
        if (aa[i] < 0 || aa[i] == i)
            continue;
        cnt = 0;
        for (j = i; aa[j] >= 0; aa[j] = -aa[j], j = -aa[j])
            qq[cnt++] = j;
        for (u = 0, v = cnt - 2; u < v; u++, v--) {
            s1[k1++] = qq[u];
            s1[k1++] = qq[v];
        }
        for (u = 0, v = cnt - 1; u < v; u++, v--) {
            s2[k2++] = qq[u];
            s2[k2++] = qq[v];
        }
    }
    printf(""%d\n"", k2 == 0 ? 0 : k1 == 0 ? 1 : 2);
    if (k1) {
        printf(""%d\n"", k1 / 2);
        while (k1) {
            printf(""%d %d\n"", s1[k1 - 1] + 1, s1[k1 - 2] + 1);
            k1 -= 2;
        }
    }
    if (k2) {
        printf(""%d\n"", k2 / 2);
        while (k2) {
            printf(""%d %d\n"", s2[k2 - 1] + 1, s2[k2 - 2] + 1);
            k2 -= 2;
        }
    }
    return 0;
}
"
Tree Isomorphism I,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int t,n,depth[MX][2], label[MX][2];
vi lev[MX][2], adj[MX][2], child[MX][2];

void dfs1(int ind, int a, int p) {
    lev[depth[a][ind]][ind].pb(a);
    trav(t,adj[a][ind]) if (t != p) {
        depth[t][ind] = depth[a][ind]+1;
        child[a][ind].pb(t);
        dfs1(ind,t,a);
    }
}

void solve() {
    re(n);
    FOR(i,1,n+1) F0R(j,2) {
        adj[i][j].clear();
        lev[i][j].clear();
        child[i][j].clear();
    }
    F0R(j,2) {
        F0R(i,n-1) {
            int a,b; re(a,b);
            adj[a][j].pb(b), adj[b][j].pb(a);
        }
    }
    depth[1][0] = depth[1][1] = 1;
    dfs1(0,1,0); dfs1(1,1,0);
    FORd(i,1,n+1) {
        map<vi,int> m;
        // ps(i,lev[i][0],lev[i][1]);
        F0R(j,2)
        trav(a,lev[i][j]) {
            vi v; trav(b,child[a][j]) v.pb(label[b][j]);
            sort(all(v)); m[v];
        }
        int co = 0;
        trav(t,m) t.s = ++co;
        F0R(j,2)
        trav(a,lev[i][j]) {
            vi v; trav(b,child[a][j]) v.pb(label[b][j]);
            sort(all(v)); label[a][j] = m[v];
        }
    }
    if (label[1][0] == label[1][1]) ps(""YES"");
    else ps(""NO"");
}

int main() {
    setIO(); re(t);
    F0R(i,t) solve();
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Tree Isomorphism I,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vi h, id;
vector<vi> g;
map<int, vi> lvl;

void dfs(int i, int p) {
    trav(j, g[i])  if (j!=p) {
        dfs(j, i);
        h[i]=max(h[i], h[j]+1);
    }
    lvl[h[i]].push_back(i);
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        int m=2*n+1;
        g.assign(m, vi());
        rep(i, 0, 2) {
            rep(j, 0, n-1) {
                int a, b;
                cin >> a >> b;
                a+=i*n, b+=i*n;
                g[a].push_back(b);
                g[b].push_back(a);
            }
        }
        g[0]={1, n+1};
        h.assign(m, 0);
        id.assign(m, 0);
        lvl.clear();
        dfs(0, -1);
        if (h[1]!=h[n+1]) {
            cout << ""NO\n"";
            continue;
        }
        trav(l, lvl) {
            map<vector<ll>, int> u;
            trav(i, l.second) {
                vector<ll> cur;
                trav(j, g[i]) cur.push_back(3LL*n*h[j]+id[j]);
                sort(all(cur));
                if (!u.count(cur)) {
                    int s=sz(u);
                    u[cur]=s;
                }
                id[i]=u[cur];
            }
        }
        cout << (id[1]==id[n+1]? ""YES\n"":""NO\n"");
    }
    return 0;
}
"
Tree Isomorphism I,Java,"// https://cses.fi/problemset/task/1700
// Tree Isomorphism I
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1700 extends PrintWriter {
    CSES1700() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1700 o = new CSES1700(); o.main(); o.flush();
    }
    
    static final int MD = 1000000007;
    Random rand = new Random();
    ArrayList[] aa;
    int[] xx, yy, xx_, yy_;
    int dfs(int p, int i) {
        ArrayList<Integer> adj = aa[i];
        int h_ = -1;
        for (int j : adj)
            if (j != p) {
                int h = dfs(i, j);
                if (h_ < h)
                    h_ = h;
            }
        h_++;
        int x = xx[h_], x_ = 1;
        int y = yy[h_], y_ = 1;
        for (int j : adj)
            if (j != p) {
                x_ = (int) ((long) x_ * (x + xx_[j]) % MD);
                y_ = (int) ((long) y_ * (y + yy_[j]) % MD);
            }
        xx_[i] = x_;
        yy_[i] = y_;
        return h_;
    }
    void main() {
        long[] hh = new long[2];
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            aa = new ArrayList[n];
            xx = new int[n];
            yy = new int[n];
            xx[0] = yy[0] = 1;
            for (int h = 1; h < n; h++) {
                xx[h] = rand.nextInt(MD - 2) + 2;
                yy[h] = rand.nextInt(MD - 2) + 2;
            }
            xx_ = new int[n];
            yy_ = new int[n];
            for (int k = 0; k < 2; k++) {
                for (int i = 0; i < n; i++)
                    aa[i] = new ArrayList<Integer>();
                for (int h = 0; h < n - 1; h++) {
                    int i = sc.nextInt() - 1;
                    int j = sc.nextInt() - 1;
                    aa[i].add(j);
                    aa[j].add(i);
                }
                dfs(-1, 0);
                hh[k] = (long) xx_[0] * MD + yy_[0];
            }
            println(hh[0] == hh[1] ? ""YES"" : ""NO"");
        }
    }
}
"
Tree Isomorphism I,C++,"/*
 https://cses.fi/problemset/task/1700
 Tree Isomorphism I
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    100000
#define MD    1000000007

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

struct L {
    struct L *next;
    int j;
} aa[N];

int xx[N], yy[N], xx_[N], yy_[N];

void link(int i, int j) {
    static struct L l91[N * 2 * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next, aa[i].next = l++;
}

int dfs(int p, int i) {
    struct L *l;
    int j, h_, h, x, y, x_, y_;
    
    h_ = -1;
    for (l = aa[i].next; l; l = l->next)
        if ((j = l->j) != p)
            if (h_ < (h = dfs(i, j)))
                h_ = h;
    h_++;
    x = xx[h_], x_ = 1;
    y = yy[h_], y_ = 1;
    for (l = aa[i].next; l; l = l->next)
        if ((j = l->j) != p) {
            x_ = (long long) x_ * (x + xx_[j]) % MD;
            y_ = (long long) y_ * (y + yy_[j]) % MD;
        }
    xx_[i] = x_;
    yy_[i] = y_;
    return h_;
}

int main() {
    int t;
    
    init_rand();
    scanf(""%d"", &t);
    while (t--) {
        static long long hh[2];
        int n, h, i, j, k;
        
        scanf(""%d"", &n);
        xx[0] = 1;
        yy[0] = 1;
        for (h = 1; h < n; h++) {
            xx[h] = rand_(MD - 2) + 2;
            yy[h] = rand_(MD - 2) + 2;
        }
        for (k = 0; k < 2; k++) {
            for (i = 0; i < n; i++)
                aa[i].next = NULL;
            for (h = 0; h < n - 1; h++) {
                scanf(""%d%d"", &i, &j), i--, j--;
                link(i, j);
                link(j, i);
            }
            dfs(-1, 0);
            hh[k] = (long long) xx_[0] * MD + yy_[0];
        }
        printf(hh[0] == hh[1] ? ""YES\n"" : ""NO\n"");
    }
    return 0;
}
"
Tree Isomorphism II,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<int SZ> struct TreeDiameter {
    int n;
    vi adj[SZ];
    void addEdge(int a, int b) { adj[a].pb(b), adj[b].pb(a); }
    
    int par[SZ], dist[SZ];
    void dfs(int x) {
        trav(y,adj[x]) if (y != par[x]) {
            par[y] = x; dist[y] = dist[x]+1;
            dfs(y);
        }
    }
    void genDist(int x) { par[x] = -1; dist[x] = 0; dfs(x); }
    
    int diaLength;
    vi center, dia = {1,1};
    void init(int _n) {
        n = _n; dia = {1,1}; center.clear();
        genDist(1); FOR(i,1,n+1) if (dist[i] > dist[dia[0]]) dia[0] = i; // find one endpoint of a diameter
        genDist(dia[0]); FOR(i,1,n+1) if (dist[i] > dist[dia[1]]) dia[1] = i;
        diaLength = dist[dia[1]];
        /*trav(t,center) if (t > n) {
         ps(""OOPS"",center,n);
         exit(0);
         }
         ps(""PROCESS"",n,diaLength);
         FOR(i,1,n+1) pr(dist[i],' ');
         ps();*/
        int cen = dia[1]; F0R(i,diaLength/2) cen = par[cen];
        if (diaLength&1) center = {cen,par[cen]};
        else center = {cen};
    }
};

TreeDiameter<MX> T[2];
int t,n,depth[MX][2], label[MX][2];
vi lev[MX][2], child[MX][2];

void dfs1(int ind, int a, int p) {
    lev[depth[a][ind]][ind].pb(a);
    trav(t,T[ind].adj[a]) if (t != p) {
        // assert(t <= n);
        depth[t][ind] = depth[a][ind]+1;
        child[a][ind].pb(t);
        dfs1(ind,t,a);
    }
}

bool eq(int a, int b) {
    FOR(i,1,n+1) F0R(j,2) {
        lev[i][j].clear();
        child[i][j].clear();
    }
    depth[a][0] = depth[b][1] = 1;
    dfs1(0,a,0); dfs1(1,b,0);
    FORd(i,1,n+1) {
        map<vi,int> m;
        // ps(i,lev[i][0],lev[i][1]);
        F0R(j,2)
        trav(a,lev[i][j]) {
            vi v; trav(b,child[a][j]) v.pb(label[b][j]);
            sort(all(v)); m[v] = 0;
        }
        int co = 0; trav(t,m) t.s = ++co;
        F0R(j,2)
        trav(a,lev[i][j]) {
            vi v; trav(b,child[a][j]) v.pb(label[b][j]);
            sort(all(v)); label[a][j] = m[v];
        }
    }
    return label[a][0] == label[b][1];
}

void solve() {
    re(n);
    FOR(i,1,n+1) F0R(j,2) T[j].adj[i].clear();
    F0R(j,2) {
        F0R(i,n-1) {
            int a,b; re(a,b);
            T[j].addEdge(a,b);
        }
    }
    T[0].init(n), T[1].init(n);
    vi a = T[0].center, b = T[1].center;
    trav(x,a) if (x > n) {
        ps(""??"",n,a);
        exit(0);
    }
    trav(t,b) if (eq(a[0],t)) {
        ps(""YES"");
        return;
    }
    ps(""NO"");
}

int main() {
    setIO(); re(t);
    F0R(i,t) solve();
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Tree Isomorphism II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vi h, id;
vector<vi> g;
map<int, vi> lvl;

void dfs(int i, int p) {
    trav(j, g[i])  if (j!=p) {
        dfs(j, i);
        h[i]=max(h[i], h[j]+1);
    }
    lvl[h[i]].push_back(i);
}

int isomorphic() {
    int m=sz(g);
    h.assign(m, 0);
    id.assign(m, 0);
    lvl.clear();
    dfs(0, -1);
    if (h[g[0][0]]!=h[g[0][1]])
        return 0;
    trav(l, lvl) {
        map<vector<ll>, int> u;
        trav(i, l.second) {
            vector<ll> cur;
            trav(j, g[i])
            cur.push_back(1LL*m*h[j]+id[j]);
            sort(all(cur));
            if (!u.count(cur)) {
                int s=sz(u);
                u[cur]=s;
            }
            id[i]=u[cur];
        }
    }
    return id[g[0][0]]==id[g[0][1]];
}

vi getcore(int w) {
    int m=sz(g), n=m/2, r=n*w+1;
    vi d(m), q, ans;
    rep(i, r, r+n) {
        d[i]=sz(g[i]);
        if (d[i]==1)
            d[i]=-1, q.push_back(i);
    }
    rep(L, 0, sz(q)) trav(j, g[q[L]])
    if (d[j]>0 && --d[j]==1)
        d[j]=d[q[L]]-1, q.push_back(j);
    do {
        ans.push_back(q[--n]);
    } while (n && d[q[n]]==d[q[n-1]]);
    return ans;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        int m=2*n+1;
        g.assign(m, vi());
        vi core[2];
        rep(i, 0, 2) {
            rep(j, 0, n-1) {
                int a, b;
                cin >> a >> b;
                a+=i*n, b+=i*n;
                g[a].push_back(b);
                g[b].push_back(a);
            }
            core[i]=getcore(i);
        }
        int ok=0;
        if (sz(core[0])==sz(core[1])) {
            trav(r0, core[0]) trav(r1, core[1]) {
                g[0]={r0, r1};
                if ((ok=isomorphic())) goto out;
            }
        }
    out:
        cout << (ok? ""YES\n"" : ""NO\n"");
    }
    return 0;
}
"
Tree Isomorphism II,Java,"// https://cses.fi/problemset/task/1701
// Tree Isomorphism II
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1701 extends PrintWriter {
    CSES1701() { super(System.out); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1701 o = new CSES1701(); o.main(); o.flush();
    }
    
    static final int MD = 1000000007, N = 100000;
    Random rand = new Random();
    ArrayList[] aa;
    int[] xx, yy, xx_, yy_, hh;
    {
        aa = new ArrayList[N];
        xx = new int[N];
        yy = new int[N];
        xx[0] = yy[0] = 1;
        for (int h = 1; h < N - 1; h++) {
            xx[h] = rand.nextInt(MD - 2) + 2;
            yy[h] = rand.nextInt(MD - 2) + 2;
        }
        xx_ = new int[N];
        yy_ = new int[N];
        hh = new int[N];
    }
    void dfs(int p, int i) {
        ArrayList<Integer> adj = aa[i];
        int h = -1;
        for (int j : adj)
            if (j != p) {
                dfs(i, j);
                h = Math.max(h, hh[j]);
            }
        hh[i] = ++h;
        int x = xx[h], y = yy[h], x_ = 1, y_ = 1;
        for (int j : adj)
            if (j != p) {
                x_ = (int) ((long) x_ * (x + xx_[j]) % MD);
                y_ = (int) ((long) y_ * (y + yy_[j]) % MD);
            }
        xx_[i] = x_; yy_[i] = y_;
    }
    void dfs2(int p, int i, int hp, int xp, int yp) {
        ArrayList<Integer> adj = aa[i];
        int c = 0;
        for (int j : adj)
            if (j != p)
                c++;
        int[] jj = new int[c];
        c = 0;
        int h1 = -1, h2 = -1, j1 = -1;
        for (int j : adj)
            if (j != p) {
                if (h1 < hh[j]) {
                    h2 = h1; h1 = hh[j];
                    j1 = j;
                } else if (h2 < hh[j])
                    h2 = hh[j];
                jj[c++] = j;
            }
        h1 = Math.max(h1, hp) + 1;
        h2 = Math.max(h2, hp) + 1;
        int[] px = new int[c];
        int[] py = new int[c];
        int x = xx[h1], y = yy[h1], x_, y_;
        x_ = y_ = 1;
        if (hp != -1) {
            x_ = (int) ((long) x_ * (x + xp) % MD);
            y_ = (int) ((long) y_ * (y + yp) % MD);
        }
        for (int a = 0; a < c; a++) {
            px[a] = x_;
            py[a] = y_;
            int j = jj[a];
            x_ = (int) ((long) x_ * (x + xx_[j]) % MD);
            y_ = (int) ((long) y_ * (y + yy_[j]) % MD);
        }
        int xi = x_, yi = y_;
        int[] qx = new int[c];
        int[] qy = new int[c];
        x_ = y_ = 1;
        for (int a = c - 1; a >= 0; a--) {
            qx[a] = x_;
            qy[a] = y_;
            int j = jj[a];
            x_ = (int) ((long) x_ * (x + xx_[j]) % MD);
            y_ = (int) ((long) y_ * (y + yy_[j]) % MD);
        }
        if (j1 != -1) {
            x = xx[h2]; y = yy[h2];
            x_ = y_ = 1;
            if (hp != -1) {
                x_ = (int) ((long) x_ * (x + xp) % MD);
                y_ = (int) ((long) y_ * (y + yp) % MD);
            }
            for (int a = 0; a < c; a++) {
                int j = jj[a];
                if (j != j1) {
                    x_ = (int) ((long) x_ * (x + xx_[j]) % MD);
                    y_ = (int) ((long) y_ * (y + yy_[j]) % MD);
                }
            }
            dfs2(i, j1, h2, x_, y_);
        }
        for (int a = 0; a < c; a++) {
            int j = jj[a];
            if (j != j1) {
                x_ = (int) ((long) px[a] * qx[a] % MD);
                y_ = (int) ((long) py[a] * qy[a] % MD);
                dfs2(i, j, h1, x_, y_);
            }
        }
        xx_[i] = xi; yy_[i] = yi;
    }
    void main() {
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            long z = 0;
            for (int k = 0; k < 2; k++) {
                for (int i = 0; i < n; i++)
                    aa[i] = new ArrayList<Integer>();
                for (int h = 0; h < n - 1; h++) {
                    int i = sc.nextInt() - 1;
                    int j = sc.nextInt() - 1;
                    aa[i].add(j);
                    aa[j].add(i);
                }
                dfs(-1, 0);
                if (k == 0) {
                    z = (long) xx_[0] * MD + yy_[0];
                    continue;
                }
                dfs2(-1, 0, -1, -1, -1);
            }
            boolean yes = false;
            for (int i = 0; i < n; i++)
                if (z == (long) xx_[i] * MD + yy_[i]) {
                    yes = true;
                    break;
                }
            println(yes ? ""YES"" : ""NO"");
        }
    }
}
"
Tree Isomorphism II,C++,"/*
 https://cses.fi/problemset/task/1701
 Tree Isomorphism II
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    100000
#define MD    1000000007

struct L {
    struct L *next;
    int j;
} aa[N];

int xx[N], yy[N], xx_[N], yy_[N], hh[N], jj[N];

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

void init_rand() {
    struct timeval tv;
    int h;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
    xx[0] = 1;
    for (h = 1; h < N - 1; h++)
        xx[h] = rand_(MD - 2) + 2;
    yy[0] = 1;
    for (h = 1; h < N - 1; h++)
        yy[h] = rand_(MD - 2) + 2;
}

void link(int i, int j) {
    static struct L l91[N * 2 * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next, aa[i].next = l++;
}

void dfs(int p, int i) {
    struct L *l;
    int h, j, x, y, x_, y_;
    
    h = -1;
    for (l = aa[i].next; l; l = l->next)
        if ((j = l->j) != p) {
            dfs(i, j);
            if (h < hh[j])
                h = hh[j];
        }
    hh[i] = ++h;
    x = xx[h], y = yy[h], x_ = 1, y_ = 1;
    for (l = aa[i].next; l; l = l->next)
        if ((j = l->j) != p) {
            x_ = (long long) x_ * (x + xx_[j]) % MD;
            y_ = (long long) y_ * (y + yy_[j]) % MD;
        }
    xx_[i] = x_, yy_[i] = y_;
}

void dfs2(int p, int i, int hp, int xp, int yp) {
    struct L *l;
    int *px, *py, *qx, *qy, *jj, h1, h2, a, j, j1, c, x, y, x_, y_, xi, yi;
    
    c = 0;
    for (l = aa[i].next; l; l = l->next)
        if (l->j != p)
            c++;
    jj = (int *) malloc(c * sizeof *jj);
    c = 0;
    h1 = -1, h2 = -1, j1 = -1;
    for (l = aa[i].next; l; l = l->next)
        if ((j = l->j) != p) {
            if (h1 < hh[j]) {
                h2 = h1, h1 = hh[j];
                j1 = j;
            } else if (h2 < hh[j])
                h2 = hh[j];
            jj[c++] = j;
        }
    h1 = (h1 > hp ? h1 : hp) + 1;
    h2 = (h2 > hp ? h2 : hp) + 1;
    px = (int *) malloc(c * sizeof *px);
    py = (int *) malloc(c * sizeof *py);
    x = xx[h1], y = yy[h1];
    x_ = y_ = 1;
    if (hp != -1) {
        x_ = (long long) x_ * (x + xp) % MD;
        y_ = (long long) y_ * (y + yp) % MD;
    }
    for (a = 0; a < c; a++) {
        px[a] = x_;
        py[a] = y_;
        j = jj[a];
        x_ = (long long) x_ * (x + xx_[j]) % MD;
        y_ = (long long) y_ * (y + yy_[j]) % MD;
    }
    xi = x_, yi = y_;
    qx = (int *) malloc(c * sizeof *qx);
    qy = (int *) malloc(c * sizeof *qy);
    x_ = y_ = 1;
    for (a = c - 1; a >= 0; a--) {
        qx[a] = x_;
        qy[a] = y_;
        j = jj[a];
        x_ = (long long) x_ * (x + xx_[j]) % MD;
        y_ = (long long) y_ * (y + yy_[j]) % MD;
    }
    if (j1 != -1) {
        x = xx[h2], y = yy[h2];
        x_ = y_ = 1;
        if (hp != -1) {
            x_ = (long long) x_ * (x + xp) % MD;
            y_ = (long long) y_ * (y + yp) % MD;
        }
        for (a = 0; a < c; a++) {
            j = jj[a];
            if (j != j1) {
                x_ = (long long) x_ * (x + xx_[j]) % MD;
                y_ = (long long) y_ * (y + yy_[j]) % MD;
            }
        }
        dfs2(i, j1, h2, x_, y_);
    }
    for (a = 0; a < c; a++) {
        j = jj[a];
        if (j != j1) {
            x_ = (long long) px[a] * qx[a] % MD;
            y_ = (long long) py[a] * qy[a] % MD;
            dfs2(i, j, h1, x_, y_);
        }
    }
    xx_[i] = xi, yy_[i] = yi;
}

int main() {
    int t;
    
    init_rand();
    scanf(""%d"", &t);
    while (t--) {
        int n, h, i, j, k, yes;
        long long z;
        
        scanf(""%d"", &n);
        for (k = 0; k < 2; k++) {
            for (i = 0; i < n; i++)
                aa[i].next = NULL;
            for (h = 0; h < n - 1; h++) {
                scanf(""%d%d"", &i, &j), i--, j--;
                link(i, j);
                link(j, i);
            }
            dfs(-1, 0);
            if (k == 0) {
                z = (long long) xx_[0] * MD + yy_[0];
                continue;
            }
            dfs2(-1, 0, -1, -1, -1);
        }
        yes = 0;
        for (i = 0; i < n; i++)
            if (z == (long long) xx_[i] * MD + yy_[i]) {
                yes = 1;
                break;
            }
        printf(yes ? ""YES\n"" : ""NO\n"");
    }
    return 0;
}
"
Tree Traversals,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n, pos[MX], lef[MX], ri[MX];
vi A,B;

int process(int a, int b, int len) {
    if (len <= 0) return 0;
    int root = A[a]; int B = pos[root];
    lef[root] = process(a+1,b,B-b);
    ri[root] = process(a+B-b+1,B+1,b+len-1-B);
    return root;
}

vi ans;

void dfs(int x) {
    if (!x) return;
    dfs(lef[x]); dfs(ri[x]); ans.pb(x);
}

int main() {
    setIO(); re(n); A.resz(n), B.resz(n); re(A,B);
    F0R(i,sz(B)) pos[B[i]] = i;
    int r = process(0,0,n);
    dfs(r);
    trav(t,ans) pr(t,' ');
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Tree Traversals,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vi po, io, ans;

void solve(int L, int R, int l, int r) {
    if (L==R) return;
    int s=io[po[L]]-l;
    solve(L+1, L+s+1, l, l+s);
    solve(L+s+1, R, l+s+1, r);
    ans.push_back(po[L]);
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    po.resize(n+1);
    io.resize(n+1);
    rep(i, 0, n) cin >> po[i];
    rep(i, 0, n) {
        int a;
        cin >> a;
        io[a]=i;
    }
    solve(0, n, 0, n);
    rep(i, 0, n)
    cout << ans[i] << "" \n""[i==n-1];
    return 0;
}
"
Tree Traversals,Java,"// https://cses.fi/problemset/task/1702
// Tree Traversals
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1702 extends PrintWriter {
    CSES1702() { super(System.out, true); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) {
        CSES1702 c = new CSES1702(); c.main(); c.flush();
    }
    
    void main() {
        int n = sc.nextInt();
        int[] pp = new int[n + 2];
        pp[0] = n;
        for (int i = 1; i <= n; i++)
            pp[i] = sc.nextInt() - 1;
        pp[n + 1] = n + 1;
        int[] aa = new int[n + 2];
        for (int i = 0; i < n; i++)
            aa[i] = sc.nextInt() - 1;
        aa[n] = n;
        aa[n + 1] = n + 1;
        int[] ii = new int[n + 2];
        for (int i = 0; i < n + 2; i++)
            ii[aa[i]] = i;
        int[] s1 = new int[n + 2];
        int[] s2 = new int[n + 2];
        int k1 = 0, k2 = 0;
        s1[k1++] = pp[0];
        s2[k2++] = pp[0];
        for (int i = 1; i < n + 2; i++) {
            int a = pp[i], b = pp[i - 1];
            if (ii[a] > ii[b]) {
                int p = -1, q = -1;
                while (k2 > 0 && ii[a] > ii[q = s2[k2 - 1]]) {
                    p = q;
                    k2--;
                }
                while ((q = s1[k1 - 1]) != p) {
                    print(q + 1 + "" "");
                    k1--;
                }
            }
            s1[k1++] = a;
            s2[k2++] = a;
        }
        println();
    }
}
"
Tree Traversals,Java,"// https://cses.fi/problemset/task/1702
// Tree Traversals
// upsolve with rainboy
// https://cses.fi/problemset/hack/1702/entry/169043/ (Noam527)
import java.io.*;
import java.util.*;

public class CSES1702 extends PrintWriter {
    CSES1702() { super(System.out, true); }
    static class Scanner {
        Scanner(InputStream in) { this.in = in; } InputStream in;
        int k, l; byte[] bb = new byte[1 << 15];
        byte getc() {
            if (k >= l) {
                k = 0;
                try { l = in.read(bb); } catch (IOException e) { l = 0; }
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        int nextInt() {
            byte c = 0; while (c <= 32) c = getc();
            int a = 0;
            while (c > 32) { a = a * 10 + c - '0'; c = getc(); }
            return a;
        }
    }
    Scanner sc = new Scanner(System.in);
    public static void main(String[] $) { new CSES1702().main(); }
    
    int[] pp, ii;
    int cnt;
    void solve(int l, int r) {
        if (l == r)
            return;
        int a = pp[cnt++], i = ii[a];
        solve(l, i);
        solve(i + 1, r);
        print(a + 1 + "" "");
    }
    void main() {
        int n = sc.nextInt();
        pp = new int[n];
        for (int i = 0; i < n; i++)
            pp[i] = sc.nextInt() - 1;
        ii = new int[n];
        for (int i = 0; i < n; i++) {
            int a = sc.nextInt() - 1;
            ii[a] = i;
        }
        solve(0, n);
        println();
    }
}
"
Tree Traversals,C++,"/*
 https://cses.fi/problemset/task/1702
 Tree Traversals
 practice with Dukkha
 */
#include <stdio.h>

#define N    100000

int main() {
    static int pp[N + 2], aa[N + 2], ii[N + 2], s1[N + 2], s2[N + 2];
    int n, i, k1, k2;
    
    scanf(""%d"", &n);
    pp[0] = n;
    for (i = 1; i <= n; i++)
        scanf(""%d"", &pp[i]), pp[i]--;
    pp[n + 1] = n + 1;
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]), aa[i]--;
    aa[n] = n;
    aa[n + 1] = n + 1;
    for (i = 0; i < n + 2; i++)
        ii[aa[i]] = i;
    k1 = k2 = 0;
    s1[k1++] = pp[0];
    s2[k2++] = pp[0];
    for (i = 1; i < n + 2; i++) {
        int a = pp[i], b = pp[i - 1];
        
        if (ii[a] > ii[b]) {
            int p = -1, q = -1;
            
            while (k2 && ii[a] > ii[q = s2[k2 - 1]]) {
                p = q;
                k2--;
            }
            while ((q = s1[k1 - 1]) != p) {
                printf(""%d "", q + 1);
                k1--;
            }
        }
        s1[k1++] = a;
        s2[k2++] = a;
    }
    printf(""\n"");
    return 0;
}
"
Tree Traversals,C++,"/*
 https://cses.fi/problemset/task/1702
 Tree Traversals
 upsolve with Dukkha
 https://cses.fi/problemset/hack/1702/entry/169043/ (Noam527)
 */
#include <stdio.h>

#define N    100000

int pp[N], ii[N];

void solve(int l, int r) {
    static int cnt;
    int a, i;
    
    if (l == r)
        return;
    a = pp[cnt++], i = ii[a];
    solve(l, i);
    solve(i + 1, r);
    printf(""%d "", a + 1);
}

int main() {
    int n, i, a;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++)
        scanf(""%d"", &pp[i]), pp[i]--;
    for (i = 0; i < n; i++) {
        scanf(""%d"", &a), a--;
        ii[a] = i;
    }
    solve(0, n);
    printf(""\n"");
    return 0;
}
"
Visiting Cities,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
typedef pair<ll,ll> pll;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;
const int MX = 200001;
const ll INF = 1e18;

vector<pii> adj[MX], radj[MX];
ll dist[2][MX], num[MX], NUM[MX];
ll ans = INF;
int n,m;

void gendist1() {
    FOR(i,2,n+1) dist[0][i] = INF;
    priority_queue<pll,vector<pll>,greater<pll>> pq;
    pq.push({0,1});
    while (sz(pq)) {
        pll x = pq.top(); pq.pop();
        if (dist[0][x.s] != x.f) continue;
        for (auto a: adj[x.s]) if (dist[0][a.f] > x.f+a.s)
            pq.push({dist[0][a.f] = x.f+a.s,a.f});
    }
}

bool cmp(int a, int b) {
    return dist[0][a] < dist[0][b];
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m;
    F0R(i,m) {
        int a,b,c; cin >> a >> b >> c;
        adj[a].pb({b,c});
        radj[b].pb({a,c});
    }
    gendist1();
    vi x; FOR(i,1,n+1) x.pb(i);
    sort(x.rbegin(),x.rend(),cmp);
    num[n] = 1;
    for (int i: x) if (i != n) {
        for (auto j: adj[i]) if (dist[0][i]+j.s == dist[0][j.f]) {
            num[i] = (num[i]+num[j.f]) % MOD;
        }
    }
    NUM[1] = 1;
    reverse(all(x));
    for (int i: x) if (i != 1) {
        for (auto j: radj[i]) if (dist[0][i] == dist[0][j.f]+j.s) {
            NUM[i] = (NUM[i]+NUM[j.f]) % MOD;
        }
    }
    vi ans;
    FOR(i,1,n+1) if ((NUM[i]*num[i]) % MOD == num[1]) ans.pb(i);
    cout << sz(ans) << ""\n"";
    for (int i: ans) cout << i << "" "";
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Visiting Cities,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr ll inf=1e18;

void dijkstra(int s, vector<vector<pii>> &g, vector<ll> &d) {
    typedef pair<ll, ll> T;
    priority_queue<T, vector<T>, greater<T>> q;
    for (q.push({0, s}); !q.empty(); q.pop()) {
        ll cur=q.top().first;
        int i=q.top().second;
        if (d[i]<inf) continue;
        d[i]=cur;
        trav(p, g[i])
        q.push({cur+p.second, p.first});
    }
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<vector<pii>> g1(n+1), g2(n+1);
    while (m--) {
        int a, b, c;
        cin >> a >> b >> c;
        g1[a].push_back({b, c});
        g2[b].push_back({a, c});
    }
    vector<ll> d1(n+1, inf), d2(n+1, inf);
    dijkstra(1, g1, d1);
    dijkstra(n, g2, d2);
    vi o;
    rep(i, 1, n+1) if (d1[i]+d2[i]==d1[n])
        o.push_back(i);
    sort(all(o), [&](int i, int j) {
        return d1[i]<d1[j];
    });
    int np=sz(o);
    vi id(n+1, -1);
    rep(i, 0, np) id[o[i]]=i;
    vi ans;
    int k=0;
    rep(i, 0, np) {
        if (k==i) ans.push_back(o[i]);
        trav(p, g1[o[i]])
        if (d1[o[i]]+p.second+d2[p.first]==d1[n])
            k=max(k, id[p.first]);
    }
    sort(all(ans));
    cout << sz(ans) << '\n';
    rep(i, 0, sz(ans))
    cout << ans[i] << "" \n""[i==sz(ans)-1];
    return 0;
}
"
Visiting Cities,C++,"// https://cses.fi/problemset/task/1203
// Visiting Cities
// practice with rainboy
#include <iostream>
#include <vector>
#include <set>

using namespace std;

typedef pair<int, int> pii;

const int N = 100000;
const long long INF = 0x3f3f3f3f3f3f3f3fLL;

vector<pii> aa[N];
long long dd[N];
int pp[N], qq[N], cnt;
bool used[N], marked[N];

struct Compare {
    bool operator() (int i, int j) const {
        return dd[i] != dd[j] ? dd[i] < dd[j] : i < j;
    }
};

void dijkstra(int n) {
    set<int, Compare> pq;
    for (int i = 0; i < n; i++)
        dd[i] = INF;
    dd[0] = 0;
    pq.insert(0);
    while (!pq.empty()) {
        auto it = pq.begin();
        int i = *it;
        pq.erase(it);
        long long d = dd[i];
        for (auto &e : aa[i]) {
            int j = e.first;
            int c = e.second;
            if (dd[j] > d + c) {
                if (dd[j] != INF)
                    pq.erase(j);
                dd[j] = d + c;
                pp[j] = i;
                pq.insert(j);
            }
        }
    }
}

int i_;

void dfs(int i) {
    if (marked[i] && dd[i] > dd[i_])
        i_ = i;
    if (used[i])
        return;
    used[i] = true;
    long long d = dd[i];
    for (auto &e : aa[i]) {
        int j = e.first;
        int c = e.second;
        if (dd[j] == d + c)
            dfs(j);
    }
}

void solve(int n) {
    cnt = 0;
    for (int i = n - 1; i != 0; i = pp[i]) {
        marked[i] = used[i] = true;
        qq[cnt++] = i;
    }
    marked[0] = used[0] = true;
    qq[cnt++] = 0;
    while (cnt) {
        int i = qq[--cnt];
        if (i != i_)
            marked[i] = false;
        used[i] = false;
        dfs(i);
    }
    cnt = 0;
    for (int i = 0; i < n; i++)
        if (marked[i])
            qq[cnt++] = i;
}

int main() {
    int n, m;
    scanf(""%d%d"", &n, &m);
    while (m--) {
        int i, j, c;
        scanf(""%d%d%d"", &i, &j, &c);
        i--, j--;
        aa[i].push_back({ j, c });
    }
    dijkstra(n);
    solve(n);
    printf(""%d\n"", cnt);
    for (int i = 0; i < cnt; i++)
        printf(""%d "", qq[i] + 1);
    printf(""\n"");
    return 0;
}
"
Visiting Cities,C++,"/*
 https://cses.fi/problemset/task/1203
 Visiting Cities
 practice with Dukkha
 */
#include <stdio.h>

#define N    100000
#define M    200000
#define INF    0x3f3f3f3f3f3f3f3f

struct L {
    struct L *next;
    int j, c;
} aa[N];

struct V {
    int i;    /* for heap */
    int i_;
} vv[N], *pq[1 + N];

int cnt;

long long dd[N];
int pp[N], qq[N];
char used[N], marked[N];

#define LT(u, v) (dd[(u)->i_] < dd[(v)->i_])

int i2(int i) {
    return (i *= 2) > cnt ? 0 : i < cnt && LT(pq[i + 1], pq[i]) ? i + 1 : i;
}

void pq_up(struct V *u) {
    int i, j;
    
    for (i = u->i; (j = i / 2) && LT(u, pq[j]); i = j)
        pq[pq[j]->i = i] = pq[j];
    pq[u->i = i] = u;
}

void pq_dn(struct V *u) {
    int i, j;
    
    for (i = u->i; (j = i2(i)) && LT(pq[j], u); i = j)
        pq[pq[j]->i = i] = pq[j];
    pq[u->i = i] = u;
}

void pq_add(struct V *u) {
    u->i = ++cnt;
    pq_up(u);
}

struct V *pq_remove_first() {
    struct V *u = pq[1], *v = pq[cnt--];
    
    v->i = 1;
    pq_dn(v);
    return u;
}

void link(int i, int j, int c) {
    static struct L l91[M], *l = l91;
    
    l->j = j, l->c = c;
    l->next = aa[i].next; aa[i].next = l++;
}

int i_;

void dijkstra(int n) {
    int i, j, c;
    long long d;
    
    for (i = 0; i < n; i++) {
        vv[i].i_ = i;
        dd[i] = INF;
    }
    dd[0] = 0;
    pq_add(&vv[0]);
    while (cnt) {
        struct V *u = pq_remove_first();
        struct L *l;
        
        i = u->i_;
        d = dd[i];
        for (l = aa[i].next; l; l = l->next) {
            j = l->j, c = l->c;
            if (dd[j] == INF) {
                dd[j] = d + c;
                pp[j] = i;
                pq_add(&vv[j]);
            } else if (dd[j] > d + c) {
                dd[j] = d + c;
                pp[j] = i;
                pq_up(&vv[j]);
            }
        }
    }
}

void dfs(int i) {
    struct L *l;
    long long d = dd[i];
    
    if (marked[i] && dd[i] > dd[i_])
        i_ = i;
    if (used[i])
        return;
    used[i] = 1;
    for (l = aa[i].next; l; l = l->next) {
        int j = l->j, c = l->c;
        
        if (dd[j] == d + c)
            dfs(j);
    }
}

void solve(int n) {
    int i;
    
    cnt = 0;
    for (i = n - 1; i != 0; i = pp[i]) {
        marked[i] = used[i] = 1;
        qq[cnt++] = i;
    }
    marked[0] = used[0] = 1;
    qq[cnt++] = 0;
    i_ = 0;
    while (cnt) {
        i = qq[--cnt];
        if (i != i_)
            marked[i] = 0;
        used[i] = 0;
        dfs(i);
    }
    cnt = 0;
    for (i = 0; i < n; i++)
        if (marked[i])
            qq[cnt++] = i;
}

int main() {
    int n, m, i, j, c;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d%d"", &i, &j, &c), i--, j--;
        link(i, j, c);
    }
    dijkstra(n);
    solve(n);
    printf(""%d\n"", cnt);
    for (i = 0; i < cnt; i++)
        printf(""%d "", qq[i] + 1);
    printf(""\n"");
    return 0;
}
"
Writing Numbers,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

ll n, lo = 1, hi = ((ll)1e18)-1;

ll get(ll mid) {
    ll ans = 0;
    F0R(i,18) {
        ll t = pow(10,i);
        ans += (mid/(10*t))*t;
        ll z = mid % (10*t);
        if (z >= 2*t) ans += t;
        else if (z >= t) ans += z-t+1;
    }
    return ans;
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n;
    while (lo < hi) {
        ll mid = (lo+hi+1)/2;
        if (get(mid) <= n) lo = mid;
        else hi = mid-1;
    }
    cout << lo;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Writing Numbers,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    ll n;
    cin >> n;
    auto cnt=[](ll M) {
        ll ans=0, d=1;
        rep(i, 0, 18) {
            ans+=M/(10*d)*d;
            ans+=max(min(M%(10*d)-d, d), 0LL);
            d*=10;
        }
        return ans;
    };
    ll L=1, R=1e18;
    while (L<R) {
        ll M=(L+R)/2;
        if (cnt(M)<=n) L=M+1;
        else R=M;
    }
    cout << L-2 << '\n';
    return 0;
}
"
Writing Numbers,Java,"// practice with rainboy
// https://cses.fi/problemset/task/1086
// Writing Numbers
import java.io.*;

public class CSES1086 {
    static long[] p10;
    static long[] pp, dd, qq;
    static void init() {
        p10 = new long[19];
        long p = 1;
        for (int i = 0; i < 19; i++) {
            p10[i] = p;
            p *= 10;
        }
        pp = new long[19];
        dd = new long[19];
        qq = new long[19];
    }
    static int preprocess(long x) {
        long p = x, q = 0;
        int k = 0;
        while (x > 0) {
            p /= 10;
            pp[k] = p;
            qq[k] = q;
            q += (dd[k] = x % 10) * p10[k];
            k++;
            x /= 10;
        }
        return k;
    }
    static long count(int k, int b) {
        long ans = 0;
        for (int i = 0; i < k - 1 + b; i++) {
            ans += (pp[i] - 1 + b) * p10[i];
            if (dd[i] >= b)
                ans += dd[i] == b ? 1 + qq[i] : p10[i];
        }
        return ans;
    }
    public static void main(String[] args) throws IOException {
        init();
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        long n = Long.parseLong(br.readLine());
        // (x - 10^17) * 18 / 10 <= n
        long lower = 0, upper = 1000000000000000000L;
        while (upper - lower > 1) {
            long x = (lower + upper) / 2;
            int k = preprocess(x);
            if (count(k, 0) <= n && count(k, 1) <= n)
                lower = x;
            else
                upper = x;
        }
        System.out.println(lower);
    }
}
"
Writing Numbers,C++,"/*
 practice with Dukkha
 https://cses.fi/problemset/task/1086
 Writing Numbers
 */
#include <stdio.h>

long long p10[19], pp[19], qq[19], dd[19];

void init() {
    int i;
    long long p = 1;
    
    for (i = 0; i < 19; i++) {
        p10[i] = p;
        p *= 10;
    }
}

int preprocess(long long x) {
    long long p = x, q = 0, d;
    int k = 0;
    
    while (x > 0) {
        d = (dd[k] = x % 10) * p10[k];
        p /= 10;
        pp[k] = p;
        qq[k] = q;
        q += d;
        k++;
        x /= 10;
    }
    return k;
}

long long count(int k, int b) {
    int i;
    long long ans;
    
    ans = 0;
    for (i = 0; i < k - 1 + b; i++) {
        ans += (pp[i] - 1 + b) * p10[i];
        if (dd[i] >= b)
            ans += dd[i] == b ? 1 + qq[i] : p10[i];
    }
    return ans;
}

int main() {
    long long n, lower, upper;
    
    init();
    scanf(""%lld"", &n);
    /* (x - 10^17) * 18 / 10 <= n */
    lower =    0, upper = 1000000000000000000LL;
    while (upper - lower > 1) {
        long long x = (lower + upper) / 2;
        int k = preprocess(x);
        
        if (count(k, 0) <= n && count(k, 1) <= n)
            lower = x;
        else
            upper = x;
    }
    printf(""%lld\n"", lower);
    return 0;
}
"
Array Description,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,m;
vi x;
array<mi,101> dp, DP;

int main() {
    setIO(); re(n,m); x.resz(n); re(x);
    FOR(i,1,m+1) dp[i] = 1;
    F0R(i,n) {
        if (i) {
            FOR(j,1,m+1) {
                if (j > 1) DP[j-1] += dp[j];
                if (j+1 <= m) DP[j+1] += dp[j];
                DP[j] += dp[j];
            }
            swap(dp,DP); FOR(j,1,m+1) DP[j] = 0;
        }
        if (x[i]) {
            FOR(j,1,m+1) if (j != x[i]) dp[j] = 0;
        }
    }
    mi res = 0; FOR(i,1,m+1) res += dp[i];
    ps(res);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Array Description,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr ll P=1e9+7;
void add(ll &x, ll y) {
    x+=y;
    if (x>=P) x-=P;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<vector<ll>> dp(n, vector<ll>(m+2));
    ll ans=1;
    int cur=0;
    rep(i, 1, m+1) dp[cur][i]=1;
    rep(i, 0, n) {
        int a;
        cin >> a;
        if(i) {
            rep(j, 1, m+1) {
                dp[cur+1][j]=dp[cur][j];
                add(dp[cur+1][j], dp[cur][j-1]);
                add(dp[cur+1][j], dp[cur][j+1]);
            }
            cur++;
        }
        if (a) {
            ans=ans*dp[cur][a]%P;
            cur=0;
            rep(j, 1, m+1)
            dp[cur][j]=(j==a);
        }
    }
    ans=ans*accumulate(all(dp[cur]), 0LL)%P;
    cout << ans << '\n';
    return 0;
}
"
Array Description,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr ll P=1e9+7;
void add(ll &x, ll y) {
    x+=y;
    if (x>=P) x-=P;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<vector<ll>> dp(n, vector<ll>(m+2));
    ll ans=1;
    int cur=0;
    rep(i, 1, m+1) dp[cur][i]=1;
    rep(i, 0, n) {
        int a;
        cin >> a;
        if(i) {
            rep(j, 1, m+1) {
                dp[cur+1][j]=dp[cur][j];
                add(dp[cur+1][j], dp[cur][j-1]);
                add(dp[cur+1][j], dp[cur][j+1]);
            }
            cur++;
        }
        if (a) {
            ans=ans*dp[cur][a]%P;
            cur=0;
            rep(j, 1, m+1)
            dp[cur][j]=(j==a);
        }
    }
    ans=ans*accumulate(all(dp[cur]), 0LL)%P;
    cout << ans << '\n';
    return 0;
}
"
Array Description,Java,"// https://cses.fi/problemset/task/1746
// Array Description
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1746 {
    static final int MD = 1000000007;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        int[] dp = new int[m + 1];
        int[] dq = new int[m + 1];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            int x = Integer.parseInt(st.nextToken());
            if (i == 0) {
                if (x == 0)
                    Arrays.fill(dq, 1);
                else {
                    Arrays.fill(dq, 0);
                    dq[x] = 1;
                }
            } else {
                if (x == 0)
                    for (x = 1; x <= m; x++) {
                        long z = dp[x];
                        if (x > 1)
                            z += dp[x - 1];
                        if (x < m)
                            z += dp[x + 1];
                        dq[x] = (int) (z % MD);
                    }
                else {
                    Arrays.fill(dq, 0);
                    long z = dp[x];
                    if (x > 1)
                        z += dp[x - 1];
                    if (x < m)
                        z += dp[x + 1];
                    dq[x] = (int) (z % MD);
                }
            }
            int[] tmp = dp; dp = dq; dq = tmp;
        }
        long ans = 0;
        for (int x = 1; x <= m; x++)
            ans += dp[x];
        System.out.println(ans % MD);
    }
}
"
Array Description,C++,"/*
 https://cses.fi/problemset/task/1746
 Array Description
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define M    100
#define MD    1000000007

int main() {
    static int dp_[M + 2], dq_[M + 2];
    int *dp = dp_, *dq = dq_, *tmp, n, m, x;
    long long ans;
    
    scanf(""%d%d"", &n, &m);
    scanf(""%d"", &x);
    if (x == 0)
        for (x = 1; x <= m; x++)
            dp[x] = 1;
    else
        dp[x] = 1;
    while (--n) {
        scanf(""%d"", &x);
        if (x == 0)
            for (x = 1; x <= m; x++)
                dq[x] = ((long long) dp[x - 1] + dp[x] + dp[x + 1]) % MD;
        else {
            memset(dq, 0, (m + 2) * sizeof *dq);
            dq[x] = ((long long) dp[x - 1] + dp[x] + dp[x + 1]) % MD;
        }
        tmp = dp, dp = dq, dq = tmp;
    }
    ans = 0;
    for (x = 1; x <= m; x++)
        ans += dp[x];
    printf(""%lld\n"", ans % MD);
    return 0;
}
"
Book Shop,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int n,x,h[1000],s[1000], bes[100001];

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> x;
    F0R(i,n) cin >> h[i];
    F0R(i,n) cin >> s[i];
    F0R(i,n) F0Rd(j,x-h[i]+1) bes[j+h[i]] = max(bes[j+h[i]],bes[j]+s[i]);
    cout << bes[x];
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Book Shop,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, x;
    cin >> n >> x;
    vi h(n), s(n), dp(x+1);
    rep(i, 0, n) cin >> h[i];
    rep(i, 0, n) cin >> s[i];
    rep(i, 0, n) for(int j=x; j>=h[i]; j--)
        dp[j]=max(dp[j], dp[j-h[i]]+s[i]);
    cout << dp[x] << '\n';
    return 0;
}
"
Book Shop,Java,"// https://cses.fi/problemset/task/1158
// Book Shop
import java.io.*;
import java.util.*;

public class CSES1158 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int x = Integer.parseInt(st.nextToken());
        int[] dp = new int[x + 1];
        int[] hh = new int[n];
        int[] ss = new int[n];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++)
            hh[i] = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++)
            ss[i] = Integer.parseInt(st.nextToken());
        for (int i = 0; i < n; i++) {
            int h = hh[i], s = ss[i];
            for (int y = x; y >= h; y--)
                dp[y] = Math.max(dp[y], dp[y - h] + s);
        }
        System.out.println(dp[x]);
    }
}
"
Book Shop,C++,"/*
 https://cses.fi/problemset/task/1158
 Book Shop
 */
#include <stdio.h>

#define N    1000
#define X    100000

int max(int a, int b) {
    return a > b ? a : b;
}

int main() {
    static int hh[N], ss[N], dp[X + 1];
    int n, x, i, y;
    
    scanf(""%d%d"", &n, &x);
    for (i = 0; i < n; i++)
        scanf(""%d"", &hh[i]);
    for (i = 0; i < n; i++)
        scanf(""%d"", &ss[i]);
    for (i = 0; i < n; i++) {
        int h = hh[i], s = ss[i];
        
        for (y = x; y >= h; y--)
            dp[y] = max(dp[y], dp[y - h] + s);
    }
    printf(""%d\n"", dp[x]);
    return 0;
}
"
Coin Combinations I,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n, x, dp[1000001];
vi c;

int main() {
    re(n,x); c.resz(n); re(c);
    dp[0] = 1;
    FOR(i,1,x+1) trav(t,c) if (i >= t) {
        dp[i] += dp[i-t];
        if (dp[i] >= MOD) dp[i] -= MOD;
    }
    ps(dp[x]);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Coin Combinations I,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int P=1e9+7;
    int n, x;
    cin >> n >> x;
    vi c(n), dp(x+1);
    dp[0]=1;
    rep(i, 0, n) cin >> c[i];
    auto add=[&](int &x, int a) {
        x+=a;
        if (x>=P) x-=P;
    };
    rep(i, 0, x+1) trav(a, c)
    if (i>=a) add(dp[i], dp[i-a]);
    cout << dp[x] << '\n';
    return 0;
}
"
Coin Combinations I,Java,"// https://cses.fi/problemset/task/1635
// Coin Combinations I
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1635 {
    static final int MD = 1000000007;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int x = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        int[] cc = new int[n];
        for (int i = 0; i < n; i++)
            cc[i] = Integer.parseInt(st.nextToken());
        int[] dp = new int[x + 1];
        dp[0] = 1;
        for (int y = 1; y <= x; y++) {
            long c = 0;
            for (int i = 0; i < n; i++)
                if (y >= cc[i])
                    c += dp[y - cc[i]];
            dp[y] = (int) (c % MD);
        }
        System.out.println(dp[x]);
    }
}
"
Coin Combinations I,C++,"/*
 https://cses.fi/problemset/task/1635
 Coin Combinations I
 practice with Dukkha
 */
#include <stdio.h>

#define N    100
#define X    1000000
#define MD    1000000007

int main() {
    static int cc[N], dp[X + 1];
    int n, x, i, y;
    long long s;
    
    scanf(""%d%d"", &n, &x);
    for (i = 0; i < n; i++)
        scanf(""%d"", &cc[i]);
    dp[0] = 1;
    for (y = 1; y <= x; y++) {
        s = 0;
        for (i = 0; i < n; i++)
            if (y >= cc[i])
                s += dp[y - cc[i]];
        dp[y] = s % MD;
    }
    printf(""%d\n"", dp[x]);
    return 0;
}
"
Coin Combinations II,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n, x, dp[1000001];
vi c;

int main() {
    re(n,x); c.resz(n); re(c);
    dp[0] = 1;
    trav(t,c) FOR(i,1,x+1) if (i >= t) {
        dp[i] += dp[i-t];
        if (dp[i] >= MOD) dp[i] -= MOD;
    }
    ps(dp[x]);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Coin Combinations II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int P=1e9+7;
    int n, x;
    cin >> n >> x;
    vi dp(x+1);
    dp[0]=1;
    rep(i, 0, n) {
        int a;
        cin >> a;
        rep(j, a, x+1) {
            dp[j]+=dp[j-a];
            if (dp[j]>=P) dp[j]-=P;
        }
    }
    cout << dp[x] << '\n';
    return 0;
}
"
Coin Combinations II,Java,"// https://cses.fi/problemset/task/1636
// Coin Combinations II
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1636 {
    static final int MD = 1000000007;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int x = Integer.parseInt(st.nextToken());
        int[] dp = new int[x + 1];
        dp[0] = 1;
        st = new StringTokenizer(br.readLine());
        while (n-- > 0) {
            int c = Integer.parseInt(st.nextToken());
            for (int y = c; y <= x; y++)
                dp[y] = (dp[y] + dp[y - c]) % MD;
        }
        System.out.println(dp[x]);
    }
}
"
Coin Combinations II,C++,"/*
 https://cses.fi/problemset/task/1636
 Coin Combinations II
 practice with Dukkha
 */
#include <stdio.h>

#define X    1000000
#define MD    1000000007

int main() {
    static int dp[X + 1];
    int n, x;
    
    scanf(""%d%d"", &n, &x);
    dp[0] = 1;
    while (n--) {
        int c, y;
        
        scanf(""%d"", &c);
        for (y = c; y <= x; y++)
            dp[y] = (dp[y] + dp[y - c]) % MD;
    }
    printf(""%d\n"", dp[x]);
    return 0;
}
"
Dice Combinations,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n;
int dp[1000001];

int main() {
    setIO(); re(n); dp[0] = 1;
    FOR(i,1,n+1) {
        FOR(j,1,min(i,6)+1) {
            dp[i] += dp[i-j];
            dp[i] %= MOD;
        }
    }
    ps(dp[n]);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Dice Combinations,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

const ll mod = 1e9+7;

typedef vector<ll> Poly;
ll linearRec(Poly S, Poly tr, ll k) {
    int n = sz(tr);
    
    auto combine = [&](Poly a, Poly b) {
        Poly res(n * 2 + 1);
        rep(i,0,n+1) rep(j,0,n+1)
        res[i + j] = (res[i + j] + a[i] * b[j]) % mod;
        for (int i = 2 * n; i > n; --i) rep(j,0,n)
            res[i - 1 - j] = (res[i - 1 - j] + res[i] * tr[j]) % mod;
        res.resize(n + 1);
        return res;
    };
    
    Poly pol(n + 1), e(pol);
    pol[0] = e[1] = 1;
    
    for (++k; k; k /= 2) {
        if (k % 2) pol = combine(pol, e);
        e = combine(e, e);
    }
    
    ll res = 0;
    rep(i,0,n) res = (res + pol[i + 1] * S[i]) % mod;
    return res;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    ll n;
    cin >> n;
    cout << linearRec({0, 0, 0, 0, 0, 1}, {1, 1, 1, 1, 1, 1}, n+5);
    return 0;
}
"
Dice Combinations,Java,"// https://cses.fi/problemset/task/1633
// Dice Combinations
// practice with rainboy
import java.io.*;

public class CSES1633 {
    static final int MD = 1000000007;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            long x = 0;
            for (int j = i - 1; j >= i - 6 && j >= 0; j--)
                x += dp[j];
            dp[i] = (int) (x % MD);
        }
        System.out.println(dp[n]);
    }
}
"
Dice Combinations,C++,"/*
 https://cses.fi/problemset/task/1633
 Dice Combinations
 practice with Dukkha
 */
#include <stdio.h>

#define N    1000000
#define MD    1000000007

int main() {
    static int dp[N + 1];
    int n, i, j;
    long long x;
    
    scanf(""%d"", &n);
    dp[0] = 1;
    for (i = 1; i <= n; i++) {
        x = 0;
        for (j = 1; j <= 6 && j <= i; j++)
            x += dp[i - j];
        dp[i] = x % MD;
    }
    printf(""%d\n"", dp[n]);
    return 0;
}
"
Edit Distance,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

string a,b;
int n,m;
int dp[5001][5001];

int main() {
    re(a,b); n = sz(a), m = sz(b);
    F0R(i,n+1) F0R(j,m+1) {
        if (i+j != 0) dp[i][j] = MOD;
        if (i) ckmin(dp[i][j],dp[i-1][j]+1);
        if (j) ckmin(dp[i][j],dp[i][j-1]+1);
        if (i && j) ckmin(dp[i][j],dp[i-1][j-1]+(a[i-1] != b[j-1]));
    }
    ps(dp[n][m]);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Edit Distance,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    string s, t;
    cin >> s >> t;
    int n=sz(s), m=sz(t);
    vector<vi> dp(n+1, vi(m+1));
    rep(i, 0, m+1) dp[0][i]=i;
    rep(i, 1, n+1) {
        dp[i][0]=i;
        rep(j, 1, m+1) {
            dp[i][j]=1+min(dp[i-1][j], dp[i][j-1]);
            dp[i][j]=min(dp[i][j], dp[i-1][j-1]+(s[i-1]!=t[j-1]));
        }
    }
    cout << dp[n][m] << '\n';
    return 0;
}
"
Edit Distance,Java,"// https://cses.fi/problemset/task/1639
// Edit Distance
// practice with rainboy
import java.io.*;

public class CSES1639 {
    static final int INF = 0x3f3f3f3f;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        char[] aa = br.readLine().toCharArray();
        char[] bb = br.readLine().toCharArray();
        int n = aa.length;
        int m = bb.length;
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 0; i <= n; i++)
            dp[i][0] = i;
        for (int j = 0; j <= m; j++)
            dp[0][j] = j;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                dp[i][j] = aa[i - 1] == bb[j - 1] ? dp[i - 1][j - 1] :
                Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
        System.out.println(dp[n][m]);
    }
}
"
Edit Distance,C++,"/*
 https://cses.fi/problemset/task/1639
 Edit Distance
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    5000
#define M    5000

int min(int a, int b) { return a < b ? a : b; }

int main() {
    static char s[N + 1], t[M + 1];
    static int dp[N + 1][M + 1];
    int n, m, i, j;
    
    scanf(""%s%s"", s, t);
    n = strlen(s);
    m = strlen(t);
    for (i = 0; i <= n; i++)
        dp[i][0] = i;
    for (j = 0; j <= m; j++)
        dp[0][j] = j;
    for (i = 1; i <= n; i++)
        for (j = 1; j <= m; j++)
            if (s[i - 1] == t[j - 1])
                dp[i][j] = dp[i - 1][j - 1];
            else
                dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
    printf(""%d\n"", dp[n][m]);
    return 0;
}
"
Grid Paths,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

mi dp[1000][1000];
int n;
string g[1000];

int main() {
    re(n); F0R(i,n) re(g[i]);
    dp[0][0] = 1;
    F0R(i,n) F0R(j,n) {
        if (g[i][j] == '*') dp[i][j] = 0;
        if (i+1 < n) dp[i+1][j] += dp[i][j];
        if (j+1 < n) dp[i][j+1] += dp[i][j];
    }
    ps(dp[n-1][n-1]);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Grid Paths,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr int P=1e9+7;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vector<string> s(n);
    rep(i, 0, n)
    cin >> s[i];
    vector<vi> dp(n, vi(n));
    dp[0][0]=(s[0][0]=='.');
    rep(i, 0, n) rep(j, 0, n) {
        if (s[i][j]=='*') continue;
        if (i) dp[i][j]+=dp[i-1][j];
        if (dp[i][j]>=P) dp[i][j]-=P;
        if (j) dp[i][j]+=dp[i][j-1];
        if (dp[i][j]>=P) dp[i][j]-=P;
    }
    cout << dp[n-1][n-1] << '\n';
    return 0;
}
"
Grid Paths,Java,"// https://cses.fi/problemset/task/1638
// Grid Paths
// practice with rainboy
import java.io.*;

public class CSES1638 {
    static final int MD = 1000000007;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        char[][] cc = new char[n][n];
        for (int i = 0; i < n; i++)
            br.readLine().getChars(0, n, cc[i], 0);
        int[][] dp = new int[n][n];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++) {
                if (cc[i][j] == '*')
                    continue;
                if (i == 0 && j == 0)
                    dp[i][j] = 1;
                else {
                    int x = 0;
                    if (i > 0)
                        x += dp[i - 1][j];
                    if (j > 0)
                        x += dp[i][j - 1];
                    dp[i][j] = x % MD;
                }
            }
        System.out.println(dp[n - 1][n - 1]);
    }
}
"
Grid Paths,C++,"/*
 https://cses.fi/problemset/task/1638
 Grid Paths
 practice with Dukkha
 */
#include <stdio.h>

#define N    1000
#define MD    1000000007

int main() {
    static char s[N + 1];
    static int dp[N][N];
    int n, i, j;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++) {
        scanf(""%s"", s);
        for (j = 0; j < n; j++)
            if (s[j] == '.') {
                if (i == 0 && j == 0)
                    dp[i][j] = 1;
                else {
                    if (i > 0)
                        dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MD;
                    if (j > 0)
                        dp[i][j] = (dp[i][j] + dp[i][j - 1]) % MD;
                }
            }
    }
    printf(""%d\n"", dp[n - 1][n - 1]);
    return 0;
}
"
Increasing Subsequence,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

vi bes = {0};
int n;

void ad(int x) {
    int lo = 0, hi = sz(bes)-1;
    while (lo < hi) {
        int mid = (lo+hi+1)/2;
        if (bes[mid] < x) lo = mid;
        else hi = mid-1;
    }
    if (lo == sz(bes)-1) bes.pb(0);
    bes[lo+1] = x;
}

int main() {
    cin >> n;
    F0R(i,n) {
        int x; cin >> x;
        ad(x);
    }
    cout << sz(bes)-1;
}
"
Increasing Subsequence,C++,"#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 100001;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; trav(a,x) pr(!fst?"", "":"""",a), fst = 0;
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

namespace modOp {
    int ad(int a, int b, int mod = MOD) { return (a+b)%mod; }
    int sub(int a, int b, int mod = MOD) { return (a-b+mod)%mod; }
    int mul(int a, int b, int mod = MOD) { return (ll)a*b%mod; }
    
    int AD(int& a, int b, int mod = MOD) { return a = ad(a,b,mod); }
    int SUB(int& a, int b, int mod = MOD) { return a = sub(a,b,mod); }
    int MUL(int& a, int b, int mod = MOD) { return a = mul(a,b,mod); }
    
    int po (int b, int p, int mod = MOD) { return !p?1:mul(po(mul(b,b,mod),p/2,mod),p&1?b:1,mod); }
    int inv (int b, int mod = MOD) { return po(b,mod-2,mod); }
    
    int invGeneral(int a, int b) { // 0 < a < b, gcd(a,b) = 1
        if (a == 0) return b == 1 ? 0 : -1;
        int x = invGeneral(b%a,a);
        return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
    }
}

using namespace modOp;

vi bes = {INT_MIN}; // min last term of increasing sequence with i terms

void add(int x) { // add terms of sequence one by one
    int lo = lb(all(bes),x)-beg(bes);
    if (lo == sz(bes)) bes.pb(0);
    bes[lo] = x; // sz(bes)-1 is your current answer
}

int main() {
    // you should actually read the stuff at the bottom
    setIO(); int n; re(n);
    F0R(i,n) {
        int x; re(x);
        add(x);
    }
    ps(sz(bes)-1);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Increasing Subsequence,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

template<class I> vi lis(vector<I> S) {
    vi prev(sz(S));
    typedef pair<I, int> p;
    vector<p> res;
    rep(i,0,sz(S)) {
        p el { S[i], i };
        //S[i]+1 for non-decreasing
        auto it = lower_bound(all(res), p { S[i], 0 });
        if (it == res.end()) res.push_back(el), it = --res.end();
        *it = el;
        prev[i] = it==res.begin() ?0:(it-1)->second;
    }
    int L = sz(res), cur = res.back().second;
    vi ans(L);
    while (L--) ans[L] = cur, cur = prev[cur];
    return ans;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vi x(n);
    rep(i, 0, n) cin >> x[i];
    cout << sz(lis(x)) << '\n';
    return 0;
}
"
Increasing Subsequence,Java,"// https://cses.fi/problemset/task/1145
// Increasing Subsequence
import java.io.*;
import java.util.*;

public class CSES1145 {
    static int[] tt;
    static void update(int i, int n, int x) {
        while (i < n) {
            tt[i] = Math.max(tt[i], x);
            i |= i + 1;
        }
    }
    static int query(int i) {
        int ans = 0;
        while (i >= 0) {
            ans = Math.max(ans, tt[i]);
            i &= i + 1;
            i--;
        }
        return ans;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = Integer.parseInt(st.nextToken());
        Integer[] ii = new Integer[n];
        for (int i = 0; i < n; i++)
            ii[i] = i;
        Arrays.sort(ii, (i, j) -> aa[i] != aa[j] ? aa[i] - aa[j] : j - i);
        tt = new int[n];
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int cnt = query(ii[i]) + 1;
            ans = Math.max(ans, cnt);
            update(ii[i], n, cnt);
        }
        System.out.println(ans);
    }
}
"
Increasing Subsequence,C++,"/*
 https://cses.fi/problemset/task/1145
 Increasing Subsequence
 */
#include <stdio.h>
#include <stdlib.h>

#define N    200000

int aa[N], tt[N];

int compare(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return aa[i] != aa[j] ? aa[i] - aa[j] : j - i;
}

void update(int i, int n, int x) {
    while (i < n) {
        if (tt[i] < x)
            tt[i] = x;
        i |= i + 1;
    }
}

int query(int i) {
    int ans = 0;
    
    while (i >= 0) {
        if (ans < tt[i])
            ans = tt[i];
        i &= i + 1;
        i--;
    }
    return ans;
}

int main() {
    static int ii[N];
    int n, i, ans, cnt;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++) {
        scanf(""%d"", &aa[i]);
        ii[i] = i;
    }
    qsort(ii, n, sizeof *ii, compare);
    ans = 0;
    for (i = 0; i < n; i++) {
        if (ans < (cnt = query(ii[i]) + 1))
            ans = cnt;
        update(ii[i], n, cnt);
    }
    printf(""%d\n"", ans);
    return 0;
}
"
Minimizing Coins,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n, x, dp[1000001];

void ad(int a) {
    F0R(i,1000001-a) ckmin(dp[i+a],dp[i]+1);
}

int main() {
    re(n,x); FOR(i,1,1000001) dp[i] = MOD;
    F0R(i,n) {
        int c; re(c);
        ad(c);
    }
    if (dp[x] == MOD) ps(-1);
    else ps(dp[x]);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Minimizing Coins,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int inf=1e9;
    int n, x;
    cin >> n >> x;
    vi dp(x+1, inf);
    dp[0]=0;
    while (n--) {
        int a;
        cin >> a;
        rep(i, 0, x-a+1)
        dp[i+a]=min(dp[i+a], dp[i]+1);
    }
    cout << (dp[x]==inf? -1:dp[x]) << '\n';
    return 0;
}
"
Minimizing Coins,Java,"// https://cses.fi/problemset/task/1634
// Minimizing Coins
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1634 {
    static final int INF = 0x3f3f3f3f;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int x = Integer.parseInt(st.nextToken());
        int[] dp = new int[x + 1];
        Arrays.fill(dp, INF);
        dp[0] = 0;
        st = new StringTokenizer(br.readLine());
        while (n-- > 0) {
            int c = Integer.parseInt(st.nextToken());
            for (int y = c; y <= x; y++)
                dp[y] = Math.min(dp[y], dp[y - c] + 1);
        }
        System.out.println(dp[x] == INF ? -1 : dp[x]);
    }
}
"
Minimizing Coins,C++,"/*
 https://cses.fi/problemset/task/1634
 Minimizing Coins
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define X    1000000
#define INF    0x3f3f3f3f

int min(int a, int b) { return a < b ? a : b; }

int main() {
    static int dp[X + 1];
    int n, x, y, c;
    
    scanf(""%d%d"", &n, &x);
    memset(dp, 0x3f, (x + 1) * sizeof *dp);
    dp[0] = 0;
    while (n--) {
        scanf(""%d"", &c);
        for (y = c; y <= x; y++)
            dp[y] = min(dp[y], dp[y - c] + 1);
    }
    printf(""%d\n"", dp[x] == INF ? -1 : dp[x]);
    return 0;
}
"
Money Sums,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n;
bitset<100001> ok;

int main() {
    re(n); ok[0] = 1;
    F0R(i,n) {
        int x; re(x);
        ok |= ok<<x;
    }
    ok[0] = 0;
    ps(ok.count());
    F0R(i,100001) if (ok[i]) pr(i,' ');
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Money Sums,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    const int N=100*1000+1;
    bitset<N> dp(1);
    int n;
    cin >> n;
    while (n--) {
        int x;
        cin >> x;
        dp|=dp<<x;
    }
    cout << dp.count()-1 << '\n';
    int first=1;
    rep(i, 1, N+1) if (dp[i]) {
        if (!first) cout << ' ';
        first=0;
        cout << i;
    }
    cout << '\n';
    return 0;
}
"
Money Sums,Java,"// https://cses.fi/problemset/task/1745
// Money Sums
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1745 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] aa = new int[n];
        int b = 0;
        for (int i = 0; i < n; i++)
            b += aa[i] = Integer.parseInt(st.nextToken());
        boolean[] dp = new boolean[b + 1];
        dp[0] = true;
        for (int i = 1; i <= n; i++) {
            int c = aa[i - 1];
            for (int a = b; a >= c; a--)
                dp[a] = dp[a] || dp[a - c];
        }
        int[] qq = new int[b + 1];
        int cnt = 0;
        for (int a = b; a >= 1; a--)
            if (dp[a])
                qq[cnt++] = a;
        PrintWriter pw = new PrintWriter(System.out);
        pw.println(cnt);
        while (cnt-- > 0)
            pw.print(qq[cnt] + "" "");
        pw.println();
        pw.close();
    }
}
"
Money Sums,C++,"/*
 https://cses.fi/problemset/task/1745
 Money Sums
 practice with Dukkha
 */
#include <stdio.h>

#define N    100
#define X    1000
#define S    (N * X)

int main() {
    static char dp[S + 1];
    int n, x, s, k;
    
    scanf(""%d"", &n);
    dp[0] = 1;
    while (n--) {
        scanf(""%d"", &x);
        for (s = S; s >= x; s--)
            dp[s] |= dp[s - x];
    }
    k = 0;
    for (s = 1; s <= S; s++)
        if (dp[s])
            k++;
    printf(""%d\n"", k);
    for (s = 1; s <= S; s++)
        if (dp[s])
            printf(""%d "", s);
    printf(""\n"");
    return 0;
}
"
Projects,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

template<class T, int SZ> struct Seg {
    T seg[2*SZ], MN = 0;
    
    Seg() {
        memset(seg,0,sizeof seg);
    }
    
    T comb(T a, T b) { return max(a,b); } // easily change this to min or max
    
    void upd(int p, T value) {  // set value at position p
        for (seg[p += SZ] = value; p > 1; p >>= 1){
            //be careful here: some updates are noncommutative!
            if (p < (p^1)){
                seg[p>>1] = comb(seg[p],seg[p^1]);
            }
            else{
                seg[p>>1] = comb(seg[p^1], seg[p]);
            }
        }
    }
    
    void build() {
        F0Rd(i,SZ) seg[i] = comb(seg[2*i],seg[2*i+1]);
    }
    
    T query(int l, int r) {  // sum on interval [l, r]
        T res = MN; r++;
        for (l += SZ, r += SZ; l < r; l >>= 1, r >>= 1) {
            if (l&1) res = comb(res,seg[l++]);
            if (r&1) res = comb(res,seg[--r]);
        }
        return res;
    }
};

Seg<ll,1<<19> S;
int n;
vector<array<int,3>> v;
map<int,int> m;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n;
    F0R(i,n) {
        int a,b,p; cin >> a >> b >> p;
        m[a] = m[b+1] = 0;
        v.pb({a,b,p});
    }
    int nex = 0;
    for (auto& a: m) a.s = nex++;
    sort(v.rbegin(),v.rend());
    for (auto& a: v) {
        a[0] = m[a[0]];
        a[1] = m[a[1]+1];
        ll x = S.query(a[1],(1<<19)-1)+a[2];
        if (x > S.query(a[0],a[0])) S.upd(a[0],x);
    }
    cout << S.query(0,(1<<19)-1);
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Projects,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int inf=2e9;
    int n;
    cin >> n;
    vector<array<int, 3>> x(n);
    rep(i, 0, n) rep(j, 0, 3) cin >> x[i][j];
    sort(all(x));
    reverse(all(x));
    map<int, ll> dp;
    dp.insert({inf, 0});
    trav(p, x) {
        ll val=begin(dp)->second;
        dp[p[0]]=val;
        val=dp.upper_bound(p[1])->second;
        dp[p[0]]=max(dp[p[0]], val+p[2]);
    }
    cout << begin(dp)->second;
    return 0;
}
"
Projects,Java,"// practice with rainboy
// https://cses.fi/problemset/task/1140
// Projects
import java.io.*;
import java.util.*;

public class CSES1140 {
    static class V {
        int a, b;
        long p;
        V(int a, int b, long p) {
            this.a = a; this.b = b; this.p = p;
        }
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        V[] vv = new V[n];
        for (int i = 0; i < n; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            int p = sc.nextInt();
            vv[i] = new V(a, b, p);
        }
        Arrays.sort(vv, (u, v) -> u.b - v.b);
        for (int j = 0; j < n; j++) {
            int lower = -1, upper = j;
            while (upper - lower > 1) {
                int i = (lower + upper) / 2;
                if (vv[i].b < vv[j].a)
                    lower = i;
                else
                    upper = i;
            }
            if (lower != -1)
                vv[j].p += vv[lower].p;
            if (j > 0 && vv[j].p < vv[j - 1].p)
                vv[j].p = vv[j - 1].p;
        }
        System.out.println(vv[n - 1].p);
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb); //if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        String next() throws IOException {
            StringBuilder sb = new StringBuilder();
            for (byte b = skip(); b > 32; b = getc())
                sb.append((char) b);
            return sb.toString();
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Projects,Java,"// practice with rainboy
// https://cses.fi/problemset/task/1140
// Projects
import java.io.*;
import java.util.*;

public class CSES1140 {
    static class V {
        int a, b;
        long p;
        V(int a, int b, long p) {
            this.a = a; this.b = b; this.p = p;
        }
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        V[] vv = new V[n];
        for (int i = 0; i < n; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            int p = sc.nextInt();
            vv[i] = new V(a, b, p);
        }
        Arrays.sort(vv, (u, v) -> u.b - v.b);
        for (int j = 0; j < n; j++) {
            int lower = -1, upper = j;
            while (upper - lower > 1) {
                int i = (lower + upper) / 2;
                if (vv[i].b < vv[j].a)
                    lower = i;
                else
                    upper = i;
            }
            if (lower != -1)
                vv[j].p += vv[lower].p;
            if (j > 0 && vv[j].p < vv[j - 1].p)
                vv[j].p = vv[j - 1].p;
        }
        System.out.println(vv[n - 1].p);
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}

"
Projects,C++,"/*
 practice with Dukkha
 https://cses.fi/problemset/task/1140
 Projects
 */
#include <stdio.h>
#include <stdlib.h>

#define N    200000

struct V {
    int a, b;
    long long p;
} vv[N];

int compare(const void *a, const void *b) {
    struct V *u = (struct V *) a;
    struct V *v = (struct V *) b;
    
    return u->b - v->b;
}

int main() {
    int n, i, j, lower, upper;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++) {
        struct V *v = &vv[i];
        
        scanf(""%d%d%lld"", &v->a, &v->b, &v->p);
    }
    qsort(vv, n, sizeof *vv, compare);
    for (j = 0; j < n; j++) {
        lower = -1, upper = j;
        while (upper - lower > 1) {
            i = (lower + upper) / 2;
            if (vv[i].b < vv[j].a)
                lower = i;
            else
                upper = i;
        }
        if (lower != -1)
            vv[j].p += vv[lower].p;
        if (j > 0 && vv[j].p < vv[j - 1].p)
            vv[j].p = vv[j - 1].p;
    }
    printf(""%lld\n"", vv[n - 1].p);
    return 0;
}
"
Rectangle Cutting,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int a,b,dp[501][501];

int main() {
    re(a,b);
    FOR(i,1,a+1) FOR(j,1,b+1) {
        if (i == j) continue;
        dp[i][j] = MOD;
        FOR(I,1,i) ckmin(dp[i][j],dp[I][j]+dp[i-I][j]);
        FOR(J,1,j) ckmin(dp[i][j],dp[i][J]+dp[i][j-J]);
        dp[i][j] ++;
    }
    ps(dp[a][b]);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Rectangle Cutting,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int N=512;
    constexpr int inf=1e9;
    vector<vi> dp(N, vi(N));
    rep(i, 1, N) rep(j, 1, N) {
        dp[i][j]=(i==j? 0:inf);
        rep(k, 1, i)
        dp[i][j]=min(dp[i][j], 1+dp[k][j]+dp[i-k][j]);
        rep(k, 1, j)
        dp[i][j]=min(dp[i][j], 1+dp[i][k]+dp[i][j-k]);
    }
    int a, b;
    cin >> a >> b;
    cout << dp[a][b] << '\n';
    return 0;
}
"
Rectangle Cutting,Java,"// https://cses.fi/problemset/task/1744
// Rectangle Cutting
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1744 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int a = Integer.parseInt(st.nextToken());
        int b = Integer.parseInt(st.nextToken());
        int[][] dp = new int[a + 1][b + 1];
        for (int p = 1; p <= a; p++)
            for (int q = 1; q <= b; q++) {
                int x;
                if (p == q)
                    x = 0;
                else {
                    x = p * q;
                    for (int p_ = 1; p_ < p; p_++)
                        x = Math.min(x, dp[p_][q] + dp[p - p_][q] + 1);
                    for (int q_ = 1; q_ < q; q_++)
                        x = Math.min(x, dp[p][q_] + dp[p][q - q_] + 1);
                }
                dp[p][q] = x;
            }
        System.out.println(dp[a][b]);
    }
}
"
Rectangle Cutting,C++,"/*
 https://cses.fi/problemset/task/1744
 Rectangle Cutting
 practice with Dukkha
 */
#include <stdio.h>

#define A    500
#define B    500

int main() {
    static int dp[A + 1][B + 1];
    int a, b, p, q, p_, q_, x_, x;
    
    scanf(""%d%d"", &a, &b);
    for (p = 1; p <= a; p++)
        for (q = 1; q <= b; q++) {
            if (p == q) {
                dp[p][q] = 0;
                continue;
            }
            x_ = p * q;
            for (p_ = 1; p_ < p; p_++)
                if (x_ > (x = dp[p_][q] + dp[p - p_][q]))
                    x_ = x;
            for (q_ = 1; q_ < q; q_++)
                if (x_ > (x = dp[p][q_] + dp[p][q - q_]))
                    x_ = x;
            dp[p][q] = x_ + 1;
        }
    printf(""%d\n"", dp[a][b]);
    return 0;
}
"
Removal Game,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

ll dp[5001][5000], sum;
int a[5000], n;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n;
    F0R(i,n) {
        cin >> a[i];
        sum += a[i];
    }
    FOR(i,1,n+1) F0R(j,n+1-i) dp[i][j] = max(-dp[i-1][j]+a[j+i-1],-dp[i-1][j+1]+a[j]);
    cout << (sum+dp[n][0])/2;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Removal Game,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vi x(n);
    rep(i, 0, n) cin >> x[i];
    vector<vector<ll>> dp(n+1, vector<ll>(n+1));
    rep(l, 1, n+1) rep(i, 0, n+1-l)
    dp[l][i]=max(x[i]-dp[l-1][i+1], x[i+l-1]-dp[l-1][i]);
    cout << (dp[n][0]+accumulate(all(x), 0LL))/2 << '\n';
    return 0;
}
"
Removal Game,Java,"// practice with rainboy
// https://cses.fi/problemset/task/1097
// Removal Game
import java.io.*;
import java.util.*;

public class CSES1097 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        long[] aa = new long[1 + n];
        for (int i = 1; i <= n; i++)
            aa[i] = Integer.parseInt(st.nextToken());
        for (int i = 1; i <= n; i++)
            aa[i] += aa[i - 1];
        long[] dp = new long[n];
        for (int i = n - 1; i >= 0; i--) {
            dp[i] = aa[i + 1] - aa[i];
            for (int j = i + 1; j < n; j++)
                dp[j] = aa[j + 1] - aa[i] - Math.min(dp[j - 1], dp[j]);
        }
        System.out.println(dp[n - 1]);
    }
}
"
Removal Game,C++,"/*
 practice with Dukkha
 https://cses.fi/problemset/task/1097
 Removal Game
 */
#include <stdio.h>

#define N    5000

long long min(long long a, long long b) {
    return a < b ? a : b;
}

int main() {
    static long long aa[1 + N], dp[N];
    int n, i, j;
    
    scanf(""%d"", &n);
    for (i = 1; i <= n; i++)
        scanf(""%lld"", &aa[i]);
    for (i = 1; i <= n; i++)
        aa[i] += aa[i - 1];
    for (i = n - 1; i >= 0; i--) {
        dp[i] = aa[i + 1] - aa[i];
        for (j = i + 1; j < n; j++)
            dp[j] = aa[j + 1] - aa[i] - min(dp[j - 1], dp[j]);
    }
    printf(""%lld\n"", dp[n - 1]);
    return 0;
}
"
Removing Digits,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n, dp[1000001];

vi get(int x) {
    vi v;
    while (x) {
        v.pb(x%10);
        x /= 10;
    }
    return v;
}

int main() {
    FOR(i,1,1000001) {
        dp[i] = MOD;
        vi dig = get(i);
        trav(t,dig) ckmin(dp[i],dp[i-t]+1);
    }
    re(n); ps(dp[n]);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Removing Digits,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vi dp(n+1, n);
    dp[0]=0;
    rep(i, 1, n+1) {
        for(int j=i; j; j/=10)
            dp[i]=min(dp[i], dp[i-j%10]+1);
    }
    cout << dp[n] << '\n';
    return 0;
}
"
Removing Digits,Java,"// https://cses.fi/problemset/task/1637
// Removing Digits
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1637 {
    static final int INF = 0x3f3f3f3f;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int[] dp = new int[n + 1];
        Arrays.fill(dp, INF);
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            int x = INF;
            for (int j = i; j > 0; j /= 10) {
                int d = j % 10;
                if (d > 0)
                    x = Math.min(x, dp[i - d]);
            }
            dp[i] = x + 1;
        }
        System.out.println(dp[n]);
    }
}
"
Removing Digits,C++,"/*
 https://cses.fi/problemset/task/1637
 Removing Digits
 practice with Dukkha
 */
#include <stdio.h>

#define N    1000000

int main() {
    static int dp[N + 1];
    int n, i, j, d, x_, x;
    
    scanf(""%d"", &n);
    dp[0] = 0;
    for (i = 1; i <= n; i++) {
        x_ = i;
        j = i;
        while (j > 0) {
            d = j % 10;
            if (d != 0 && x_ > (x = dp[i - d]))
                x_ = x;
            j /= 10;
        }
        dp[i] = x_ + 1;
    }
    printf(""%d\n"", dp[n]);
    return 0;
}
"
Two Sets II,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

array<int,250501> a, b;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    a[125250] = 1;
    int n; cin >> n;
    FOR(i,1,n+1) {
        swap(a,b);
        F0R(j,250501) {
            a[j] = 0;
            if (j-i >= 0) a[j] += b[j-i];
            if (j+i <= 250500) a[j] += b[j+i];
            a[j] %= MOD;
        }
    }
    ll ans = a[125250];
    ans = ans*(MOD+1)/2 % MOD;
    cout << ans;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Two Sets II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int P=1e9+7;
    constexpr int P2=(P+1)/2;
    int n;
    cin >> n;
    int m=n*(n+1)/2;
    if (m%2) {
        cout << 0 <<'\n';
        return 0;
    }
    m/=2;
    vi dp(m+1);
    dp[0]=1;
    rep(i, 1, n+1) for(int j=m; j>=i; j--) {
        dp[j]+=dp[j-i];
        if (dp[j]>=P) dp[j]-=P;
    }
    cout << 1LL*dp[m]*P2%P << '\n';
    return 0;
}
"
Two Sets II,Java,"// practice with rainboy
// https://cses.fi/problemset/task/1093
// Two Sets II
import java.io.*;
import java.util.*;

public class CSES1093 {
    static final int MD = 1000000007;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        if (n % 4 == 1 || n % 4 == 2) {
            System.out.println(0);
            return;
        }
        int m = n * (n + 1) / 4;
        int[] dp = new int[1 + m];
        dp[0] = 1;
        for (int i = 1; i <= n; i++)
            for (int j = m; j >= i; j--)
                dp[j] = (dp[j] + dp[j - i]) % MD;
        System.out.println((long) dp[m] * ((MD + 1) / 2) % MD);
    }
}
"
Two Sets II,C++,"/*
 practice with Dukkha
 https://cses.fi/problemset/task/1093
 Two Sets II
 */
#include <stdio.h>

#define M    62625    /* 500 * 501 / 4 */
#define MD    1000000007

int main() {
    static int dp[1 + M];
    int n, m, i, j;
    
    scanf(""%d"", &n);
    if (n % 4 == 1 || n % 4 == 2) {
        printf(""0\n"");
        return 0;
    }
    m = n * (n + 1) / 4;
    dp[0] = 1;
    for (i = 1; i <= n; i++)
        for (j = m; j >= i; j--)
            dp[j] = (dp[j] + dp[j - i]) % MD;
    printf(""%lld\n"", (long long) dp[m] * (MD + 1) / 2 % MD);
    return 0;
}
"
Building Roads,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,m;


template<int SZ> struct DSU {
    int par[SZ], sz[SZ];
    
    DSU() {
        F0R(i,SZ) par[i] = i, sz[i] = 1;
    }
    
    int get(int x) { // path compression
        if (par[x] != x) par[x] = get(par[x]);
        return par[x];
    }
    
    bool unite(int x, int y) { // union-by-rank
        x = get(x), y = get(y);
        if (x == y) return 0;
        if (sz[x] < sz[y]) swap(x,y);
        sz[x] += sz[y], par[y] = x;
        return 1;
    }
};

DSU<MX> D;

int main() {
    setIO(); re(n,m);
    F0R(i,m) {
        int a,b; re(a,b); D.unite(a,b);
        
    }
    vi v;
    FOR(i,1,n+1) if (D.get(i) == i) v.pb(i);
    ps(sz(v)-1);
    FOR(i,1,sz(v)) ps(v[0],v[i]);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Building Roads,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vi val, comp, z, cont;
int Time, ncomps;
template<class G, class F> int dfs(int j, G& g, F& f) {
    int low = val[j] = ++Time, x; z.push_back(j);
    trav(e,g[j]) if (comp[e] < 0)
        low = min(low, val[e] ?: dfs(e,g,f));
    
    if (low == val[j]) {
        do {
            x = z.back(); z.pop_back();
            comp[x] = ncomps;
            cont.push_back(x);
        } while (x != j);
        f(cont); cont.clear();
        ncomps++;
    }
    return val[j] = low;
}
template<class G, class F> void scc(G& g, F f) {
    int n = sz(g);
    val.assign(n, 0); comp.assign(n, -1);
    Time = ncomps = 0;
    rep(i,0,n) if (comp[i] < 0) dfs(i, g, f);
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<vi> g(n);
    while (m--) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    vi r;
    scc(g, [&](vi &c) { r.push_back(c[0]); });
    cout << sz(r)-1 << '\n';
    rep(i, 1, sz(r))
    cout << r[0]+1 << "" "" << r[i]+1 << '\n';
    return 0;
}
"
Building Roads,Java,"// https://cses.fi/problemset/task/1666
// Building Roads
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1666 {
    static ArrayList[] aa;
    static int[] cc;
    static void dfs(int i, int c) {
        cc[i] = c;
        ArrayList<Integer> adj = aa[i];
        for (int j : adj)
            if (cc[j] == -1)
                dfs(j, c);
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            aa[i].add(j);
            aa[j].add(i);
        }
        cc = new int[n];
        Arrays.fill(cc, -1);
        for (int i = 0; i < n; i++)
            if (cc[i] == -1)
                dfs(i, i);
        int k = 0;
        for (int i = 0; i < n; i++)
            if (cc[i] == i)
                cc[k++] = i + 1;
        pw.println(k - 1);
        for (int i = 1; i < k; i++)
            pw.println(cc[i - 1] + "" "" + cc[i]);
        pw.close();
    }
}
"
Building Roads,Java,"// https://cses.fi/problemset/task/1666
// Building Roads
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1666 {
    static int[] dsu;
    static int find(int i) {
        return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));
    }
    static void join(int i, int j) {
        i = find(i);
        j = find(j);
        if (i == j)
            return;
        if (dsu[i] > dsu[j])
            dsu[i] = j;
        else {
            if (dsu[i] == dsu[j])
                dsu[i]--;
            dsu[j] = i;
        }
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        dsu = new int[n];
        Arrays.fill(dsu, -1);
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            join(i, j);
        }
        int k = 0;
        for (int i = 0; i < n; i++)
            if (dsu[i] < 0)
                dsu[k++] = i + 1;
        pw.println(k - 1);
        for (int i = 1; i < k; i++)
            pw.println(dsu[i - 1] + "" "" + dsu[i]);
        pw.close();
    }
}
"
Building Roads,C++,"/*
 https://cses.fi/problemset/task/1666
 Building Roads
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int j;
} aa[N];

void link(int i, int j) {
    static struct L l91[M * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

int cc[N];

void dfs(int i, int c) {
    struct L *l;
    
    cc[i] = c;
    for (l = aa[i].next; l; l = l->next)
        if (cc[l->j] == -1)
            dfs(l->j, c);
}

int main() {
    int n, m, h, i, j, k;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), link(j, i);
    }
    memset(cc, -1, n * sizeof *cc);
    k = 0;
    for (i = 0; i < n; i++)
        if (cc[i] == -1)
            dfs(i, i);
    for (i = 0; i < n; i++)
        if (cc[i] == i)
            cc[k++] = i + 1;
    printf(""%d\n"", k - 1);
    for (h = 1; h < k; h++)
        printf(""%d %d\n"", cc[h - 1], cc[h]);
    return 0;
}
"
Building Roads,C++,"/*
 https://cses.fi/problemset/task/1666
 Building Roads
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100000

int dsu[N];

int find(int i) {
    return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));
}

void join(int i, int j) {
    i = find(i);
    j = find(j);
    if (i == j)
        return;
    if (dsu[i] > dsu[j])
        dsu[i] = j;
    else {
        if (dsu[i] == dsu[j])
            dsu[i]--;
        dsu[j] = i;
    }
}

int main() {
    int n, m, h, i, j, k;
    
    scanf(""%d%d"", &n, &m);
    memset(dsu, -1, n * sizeof *dsu);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        join(i, j);
    }
    k = 0;
    for (i = 0; i < n; i++)
        if (dsu[i] < 0)
            dsu[k++] = i + 1;
    printf(""%d\n"", k - 1);
    for (h = 1; h < k; h++)
        printf(""%d %d\n"", dsu[h - 1], dsu[h]);
    return 0;
}
"
Building Teams,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,m, dist[MX], pre[MX];
vi adj[MX];

template<int SZ> struct DSU {
    int par[SZ], sz[SZ];
    
    DSU() {
        F0R(i,SZ) par[i] = i, sz[i] = 1;
    }
    
    int get(int x) { // path compression
        if (par[x] != x) par[x] = get(par[x]);
        return par[x];
    }
    
    bool unite(int x, int y) { // union-by-rank
        x = get(x), y = get(y);
        if (x == y) return 0;
        if (sz[x] < sz[y]) swap(x,y);
        sz[x] += sz[y], par[y] = x;
        return 1;
    }
};

DSU<MX> D;

int col[MX];

void dfs(int a, int b) {
    if (col[a]) {
        if (col[a] != b) {
            ps(""IMPOSSIBLE"");
            exit(0);
        }
        return;
    }
    col[a] = b; trav(t,adj[a]) dfs(t,col[a]^3);
}

int main() {
    setIO(); re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        adj[a].pb(b), adj[b].pb(a);
    }
    FOR(i,1,n+1) if (!col[i]) dfs(i,1);
    FOR(i,1,n+1) pr(col[i],' ');
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Building Teams,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vector<vi> g;
int fail;
vi p;

void dfs(int i, int cur) {
    p[i]=cur;
    trav(j, g[i]) {
        if (p[j]==p[i]) fail=1;
        if (!p[j]) dfs(j, cur^3);
    }
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    g.resize(n+1);
    while (m--) {
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    p.resize(n+1);
    rep(i, 1, n+1) if (!p[i])
        dfs(i, 1);
    if (fail)
        cout << ""IMPOSSIBLE\n"";
    else
        rep(i, 1, n+1) cout << p[i] << "" \n""[i==n];
    return 0;
}
"
Building Teams,Java,"// https://cses.fi/problemset/task/1668
// Building Teams
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1668 {
    static ArrayList[] aa;
    static int[] cc;
    static boolean dfs(int i, int c) {
        if (cc[i] != 0)
            return cc[i] == c;
        cc[i] = c;
        ArrayList<Integer> adj = aa[i];
        for (int j : adj)
            if (!dfs(j, 3 - c))
                return false;
        return true;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            aa[i].add(j);
            aa[j].add(i);
        }
        cc = new int[n];
        boolean yes = true;
        for (int i = 0; i < n; i++)
            if (cc[i] == 0 && !dfs(i, 1)) {
                yes = false;
                break;
            }
        if (yes) {
            for (int i = 0; i < n; i++)
                pw.print(cc[i] + "" "");
            pw.println();
        } else
            pw.println(""IMPOSSIBLE"");
        pw.close();
    }
}
"
Building Teams,Java,"// https://cses.fi/problemset/task/1668
// Building Teams
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1668 {
    static ArrayList[] aa;
    static int[] cc;
    static int[] stack;
    static boolean dfs(int i, int c) {
        int cnt = 0;
        cc[i] = c;
        stack[cnt++] = i;
        while (cnt > 0) {
            i = stack[--cnt];
            c = 3 - cc[i];
            ArrayList<Integer> adj = aa[i];
            for (int j : adj)
                if (cc[j] == 0) {
                    cc[j] = c;
                    stack[cnt++] = j;
                } else if (cc[j] != c)
                    return false;
        }
        return true;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            aa[i].add(j);
            aa[j].add(i);
        }
        cc = new int[n];
        stack = new int[n];
        boolean yes = true;
        for (int i = 0; i < n; i++)
            if (cc[i] == 0 && !dfs(i, 1)) {
                yes = false;
                break;
            }
        if (yes) {
            for (int i = 0; i < n; i++)
                pw.print(cc[i] + "" "");
            pw.println();
        } else
            pw.println(""IMPOSSIBLE"");
        pw.close();
    }
}
"
Building Teams,Java,"// https://cses.fi/problemset/task/1668
// Building Teams
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1668 {
    static ArrayList[] aa;
    static int[] cc;
    static int[] stack;
    static boolean dfs(int i, int c) {
        int cnt = 0;
        cc[i] = c;
        stack[cnt++] = i;
        while (cnt > 0) {
            i = stack[--cnt];
            c = 3 - cc[i];
            ArrayList<Integer> adj = aa[i];
            for (int j : adj)
                if (cc[j] == 0) {
                    cc[j] = c;
                    stack[cnt++] = j;
                } else if (cc[j] != c)
                    return false;
        }
        return true;
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        while (m-- > 0) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            aa[i].add(j);
            aa[j].add(i);
        }
        cc = new int[n];
        stack = new int[n];
        boolean yes = true;
        for (int i = 0; i < n; i++)
            if (cc[i] == 0 && !dfs(i, 1)) {
                yes = false;
                break;
            }
        PrintWriter pw = new PrintWriter(System.out);
        if (yes) {
            for (int i = 0; i < n; i++)
                pw.print(cc[i] + "" "");
            pw.println();
        } else
            pw.println(""IMPOSSIBLE"");
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb); //if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        String next() throws IOException {
            StringBuilder sb = new StringBuilder();
            for (byte b = skip(); b > 32; b = getc())
                sb.append((char) b);
            return sb.toString();
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Building Teams,Java,"// https://cses.fi/problemset/task/1668
// Building Teams
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1668 {
    static ArrayList[] aa;
    static int[] cc;
    static int[] stack;
    static boolean dfs(int i, int c) {
        int cnt = 0;
        cc[i] = c;
        stack[cnt++] = i;
        while (cnt > 0) {
            i = stack[--cnt];
            c = 3 - cc[i];
            ArrayList<Integer> adj = aa[i];
            for (int j : adj)
                if (cc[j] == 0) {
                    cc[j] = c;
                    stack[cnt++] = j;
                } else if (cc[j] != c)
                    return false;
        }
        return true;
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        while (m-- > 0) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            aa[i].add(j);
            aa[j].add(i);
        }
        cc = new int[n];
        stack = new int[n];
        boolean yes = true;
        for (int i = 0; i < n; i++)
            if (cc[i] == 0 && !dfs(i, 1)) {
                yes = false;
                break;
            }
        PrintWriter pw = new PrintWriter(System.out);
        if (yes) {
            for (int i = 0; i < n; i++)
                pw.print(cc[i] + "" "");
            pw.println();
        } else
            pw.println(""IMPOSSIBLE"");
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Building Teams,C++,"/*
 https://cses.fi/problemset/task/1668
 Building Teams
 practice with Dukkha
 */
#include <stdio.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int j;
} aa[N];

void link(int i, int j) {
    static struct L l91[M * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

int cc[N];

int dfs(int i, int c) {
    struct L *l;
    
    if (cc[i])
        return cc[i] == c;
    cc[i] = c;
    for (l = aa[i].next; l; l = l->next)
        if (!dfs(l->j, 3 - c))
            return 0;
    return 1;
}

int main() {
    int n, m, i, j;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), link(j, i);
    }
    for (i = 0; i < n; i++)
        if (!cc[i] && !dfs(i, 1)) {
            printf(""IMPOSSIBLE\n"");
            return 0;
        }
    for (i = 0; i < n; i++)
        printf(""%d "", cc[i]);
    printf(""\n"");
    return 0;
}
"
Building Teams,C++,"/*
 https://cses.fi/problemset/task/1668
 Building Teams
 practice with Dukkha
 */
#include <stdio.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int j;
} aa[N];

void link(int i, int j) {
    static struct L l91[M * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

int cc[N], stack[N];

int dfs(int i, int c) {
    struct L *l;
    int cnt;
    
    cnt = 0;
    stack[cnt++] = i;
    cc[i] = c;
    while (cnt) {
        i = stack[--cnt];
        c = 3 - cc[i];
        for (l = aa[i].next; l; l = l->next)
            if (!cc[l->j]) {
                cc[l->j] = c;
                stack[cnt++] = l->j;
            } else if (cc[l->j] != c)
                return 0;
    }
    return 1;
}

int main() {
    int n, m, i, j;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), link(j, i);
    }
    for (i = 0; i < n; i++)
        if (!cc[i] && !dfs(i, 1)) {
            printf(""IMPOSSIBLE\n"");
            return 0;
        }
    for (i = 0; i < n; i++)
        printf(""%d "", cc[i]);
    printf(""\n"");
    return 0;
}
"
Coin Collector,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

vi ADJ[MX];

template<int SZ> struct scc {
    int N, comp[SZ];
    vi adj[SZ], radj[SZ], todo, allComp;
    bitset<SZ> visit;
    
    void addEdge(int a, int b) { adj[a].pb(b), radj[b].pb(a); }
    
    void dfs(int v) {
        visit[v] = 1;
        trav(w,adj[v]) if (!visit[w]) dfs(w);
        todo.pb(v);
    }
    
    void dfs2(int v, int val) {
        comp[v] = val;
        trav(w,radj[v]) if (comp[w] == -1) dfs2(w,val);
    }
    
    void genSCC(int _N) { // fills allComp
        N = _N;
        FOR(i,1,N+1) comp[i] = -1, visit[i] = 0;
        FOR(i,1,N+1) if (!visit[i]) dfs(i);
        reverse(all(todo)); // toposort
        trav(i,todo) if (comp[i] == -1) dfs2(i,i), allComp.pb(i);
        FOR(i,1,N+1) trav(j,adj[i]) {
            int I = comp[i], J = comp[j];
            if (I != J) {
                ADJ[I].pb(J);
                // ps(i,j,I,J);
            }
        }
    }
};

scc<MX> S;

int n,m;
ll k[MX],K[MX];
ll ans[MX];

int main() {
    setIO(); re(n,m); FOR(i,1,n+1) re(k[i]);
    F0R(i,m) {
        int a,b; re(a,b); S.addEdge(a,b);
    }
    S.genSCC(n);
    FOR(i,1,n+1) K[S.comp[i]] += k[i];
    ll ret = 0;
    // ps(S.allComp);
    F0Rd(i,sz(S.allComp)) {
        int t = S.allComp[i];
        trav(u,ADJ[t]) ckmax(ans[t],ans[u]);
        ans[t] += K[t];
        ckmax(ret,ans[t]);
    }
    ps(ret);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Coin Collector,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vi val, comp, z, cont;
int Time, ncomps;
template<class G, class F> int dfs(int j, G& g, F& f) {
    int low = val[j] = ++Time, x; z.push_back(j);
    trav(e,g[j]) if (comp[e] < 0)
        low = min(low, val[e] ?: dfs(e,g,f));
    
    if (low == val[j]) {
        do {
            x = z.back(); z.pop_back();
            comp[x] = ncomps;
            cont.push_back(x);
        } while (x != j);
        f(cont); cont.clear();
        ncomps++;
    }
    return val[j] = low;
}
template<class G, class F> void scc(G& g, F f) {
    int n = sz(g);
    val.assign(n, 0); comp.assign(n, -1);
    Time = ncomps = 0;
    rep(i,0,n) if (comp[i] < 0) dfs(i, g, f);
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vi coin(n);
    rep(i, 0, n) cin >> coin[i];
    vector<vi> g(n);
    while (m--) {
        int a, b;
        cin >> a >> b;
        g[a-1].push_back(b-1);
    }
    vector<ll> dp(n);
    scc(g, [&](vi& c){
        int cur=ncomps;
        trav(i, c) trav(j, g[i])
        dp[cur]=max(dp[cur], dp[comp[j]]);
        trav(i, c) dp[cur]+=coin[i];
    });
    cout << *max_element(all(dp)) << '\n';
    return 0;
}
"
Coin Collector,Java,"// https://cses.fi/problemset/task/1686
// Coin Collector
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1686 {
    static ArrayList[] aa, bb;
    static int[] cc, qq;
    static int cnt;
    static void dfs1(int i) {
        if (cc[i] != 0)
            return;
        cc[i] = 1;
        ArrayList<Integer> adj = aa[i];
        for (int j : adj)
            dfs1(j);
        qq[cnt++] = i;
    }
    static void dfs2(int j, int c) {
        if (cc[j] != 0)
            return;
        cc[j] = c;
        ArrayList<Integer> adj = bb[j];
        for (int i : adj)
            dfs2(i, c);
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n];
        bb = new ArrayList[n];
        int[] ww = new int[n];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            aa[i] = new ArrayList<Integer>();
            bb[i] = new ArrayList<Integer>();
            ww[i] = Integer.parseInt(st.nextToken());
        }
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            aa[i].add(j);
            bb[j].add(i);
        }
        cc = new int[n];
        qq = new int[n];
        for (int i = 0; i < n; i++)
            if (cc[i] == 0)
                dfs1(i);
        Arrays.fill(cc, 0);
        int c = 0;
        for (int h = n - 1; h >= 0; h--) {
            int j = qq[h];
            if (cc[j] == 0)
                dfs2(j, ++c);
        }
        for (int i = 0; i < n; i++)
            cc[i]--;
        long[] ww_ = new long[c];
        for (int i = 0; i < n; i++)
            ww_[cc[i]] += ww[i];
        HashSet[] bb_ = new HashSet[c];
        for (int cj = 0; cj < c; cj++)
            bb_[cj] = new HashSet<Integer>();
        for (int j = 0; j < n; j++) {
            int cj = cc[j];
            ArrayList<Integer> adj = bb[j];
            for (int i : adj) {
                int ci = cc[i];
                if (ci < cj)
                    bb_[cj].add(ci);
            }
        }
        long[] dp = new long[c];
        long ans = 0;
        for (int cj = 0; cj < c; cj++) {
            long x = 0;
            HashSet<Integer> adj = bb_[cj];
            for (int ci : adj)
                x = Math.max(x, dp[ci]);
            ans = Math.max(ans, dp[cj] = x + ww_[cj]);
        }
        System.out.println(ans);
    }
}
"
Coin Collector,C++,"/*
 https://cses.fi/problemset/task/1686
 Coin Collector
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int j;
} aa[N], bb[N], bb_[N];

void link(int i, int j) {
    static struct L l91[M * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next, aa[i].next = l++;
    l->j = i;
    l->next = bb[j].next, bb[j].next = l++;
}

void link_(int i, int j) {
    static struct L l91[M], *l = l91;
    
    l->j = i;
    l->next = bb_[j].next, bb_[j].next = l++;
}

int cc[N], qq[N];

void dfs1(int i) {
    static int cnt;
    struct L *l;
    
    if (cc[i])
        return;
    cc[i] = 1;
    for (l = aa[i].next; l; l = l->next)
        dfs1(l->j);
    qq[cnt++] = i;
}

void dfs2(int j, int c) {
    struct L *l;
    
    if (cc[j])
        return;
    cc[j] = c;
    for (l = bb[j].next; l; l = l->next)
        dfs2(l->j, c);
}

int main() {
    static int ww[N];
    static long long ww_[N], dp[N];
    int n, m, h, i, j, c, ci, cj;
    long long x, ans;
    struct L *l;
    
    scanf(""%d%d"", &n, &m);
    for (i = 0; i < n; i++)
        scanf(""%d"", &ww[i]);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j);
    }
    for (i = 0; i < n; i++)
        if (!cc[i])
            dfs1(i);
    memset(cc, 0, n * sizeof *cc);
    c = 0;
    for (h = n - 1; h >= 0; h--) {
        i = qq[h];
        if (!cc[i])
            dfs2(i, ++c);
    }
    for (i = 0; i < n; i++)
        cc[i]--;
    for (i = 0; i < n; i++)
        ww_[cc[i]] += ww[i];
    for (j = 0; j < n; j++) {
        cj = cc[j];
        for (l = bb[j].next; l; l = l->next) {
            ci = cc[l->j];
            if (ci < cj)
                link_(ci, cj);
        }
    }
    ans = 0;
    for (cj = 0; cj < c; cj++) {
        x = 0;
        for (l = bb_[cj].next; l; l = l->next)
            if (x < dp[ci = l->j])
                x = dp[ci];
        if (ans < (dp[cj] = x + ww_[cj]))
            ans = dp[cj];
    }
    printf(""%lld\n"", ans);
    return 0;
}
"
Counting Rooms,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

char g[2500][2500];
int n,m;
int xdir[4] = {0,1,0,-1}, ydir[4] = {1,0,-1,0};
bool visit[2500][2500];
queue<pii> todo;

void process(pii x) {
    if (visit[x.f][x.s]) return;
    visit[x.f][x.s] = 1;
    F0R(i,4) {
        pii y = {x.f+xdir[i],x.s+ydir[i]};
        if (y.f < 0 || y.f >= n || y.s < 0 || y.s >= m || g[y.f][y.s] == '#') continue; // ignore this point if it's outside of grid
        process(y);
    }
}


int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m;
    F0R(i,n) F0R(j,m) cin >> g[i][j];
    
    int ans = 0;
    F0R(i,n) F0R(j,m) if (g[i][j] == '.' && !visit[i][j]) {
        process({i,j});
        ans ++;
    }
    cout << ans;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Counting Rooms,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int R, C;
    cin >> R >> C;
    vector<string> f(R);
    rep(r, 0, R) cin >> f[r];
    int ans=0;
    queue<pii> q;
    vi dr{0, 0, -1, 1}, dc{-1, 1, 0, 0};
    rep(r, 0, R) rep(c, 0, C) if (f[r][c]=='.') {
        ans++;
        f[r][c]='#';
        for (q.push({r, c}); !q.empty(); q.pop()) {
            int i=q.front().first;
            int j=q.front().second;
            rep(d, 0, 4) {
                int ii=i+dr[d], jj=j+dc[d];
                if (ii<0 || ii==R || jj<0 || jj==C)
                    continue;
                if (f[ii][jj]=='.')
                    f[ii][jj]='#', q.push({ii, jj});
            }
        }
    }
    cout << ans << '\n';
    return 0;
}
"
Counting Rooms,Java,"// practice with rainboy
// https://cses.fi/problemset/task/1192
// Counting Rooms
import java.io.*;
import java.util.*;

public class CSES1192 {
    static int[] dsu;
    static int find(int i) {
        return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));
    }
    static void join(int i, int j) {
        i = find(i);
        j = find(j);
        if (i == j)
            return;
        if (dsu[i] > dsu[j])
            dsu[i] = j;
        else {
            if (dsu[i] == dsu[j])
                dsu[i]--;
            dsu[j] = i;
        }
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        char[][] cc = new char[n][m];
        for (int i = 0; i < n; i++)
            br.readLine().getChars(0, m, cc[i], 0);
        dsu = new int[n * m];
        Arrays.fill(dsu, -1);
        for (int i = 0; i < n; i++)
            for (int j = 1; j < m; j++)
                if (cc[i][j - 1] == '.' && cc[i][j] == '.')
                    join(i * m + j - 1, i * m + j);
        for (int i = 1; i < n; i++)
            for (int j = 0; j < m; j++)
                if (cc[i - 1][j] == '.' && cc[i][j] == '.')
                    join((i - 1) * m + j, i * m + j);
        int cnt = 0;
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                if (cc[i][j] == '.' && dsu[i * m + j] < 0)
                    cnt++;
        System.out.println(cnt);
    }
}
"
Counting Rooms,C++,"/*
 practice with Dukkha
 https://cses.fi/problemset/task/1192
 Counting Rooms
 */
#include <stdio.h>
#include <string.h>

#define N    1000

int dsu[N * N];

int find(int i) {
    return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));
}

void join(int i, int j) {
    i = find(i);
    j = find(j);
    if (i == j)
        return;
    if (dsu[i] > dsu[j])
        dsu[i] = j;
    else {
        if (dsu[i] == dsu[j])
            dsu[i]--;
        dsu[j] = i;
    }
}

int main() {
    static char cc[N][N + 1];
    int n, m, i, j, cnt;
    
    scanf(""%d%d"", &n, &m);
    for (i = 0; i < n; i++)
        scanf(""%s"", cc[i]);
    memset(dsu, -1, sizeof dsu);
    for (i = 0; i < n; i++)
        for (j = 1; j < m; j++)
            if (cc[i][j - 1] == '.' && cc[i][j] == '.')
                join(i * m + j - 1, i * m + j);
    for (i = 1; i < n; i++)
        for (j = 0; j < m; j++)
            if (cc[i - 1][j] == '.' && cc[i][j] == '.')
                join((i - 1) * m + j, i * m + j);
    cnt = 0;
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++)
            if (cc[i][j] == '.' && dsu[i * m + j] < 0)
                cnt++;
    printf(""%d\n"", cnt);
    return 0;
}
"
Course Schedule,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<int SZ> struct TopoSort {
    int N, in[SZ];
    vi res, adj[SZ];
    
    void addEdge(int x, int y) {
        adj[x].pb(y), in[y] ++;
    }
    
    bool sort(int _N) {
        N = _N; queue<int> todo;
        FOR(i,1,N+1) if (in[i] == 0) todo.push(i);
        while (sz(todo)) {
            int x = todo.front(); todo.pop();
            res.pb(x);
            trav(i,adj[x]) {
                in[i] --;
                if (!in[i]) todo.push(i);
            }
        }
        return sz(res) == N;
    }
};

TopoSort<MX> T;
int n,m;

int main() {
    re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        T.addEdge(a,b);
    }
    if (!T.sort(n)) ps(""IMPOSSIBLE"");
    else {
        trav(t,T.res) pr(t,' ');
    }
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Course Schedule,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vi topo_sort(const vector<vi>& gr) {
    vi indeg(sz(gr)), ret;
    trav(li, gr) trav(x, li) indeg[x]++;
    queue<int> q; // use priority queue for lexic. smallest ans.
    rep(i,0,sz(gr)) if (indeg[i] == 0) q.push(-i);
    while (!q.empty()) {
        int i = -q.front(); // top() for priority queue
        ret.push_back(i);
        q.pop();
        trav(x, gr[i])
        if (--indeg[x] == 0) q.push(-x);
    }
    return ret;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<vi> g(n);
    while (m--) {
        int a, b;
        cin >> a >> b;
        g[a-1].push_back(b-1);
    }
    vi r=topo_sort(g);
    if (sz(r)<n)
        cout << ""IMPOSSIBLE\n"";
    else
        rep(i, 0, n) cout << r[i]+1 << "" \n""[i==n-1];
    return 0;
}
"
Course Schedule,Java,"// https://cses.fi/problemset/task/1679
// Course Schedule
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1679 {
    static ArrayList[] aa;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        int[] dd = new int[n];
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            aa[i].add(j);
            dd[j]++;
        }
        int[] qq = new int[n];
        int head = 0, cnt = 0;
        for (int i = 0; i < n; i++)
            if (dd[i] == 0)
                qq[head + cnt++] = i;
        while (cnt > 0) {
            int i = qq[head++]; cnt--;
            ArrayList<Integer> adj = aa[i];
            for (int j : adj)
                if (--dd[j] == 0)
                    qq[head + cnt++] = j;
        }
        if (head == n) {
            for (int i = 0; i < n; i++)
                pw.print(qq[i] + 1 + "" "");
            pw.println();
        } else
            pw.println(""IMPOSSIBLE"");
        pw.close();
    }
}
"
Course Schedule,C++,"/*
 https://cses.fi/problemset/task/1679
 Course Schedule
 practice with Dukkha
 */
#include <stdio.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int j;
} aa[N];

int dd[N];

void link(int i, int j) {
    static struct L l91[M], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

int main() {
    static int qq[N];
    int n, m, i, j, head, cnt;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), dd[j]++;
    }
    head = cnt = 0;
    for (i = 0; i < n; i++)
        if (dd[i] == 0)
            qq[head + cnt++] = i;
    while (cnt) {
        struct L *l;
        
        i = qq[cnt--, head++];
        for (l = aa[i].next; l; l = l->next)
            if (--dd[j = l->j] == 0)
                qq[head + cnt++] = j;
    }
    if (head == n)
        for (i = 0; i < n; i++)
            printf(""%d "", qq[i] + 1);
    else
        printf(""IMPOSSIBLE"");
    printf(""\n"");
    return 0;
}
"
Cycle Finding,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

const ll INF = 1e18;
const int MX = 2501;

int n,m,q,s,pre[MX];
vector<pair<pii,int>> edge;
ll dist[MX];
vi z;
bool vis[MX];

void backtrack(int x) {
    while (!vis[x]) {
        z.pb(x); vis[x] = 1;
        x = pre[x];
    }
    z.pb(x);
    reverse(all(z));
    while (z.back() != z.front()) z.pop_back();
    for (int i: z) cout << i << "" "";
}

void solve() {
    edge.clear();
    FOR(i,1,n+1) dist[i] = 0;
    F0R(i,m) {
        int u,v,w; cin >> u >> v >> w;
        if (u == v && w < 0) {
            cout << ""YES\n"";
            cout << u << "" "" << v << ""\n"";
            return;
        }
        edge.pb({{u,v},w});
    }
    FOR(i,1,n+1) for (auto a: edge)
        if (dist[a.f.f] < INF) {
            ll t = dist[a.f.f]+a.s;
            if (t < dist[a.f.s]) {
                dist[a.f.s] = t;
                pre[a.f.s] = a.f.f;
            }
        }
    
    for (auto a: edge)
        if (dist[a.f.s] > dist[a.f.f]+a.s) {
            cout << ""YES\n"";
            backtrack(a.f.s);
            return;
        }
    cout << ""NO"";
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m;
    solve();
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Cycle Finding,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

const ll inf = LLONG_MAX;
struct Ed { int a, b, w, s() { return a < b ? a : -a; }};
struct Node { ll dist = inf; int prev = -1; };

void bellmanFord(vector<Node>& nodes, vector<Ed>& eds, int s) {
    nodes[s].dist = 0;
    sort(all(eds), [](Ed a, Ed b) { return a.s() < b.s(); });
    
    int lim = sz(nodes) / 2 + 2; // /3+100 with shuffled vertices
    rep(i,0,lim) trav(ed, eds) {
        Node cur = nodes[ed.a], &dest = nodes[ed.b];
        if (abs(cur.dist) == inf) continue;
        ll d = cur.dist + ed.w;
        if (d < dest.dist) {
            dest.prev = ed.a;
            dest.dist = (i < lim-1 ? d : -inf);
        }
    }
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<Node> v(n+1);
    vector<Ed> e(m+n);
    rep(i, 0, m)
    cin >> e[i].a >> e[i].b >> e[i].w;
    rep(i, m, m+n)
    e[i].a=e[i].w=0,  e[i].b=i-m+1;
    bellmanFord(v, e, 0);
    rep(i, 1, n+1) if(v[i].dist==-inf) {
        cout << ""YES\n"";
        vi p(1), u(n+1);
        do {
            u[i]=sz(p);
            p.push_back(i);
            i=v[i].prev;
        } while(!u[i]);
        vi ans(begin(p)+u[i], end(p));
        reverse(all(ans));
        trav(i, ans) cout << i << "" "";
        cout << ans[0] << '\n';
        return 0;
    }
    cout << ""NO\n"";
    return 0;
}
"
Cycle Finding,Java,"//https://cses.fi/problemset/task/1197
//Cycle Finding
//practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1197 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        int[] aa = new int[m];
        int[] bb = new int[m];
        int[] cc = new int[m];
        for (int h = 0; h < m; h++) {
            st = new StringTokenizer(br.readLine());
            aa[h] = Integer.parseInt(st.nextToken()) - 1;
            bb[h] = Integer.parseInt(st.nextToken()) - 1;
            cc[h] = Integer.parseInt(st.nextToken());
        }
        long[] dd = new long[n];
        int[] pp = new int[n];
        boolean[] used = new boolean[n];
        for (int r = 0; r < n; r++)
            for (int h = 0; h < m; h++) {
                int a = aa[h], b = bb[h], c = cc[h];
                long d = dd[a] + c;
                if (dd[b] > d) {
                    dd[b] = d;
                    pp[b] = a;
                    if (r == n - 1) {
                        while (!used[b]) {
                            used[b] = true;
                            b = pp[b];
                        }
                        System.out.println(""YES"");
                        ArrayList<Integer> list = new ArrayList<>();
                        while (used[b]) {
                            used[b] = false;
                            list.add(b);
                            b = pp[b];
                        }
                        list.add(b);
                        StringBuilder sb = new StringBuilder();
                        for (int i = list.size() - 1; i >= 0; i--)
                            sb.append((list.get(i) + 1) + "" "");
                        System.out.println(sb);
                        return;
                    }
                }
            }
        System.out.println(""NO"");
    }
}
"
Cycle Finding,C++,"/*
 https://cses.fi/problemset/task/1197
 Cycle Finding
 practice with Dukkha
 */
#include <stdio.h>

#define N    2500
#define M    5000

int main() {
    static int aa[M], bb[M], cc[M], pp[N], ii[1 + N];
    static char used[N];
    static long long dd[N];
    int n, m, h, r, a, b, c, k;
    long long d;
    
    scanf(""%d%d"", &n, &m);
    for (h = 0; h < m; h++)
        scanf(""%d%d%d"", &aa[h], &bb[h], &cc[h]), aa[h]--, bb[h]--;
    for (r = 0; r < n; r++)
        for (h = 0; h < m; h++) {
            a = aa[h], b = bb[h], c = cc[h];
            d = dd[a] + c;
            if (dd[b] > d) {
                dd[b] = d;
                pp[b] = a;
                if (r == n - 1) {
                    while (!used[b]) {
                        used[b] = 1;
                        b = pp[b];
                    }
                    k = 0;
                    while (used[b]) {
                        used[b] = 0;
                        ii[k++] = b;
                        b = pp[b];
                    }
                    ii[k++] = b;
                    printf(""YES\n"");
                    while (k--)
                        printf(""%d "", ii[k] + 1);
                    printf(""\n"");
                    return 0;
                }
            }
        }
    printf(""NO\n"");
    return 0;
}
"
De Bruijn Sequence,C++,"/*
 ID: bqi3431
 PROG: labels
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int N,cur[(1<<20)+20];
short st[(1<<20)+20];
bitset<1<<20> done;
char s[(1<<20)+20];
int x = 0;

int main() {
    // setIO(""labels"");
    re(N); st[0] = -1;
    while (1) {
        if (st[x] == -1) {
            if (x >= N) {
                if (done[cur[x]]) {
                    x --;
                    continue;
                }
                done[cur[x]] = 1;
            }
            if (x == (1<<N)+N-1) {
                int len = (1<<N)+N-1; // ps(len);
                F0R(i,len) pr(s[i]);
                ps();
                exit(0);
            }
            s[x] = '0'; cur[x+1] = (2*cur[x])&((1<<N)-1); st[x] = 0; st[x+1] = -1;
            x ++;
        } else if (st[x] == 0) {
            s[x] = '1'; cur[x+1] = (2*cur[x]+1)&((1<<N)-1); st[x] = 1; st[x+1] = -1;
            x ++;
        } else {
            if (x >= N) done[cur[x]] = 0;
            x --;
        }
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
De Bruijn Sequence,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

struct V {
    vector<pii> outs; // (dest, edge index)
    int nins = 0;
};

vi euler_walk(vector<V>& nodes, int nedges, int src=0) {
    int c = 0;
    trav(n, nodes) c += abs(n.nins - sz(n.outs));
    if (c > 2) return {};
    vector<vector<pii>::iterator> its;
    trav(n, nodes)
    its.push_back(n.outs.begin());
    vector<bool> eu(nedges);
    vi ret, s = {src};
    while(!s.empty()) {
        int x = s.back();
        auto& it = its[x], end = nodes[x].outs.end();
        while(it != end && eu[it->second]) ++it;
        if(it == end) { ret.push_back(x); s.pop_back(); }
        else { s.push_back(it->first); eu[it->second] = true; }
    }
    if(sz(ret) != nedges+1)
        ret.clear(); // No Eulerian cycles/paths.
    // else, non-cycle if ret.front() != ret.back()
    reverse(all(ret));
    return ret;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    if (n==1) {
        cout << ""01\n"";
        return 0;
    }
    int m=1<<(n-1);
    vector<V> v(m);
    rep(i, 0, m) {
        v[i].outs={{2*i%m, 2*i}, {2*i%m+1, 2*i+1}};
        v[i].nins=2;
    }
    vi e=euler_walk(v, 2*m, 0);
    cout << string(n-2, '0');
    trav(i, e) cout << i%2;
    cout << '\n';
    return 0;
}
"
De Bruijn Sequence,Java,"// https://cses.fi/problemset/task/1692
// De Bruijn Sequence
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1692 {
    static class L {
        L next;
        int v;
        L(int v) {
            this.v = v;
        }
    }
    static int mask;
    static char[] hh;
    static void hierholzer(L e) {
        L f = e.next;
        int v = e.v;
        while (hh[v] < 2) {
            v = (v << 1 | hh[v]++) & mask;
            e = e.next = new L(v);
        }
        e.next = f;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int k = Integer.parseInt(br.readLine());
        if (k == 1) {
            System.out.println(""01"");
            return;
        }
        int n = 1 << k - 1;
        hh = new char[n];
        mask = n - 1;
        L e_ = new L(0);
        char[] aa = new char[k - 1 + (1 << k)];
        int i = 0;
        while (i < k - 2)
            aa[i++] = '0';
        for (L e = e_; e != null; e = e.next) {
            aa[i++] = (char) ('0' + (e.v & 1));
            hierholzer(e);
        }
        System.out.println(aa);
    }
}
"
De Bruijn Sequence,C++,"/*
 https://cses.fi/problemset/task/1692
 De Bruijn Sequence
 practice with Dukkha
 */
#include <stdio.h>

#define K    15
#define N    (1 << (K - 1))

struct L {
    struct L *next;
    int v;
};

struct L *new_L(int v) {
    static struct L l91[1 + N * 2], *l = l91;
    
    l->v = v;
    return l++;
}

char hh[N];
int mask;

void hierholzer(struct L *e) {
    struct L *f = e->next;
    int v = e->v;
    
    while (hh[v] < 2) {
        v = (v << 1 | hh[v]++) & mask;
        e = e->next = new_L(v);
    }
    e->next = f;
}

int main() {
    static char aa[K - 1 + (1 << K) + 1];
    struct L *e, *e_;
    int k, i;
    
    scanf(""%d"", &k);
    if (k == 1) {
        printf(""01\n"");
        return 0;
    }
    mask = (1 << (k - 1)) - 1;
    e_ = new_L(0);
    i = 0;
    while (i < k - 2)
        aa[i++] = '0';
    for (e = e_; e; e = e->next) {
        aa[i++] = '0' + (e->v & 1);
        hierholzer(e);
    }
    printf(""%s\n"", aa);
    return 0;
}
"
Distinct Routes,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

vi tmp;

template<int SZ> struct Dinic {
    struct Edge { int v, rev; ll flow, cap; };
    
    vector<Edge> adj[SZ];
    
    void addEdge(int u, int v, ll cap) {
        Edge a{v, sz(adj[v]), 0, cap}, b{u, sz(adj[u]), 0, 0};
        adj[u].pb(a), adj[v].pb(b);
    }
    
    int ST, EN, level[SZ], ind[SZ];
    
    bool bfs() { // level = shortest distance from source
        // after computing flow, edges {u,v} such that level[u] \neq -1, level[v] = -1 are part of min cut
        F0R(i,SZ) level[i] = -1, ind[i] = 0;
        level[ST] = 0;
        
        queue<int> q; q.push(ST);
        while (sz(q)) {
            int u = q.front(); q.pop();
            trav(e,adj[u]) if (level[e.v] < 0 && e.flow < e.cap) {
                level[e.v] = level[u] + 1;
                q.push(e.v);
            }
        }
        
        return level[EN] >= 0;
    }
    
    bool bfs2() {
        F0R(i,SZ) level[i] = -1, ind[i] = 0;
        level[ST] = 0;
        
        queue<int> q; q.push(ST);
        while (sz(q)) {
            int u = q.front(); q.pop();
            trav(e,adj[u]) if (level[e.v] < 0 && e.flow > 0) {
                level[e.v] = level[u] + 1;
                q.push(e.v);
            }
        }
        
        return level[EN] >= 0;
    }
    
    ll sendFlow(int s, ll flow) {
        if (s == EN) {
            return flow;
        }
        
        for (  ; ind[s] < sz(adj[s]); ind[s] ++) {
            Edge& e = adj[s][ind[s]];
            
            if (level[e.v] != level[s]+1 || e.flow == e.cap) continue;
            ll f = sendFlow(e.v, min(flow, e.cap - e.flow));
            
            if (f) { // saturate at least one edge
                e.flow += f; adj[e.v][e.rev].flow -= f;
                return f;
            }
        }
        
        return 0;
    }
    
    bool sendFlow2(int s) {
        if (s == EN) {
            tmp.pb(s);
            return 1;
        }
        for (  ; ind[s] < sz(adj[s]); ind[s] ++) {
            Edge& e = adj[s][ind[s]];
            
            if (level[e.v] != level[s]+1 || e.flow <= 0) continue;
            bool f = sendFlow2(e.v);
            
            if (f) {
                // ps(""HA"",s,e.v);
                tmp.pb(s);
                e.flow = 0;
                return 1;
            }
        }
        
        return 0;
    }
    
    ll maxFlow(int _ST, int _EN) {
        ST = _ST, EN = _EN;
        if (ST == EN) return -1;
        ll tot = 0;
        while (bfs()) while (auto flow = sendFlow(ST, LLONG_MAX)) tot += flow;
        return tot;
    }
};

Dinic<1002> D;
int n,m;

int main() {
    setIO(); re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        D.addEdge(a,b,1);
    }
    int f = D.maxFlow(1,n); ps(f);
    while (D.bfs2()) while (D.sendFlow2(1)) {
        reverse(all(tmp));
        ps(sz(tmp));
        trav(t,tmp) pr(t,' ');
        tmp.clear(); ps();
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Distinct Routes,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

template<class T> T edmondsKarp(vector<unordered_map<int, T>>& graph, int source, int sink) {
    assert(source != sink);
    T flow = 0;
    vi par(sz(graph)), q = par;
    
    for (;;) {
        fill(all(par), -1);
        par[source] = 0;
        int ptr = 1;
        q[0] = source;
        
        rep(i,0,ptr) {
            int x = q[i];
            trav(e, graph[x]) {
                if (par[e.first] == -1 && e.second > 0) {
                    par[e.first] = x;
                    q[ptr++] = e.first;
                    if (e.first == sink) goto out;
                }
            }
        }
        return flow;
    out:
        T inc = numeric_limits<T>::max();
        for (int y = sink; y != source; y = par[y])
            inc = min(inc, graph[par[y]][y]);
        
        flow += inc;
        for (int y = sink; y != source; y = par[y]) {
            int p = par[y];
            if ((graph[p][y] -= inc) <= 0) graph[p].erase(y);
            graph[y][p] += inc;
        }
    }
}

vector<unordered_map<int, int>> g, gc;
vi s;

void dfs(int i) {
    s.push_back(i);
    if (i==1) return;
    trav(p, g[i]) if (p.second>gc[i][p.first]) {
        p.second--;
        dfs(p.first);
        return;
    }
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    g.resize(n+1);
    while (m--) {
        int a, b;
        cin >> a >>b;
        g[a][b]++;
    }
    gc=g;
    int flow=edmondsKarp(g, 1, n);
    cout << flow << '\n';
    rep(f, 0, flow) {
        s.clear();
        dfs(n);
        int l=sz(s);
        cout << l << '\n';
        rep(i, 0, l) cout << s[l-1-i] << "" \n""[i==l-1];
    }
    return 0;
}
"
Distinct Routes,Java,"// https://cses.fi/problemset/task/1711
// Distinct Routes
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1711 {
    static ArrayList[] aa;
    static int[] dd, qq;
    static int[] ij, cc;
    static boolean bfs(int n, int s, int t) {
        Arrays.fill(dd, n);
        dd[s] = 0;
        int head = 0, cnt = 0;
        qq[head + cnt++] = s;
        while (cnt > 0) {
            int i = qq[head++]; cnt--;
            int d = dd[i] + 1;
            ArrayList<Integer> adj = aa[i];
            for (int h : adj)
                if (cc[h] != 0) {
                    int j = i ^ ij[h >> 1];
                    if (dd[j] == n) {
                        dd[j] = d;
                        if (j == t)
                            return true;
                        qq[head + cnt++] = j;
                    }
                }
        }
        return false;
    }
    static boolean dfs(int n, int i, int t) {
        if (i == t)
            return true;
        int d = dd[i] + 1;
        ArrayList<Integer> adj = aa[i];
        for (int h : adj)
            if (cc[h] != 0) {
                int j = i ^ ij[h >> 1];
                if (dd[j] == d && dfs(n, j, t)) {
                    cc[h]--; cc[h ^ 1]++;
                    return true;
                }
            }
        dd[i] = n;
        return false;
    }
    static int dinic(int n, int s, int t) {
        dd = new int[n];
        qq = new int[n];
        int f = 0;
        while (bfs(n, s, t))
            while (dfs(n, s, t))
                f++;
        return f;
    }
    static void link(int i, int j, int h, int c) {
        ij[h] = i ^ j;
        cc[h << 1] = c;
        aa[i].add(h << 1);
        aa[j].add(h << 1 ^ 1);
    }
    static int path(int i, int t) {
        int cnt = 0;
        while (i != t) {
            qq[cnt++] = i;
            ArrayList<Integer> adj = aa[i];
            for (int h : adj)
                if ((h & 1) == 0 && cc[h ^ 1] != 0) {
                    cc[h]++; cc[h ^ 1]--;
                    i ^= ij[h >> 1];
                    break;
                }
        }
        qq[cnt++] = t;
        return cnt;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n * 2];
        for (int i = 0; i < n * 2; i++)
            aa[i] = new ArrayList<Integer>();
        ij = new int[m + n];
        cc = new int[(m + n) * 2];
        for (int h = 0; h < m; h++) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            link(i << 1 ^ 1, j << 1, h, 1);
        }
        for (int i = 0; i < n; i++)
            link(i << 1, i << 1 ^ 1, m + i, n);
        int s = 0, t = n - 1 << 1 ^ 1;
        int k = dinic(n * 2, s, t);
        pw.println(k);
        while (k-- > 0) {
            int cnt = path(s, t);
            pw.println(cnt / 2);
            for (int i = 0; i < cnt; i += 2)
                pw.print((qq[i] >> 1) + 1 + "" "");
            pw.println();
        }
        pw.close();
    }
}
"
Distinct Routes,C++,"/*
 https://cses.fi/problemset/task/1711
 Distinct Routes
 practice with Dukkha
 */
#include <stdio.h>

#define N    500
#define M    1000

struct L {
    struct L *next;
    int h;
} aa[N * 2];

int ij[M + N], cc[(M + N) * 2], dd[N * 2];

int bfs(int n, int s, int t) {
    static int qq[N * 2];
    int head, cnt, h, i, j, d;
    
    for (i = 0; i < n; i++)
        dd[i] = n;
    dd[s] = 0;
    head = cnt = 0;
    qq[head + cnt++] = s;
    while (cnt) {
        struct L *l;
        
        i = qq[cnt--, head++];
        d = dd[i] + 1;
        for (l = aa[i].next; l; l = l->next)
            if (cc[h = l->h]) {
                j = i ^ ij[h >> 1];
                if (dd[j] == n) {
                    dd[j] = d;
                    if (j == t)
                        return 1;
                    qq[head + cnt++] = j;
                }
            }
    }
    return 0;
}

int dfs(int n, int i, int t) {
    struct L *l;
    int h, j, d;
    
    if (i == t)
        return 1;
    d = dd[i] + 1;
    for (l = aa[i].next; l; l = l->next)
        if (cc[h = l->h]) {
            j = i ^ ij[h >> 1];
            if (dd[j] == d && dfs(n, j, t)) {
                cc[h]--, cc[h ^ 1]++;
                return 1;
            }
        }
    dd[i] = n;
    return 0;
}

int dinic(int n, int s, int t) {
    int f = 0;
    
    while (bfs(n, s, t))
        while (dfs(n, s, t))
            f++;
    return f;
}

void link(int i, int j, int h, int c) {
    static struct L l91[(M + N) * 2], *l = l91;
    
    ij[h] = i ^ j;
    cc[h << 1] = c;
    l->h = h << 1;
    l->next = aa[i].next, aa[i].next = l++;
    l->h = h << 1 ^ 1;
    l->next = aa[j].next, aa[j].next = l++;
}

int qq[N];

int path(int i, int t) {
    int cnt = 0;
    
    while (i != t) {
        struct L *l;
        int h;
        
        qq[cnt++] = i;
        for (l = aa[i].next; l; l = l->next)
            if (((h = l->h) & 1) == 0 && cc[h ^ 1]) {
                cc[h]++, cc[h ^ 1]--;
                i ^= ij[h >> 1];
                break;
            }
    }
    qq[cnt++] = t;
    return cnt;
}

int main() {
    int n, m, h, i, j, k, s, t, cnt;
    
    scanf(""%d%d"", &n, &m);
    for (h = 0; h < m; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i << 1 ^ 1, j << 1, h, 1);
    }
    for (i = 0; i < n; i++)
        link(i << 1, i << 1 ^ 1, m + i, n);
    s = 0, t = (n - 1) << 1 ^ 1;
    k = dinic(n * 2, s, t);
    printf(""%d\n"", k);
    while (k--) {
        cnt = path(s, t);
        printf(""%d\n"", cnt / 2);
        for (i = 0; i < cnt; i += 2)
            printf(""%d "", (qq[i] >> 1) + 1);
        printf(""\n"");
    }
    return 0;
}
"
Download Speed,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<int SZ> struct Dinic {
    struct Edge { int v, rev; ll flow, cap; };
    
    vector<Edge> adj[SZ];
    
    void addEdge(int u, int v, ll cap) {
        Edge a{v, sz(adj[v]), 0, cap}, b{u, sz(adj[u]), 0, 0};
        adj[u].pb(a), adj[v].pb(b);
    }
    
    int ST, EN, level[SZ], ind[SZ];
    
    bool bfs() { // level = shortest distance from source
        // after computing flow, edges {u,v} such that level[u] \neq -1, level[v] = -1 are part of min cut
        F0R(i,SZ) level[i] = -1, ind[i] = 0;
        level[ST] = 0;
        
        queue<int> q; q.push(ST);
        while (sz(q)) {
            int u = q.front(); q.pop();
            trav(e,adj[u]) if (level[e.v] < 0 && e.flow < e.cap) {
                level[e.v] = level[u] + 1;
                q.push(e.v);
            }
        }
        
        return level[EN] >= 0;
    }
    
    ll sendFlow(int s, ll flow) {
        if (s == EN) return flow;
        
        for (  ; ind[s] < sz(adj[s]); ind[s] ++) {
            Edge& e = adj[s][ind[s]];
            
            if (level[e.v] != level[s]+1 || e.flow == e.cap) continue;
            ll f = sendFlow(e.v, min(flow, e.cap - e.flow));
            
            if (f) { // saturate at least one edge
                e.flow += f; adj[e.v][e.rev].flow -= f;
                return f;
            }
        }
        
        return 0;
    }
    
    ll maxFlow(int _ST, int _EN) {
        ST = _ST, EN = _EN;
        if (ST == EN) return -1;
        ll tot = 0;
        while (bfs()) while (auto flow = sendFlow(ST, LLONG_MAX)) tot += flow;
        return tot;
    }
};

Dinic<501> D;
int n,m;

int main() {
    setIO(); re(n,m);
    F0R(i,m) {
        int a,b,c; re(a,b,c);
        D.addEdge(a,b,c);
    }
    ps(D.maxFlow(1,n));
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Download Speed,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

typedef ll Flow;
struct Edge {
    int dest, back;
    Flow f, c;
};

struct PushRelabel {
    vector<vector<Edge>> g;
    vector<Flow> ec;
    vector<Edge*> cur;
    vector<vi> hs; vi H;
    PushRelabel(int n) : g(n), ec(n), cur(n), hs(2*n), H(n) {}
    
    void add_edge(int s, int t, Flow cap, Flow rcap=0) {
        if (s == t) return;
        g[s].push_back({t, sz(g[t]), 0, cap});
        g[t].push_back({s, sz(g[s])-1, 0, rcap});
    }
    
    void add_flow(Edge& e, Flow f) {
        Edge &back = g[e.dest][e.back];
        if (!ec[e.dest] && f) hs[H[e.dest]].push_back(e.dest);
        e.f += f; e.c -= f; ec[e.dest] += f;
        back.f -= f; back.c += f; ec[back.dest] -= f;
    }
    Flow maxflow(int s, int t) {
        int v = sz(g); H[s] = v; ec[t] = 1;
        vi co(2*v); co[0] = v-1;
        rep(i,0,v) cur[i] = g[i].data();
        trav(e, g[s]) add_flow(e, e.c);
        
        for (int hi = 0;;) {
            while (hs[hi].empty()) if (!hi--) return -ec[s];
            int u = hs[hi].back(); hs[hi].pop_back();
            while (ec[u] > 0)  // discharge u
                if (cur[u] == g[u].data() + sz(g[u])) {
                    H[u] = 1e9;
                    trav(e, g[u]) if (e.c && H[u] > H[e.dest]+1)
                        H[u] = H[e.dest]+1, cur[u] = &e;
                    if (++co[H[u]], !--co[hi] && hi < v)
                        rep(i,0,v) if (hi < H[i] && H[i] < v)
                            --co[H[i]], H[i] = v + 1;
                    hi = H[u];
                } else if (cur[u]->c && H[u] == H[cur[u]->dest]+1)
                    add_flow(*cur[u], min(ec[u], cur[u]->c));
                else ++cur[u];
        }
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    PushRelabel f(n+1);
    while (m--) {
        ll a, b, c;
        cin >> a >> b >> c;
        f.add_edge(a, b, c);
    }
    cout << f.maxflow(1, n);
    return 0;
}
"
Download Speed,Java,"// https://cses.fi/problemset/task/1694
// Download Speed
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1694 {
    static final int INF = 0x3f3f3f3f;
    static ArrayList[] aa;
    static int[] dd, qq;
    static int[] ii, jj, cc, ff;
    static boolean bfs(int n, int s, int t) {
        Arrays.fill(dd, n);
        dd[s] = 0;
        int head = 0, cnt = 0;
        qq[head + cnt++] = s;
        while (cnt > 0) {
            int i = qq[head++]; cnt--;
            int d = dd[i] + 1;
            ArrayList<Integer> adj = aa[i];
            for (int h : adj) {
                int j = i ^ ii[h] ^ jj[h];
                if (dd[j] == n && (i == ii[h] && ff[h] < cc[h] || i == jj[h] && ff[h] > 0)) {
                    dd[j] = d;
                    if (j == t)
                        return true;
                    qq[head + cnt++] = j;
                }
            }
        }
        return false;
    }
    static int dfs(int n, int i, int t, int c) {
        if (i == t || c == 0)
            return c;
        int d = dd[i] + 1;
        ArrayList<Integer> adj = aa[i];
        for (int h : adj) {
            int j = i ^ ii[h] ^ jj[h];
            if (dd[j] == d) {
                int c_ = i == ii[h] ? cc[h] - ff[h] : ff[h];
                int f = dfs(n, j, t, Math.min(c, c_));
                if (f != 0) {
                    ff[h] += i == ii[h] ? f : -f;
                    return f;
                }
            }
        }
        dd[i] = n;
        return 0;
    }
    static long dinic(int n, int s, int t) {
        dd = new int[n];
        qq = new int[n];
        long sum = 0;
        while (bfs(n, s, t)) {
            int f;
            while ((f = dfs(n, s, t, INF)) != 0)
                sum += f;
        }
        return sum;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        ii = new int[m];
        jj = new int[m];
        cc = new int[m];
        ff = new int[m];
        for (int h = 0; h < m; h++) {
            st = new StringTokenizer(br.readLine());
            ii[h] = Integer.parseInt(st.nextToken()) - 1;
            jj[h] = Integer.parseInt(st.nextToken()) - 1;
            cc[h] = Integer.parseInt(st.nextToken());
            aa[ii[h]].add(h);
            aa[jj[h]].add(h);
        }
        System.out.println(dinic(n, 0, n - 1));
    }
}
"
Download Speed,Java,"// https://cses.fi/problemset/task/1694
// Download Speed
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1694 {
    static final int INF = 0x3f3f3f3f;
    static ArrayList[] aa;
    static int[] dd, qq;
    static int[] ij, cc;
    static boolean bfs(int n, int s, int t) {
        Arrays.fill(dd, n);
        dd[s] = 0;
        int head = 0, cnt = 0;
        qq[head + cnt++] = s;
        while (cnt > 0) {
            int i = qq[head++]; cnt--;
            int d = dd[i] + 1;
            ArrayList<Integer> adj = aa[i];
            for (int h : adj)
                if (cc[h] > 0) {
                    int j = i ^ ij[h >> 1];
                    if (dd[j] == n) {
                        dd[j] = d;
                        if (j == t)
                            return true;
                        qq[head + cnt++] = j;
                    }
                }
        }
        return false;
    }
    static int dfs(int n, int i, int t, int c) {
        if (i == t || c == 0)
            return c;
        int d = dd[i] + 1;
        ArrayList<Integer> adj = aa[i];
        for (int h : adj)
            if (cc[h] > 0) {
                int j = i ^ ij[h >> 1];
                if (dd[j] == d) {
                    int f = dfs(n, j, t, Math.min(c, cc[h]));
                    if (f != 0) {
                        cc[h] -= f;
                        cc[h ^ 1] += f;
                        return f;
                    }
                }
            }
        dd[i] = n;
        return 0;
    }
    static long dinic(int n, int s, int t) {
        dd = new int[n];
        qq = new int[n];
        long sum = 0;
        while (bfs(n, s, t)) {
            int f;
            while ((f = dfs(n, s, t, INF)) != 0)
                sum += f;
        }
        return sum;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        ij = new int[m];
        cc = new int[m * 2];
        for (int h = 0; h < m; h++) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            int c = Integer.parseInt(st.nextToken());
            cc[h * 2] = c;
            ij[h] = i ^ j;
            aa[i].add(h * 2);
            aa[j].add(h * 2 + 1);
        }
        System.out.println(dinic(n, 0, n - 1));
    }
}
"
Download Speed,C++,"/*
 https://cses.fi/problemset/task/1694
 Download Speed
 practice with Dukkha
 */
#include <stdio.h>

#define N    500
#define M    1000
#define INF    0x3f3f3f3f

struct L {
    struct L *next;
    int h;
} aa[N];

int ii[M], jj[M], cc[M], ff[M], dd[N];

void link(int i, int h) {
    static struct L l91[M * 2], *l = l91;
    
    l->h = h;
    l->next = aa[i].next, aa[i].next = l++;
}

int bfs(int n, int s, int t) {
    static int qq[N];
    int i, head, cnt, d;
    
    for (i = 0; i < n; i++)
        dd[i] = n;
    head = cnt = 0;
    dd[s] = 0;
    qq[head + cnt++] = s;
    while (cnt) {
        struct L *l;
        
        i = qq[cnt--, head++];
        d = dd[i] + 1;
        for (l = aa[i].next; l; l = l->next) {
            int h = l->h, j = i ^ ii[h] ^ jj[h];
            
            if (dd[j] == n && ((i == ii[h] && ff[h] < cc[h]) || (i == jj[h] && ff[h]))) {
                dd[j] = d;
                if (j == t)
                    return 1;
                qq[head + cnt++] = j;
            }
        }
    }
    return 0;
}

int dfs(int n, int i, int t, int c) {
    struct L *l;
    int d;
    
    if (i == t || c == 0)
        return c;
    d = dd[i] + 1;
    for (l = aa[i].next; l; l = l->next) {
        int h = l->h, j = i ^ ii[h] ^ jj[h];
        
        if (dd[j] == d) {
            int c_ = i == ii[h] ? cc[h] - ff[h] : ff[h];
            int f = dfs(n, j, t, c < c_ ? c : c_);
            
            if (f) {
                ff[h] += i == ii[h] ? f : -f;
                return f;
            }
        }
    }
    dd[i] = n;
    return 0;
}

long long dinic(int n, int s, int t) {
    long long sum = 0;
    
    while (bfs(n, s, t)) {
        int f;
        
        while ((f = dfs(n, s, t, INF)))
            sum += f;
    }
    return sum;
}

int main() {
    int n, m, h, i, j, c;
    
    scanf(""%d%d"", &n, &m);
    for (h = 0; h < m; h++) {
        scanf(""%d%d%d"", &i, &j, &c), i--, j--;
        ii[h] = i, jj[h] = j;
        cc[h] = c;
        link(i, h), link(j, h);
    }
    printf(""%lld\n"", dinic(n, 0, n - 1));
    return 0;
}
"
Download Speed,C++,"/*
 https://cses.fi/problemset/task/1694
 Download Speed
 practice with Dukkha
 */
#include <stdio.h>

#define N    500
#define M    1000
#define INF    0x3f3f3f3f

struct L {
    struct L *next;
    int h;
} aa[N];

int ij[M], cc[M * 2], dd[N];

void link(int i, int h) {
    static struct L l91[M * 2], *l = l91;
    
    l->h = h;
    l->next = aa[i].next, aa[i].next = l++;
}

int bfs(int n, int s, int t) {
    static int qq[N];
    int h, i, j, head, cnt, d;
    
    for (i = 0; i < n; i++)
        dd[i] = n;
    head = cnt = 0;
    dd[s] = 0;
    qq[head + cnt++] = s;
    while (cnt) {
        struct L *l;
        
        i = qq[cnt--, head++];
        d = dd[i] + 1;
        for (l = aa[i].next; l; l = l->next) {
            h = l->h;
            if (cc[h]) {
                j = i ^ ij[h >> 1];
                if (dd[j] == n) {
                    dd[j] = d;
                    if (j == t)
                        return 1;
                    qq[head + cnt++] = j;
                }
            }
        }
    }
    return 0;
}

int dfs(int n, int i, int t, int c) {
    struct L *l;
    int h, j, d, f;
    
    if (i == t || c == 0)
        return c;
    d = dd[i] + 1;
    for (l = aa[i].next; l; l = l->next) {
        h = l->h;
        if (cc[h]) {
            j = i ^ ij[h >> 1];
            if (dd[j] == d) {
                f = dfs(n, j, t, c < cc[h] ? c : cc[h]);
                if (f) {
                    cc[h] -= f, cc[h ^ 1] += f;
                    return f;
                }
            }
        }
    }
    dd[i] = n;
    return 0;
}

long long dinic(int n, int s, int t) {
    long long sum = 0;
    
    while (bfs(n, s, t)) {
        int f;
        
        while ((f = dfs(n, s, t, INF)))
            sum += f;
    }
    return sum;
}

int main() {
    int n, m, h, i, j, c;
    
    scanf(""%d%d"", &n, &m);
    for (h = 0; h < m; h++) {
        scanf(""%d%d%d"", &i, &j, &c), i--, j--;
        cc[h * 2 + 0] = c;
        ij[h] = i ^ j;
        link(i, h * 2 + 0), link(j, h * 2 + 1);
    }
    printf(""%lld\n"", dinic(n, 0, n - 1));
    return 0;
}
"
Flight Discount,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
typedef pair<ll,ll> pll;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;
const int MX = 200001;
const ll INF = 1e18;

vector<pii> adj[MX], radj[MX];
ll dist[2][MX];
ll ans = INF;
int n,m;

void gendist1() {
    FOR(i,2,n+1) dist[0][i] = INF;
    priority_queue<pll,vector<pll>,greater<pll>> pq;
    pq.push({0,1});
    while (sz(pq)) {
        pll x = pq.top(); pq.pop();
        if (dist[0][x.s] != x.f) continue;
        for (auto a: adj[x.s]) if (dist[0][a.f] > x.f+a.s)
            pq.push({dist[0][a.f] = x.f+a.s,a.f});
    }
}

void gendist2() {
    FOR(i,1,n) dist[1][i] = INF;
    priority_queue<pll,vector<pll>,greater<pll>> pq;
    pq.push({0,n});
    while (sz(pq)) {
        pll x = pq.top(); pq.pop();
        if (dist[1][x.s] != x.f) continue;
        for (auto a: radj[x.s]) if (dist[1][a.f] > x.f+a.s)
            pq.push({dist[1][a.f] = x.f+a.s,a.f});
    }
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m;
    F0R(i,m) {
        int a,b,c; cin >> a >> b >> c;
        adj[a].pb({b,c}), radj[b].pb({a,c});
    }
    gendist1();
    gendist2();
    FOR(i,1,n+1) if (dist[0][i] != INF)
        for (auto a: adj[i]) if (dist[1][a.f] != INF)
            ans = min(ans,dist[0][i]+dist[1][a.f]+a.s/2);
    cout << ans;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Flight Discount,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr ll inf=1e18;
void dijkstra(vector<vector<pii>> g, int s, vector<ll> &d) {
    typedef pair<ll, int> T;
    priority_queue<T, vector<T>, greater<T>> q;
    for(q.push({0, s}); !q.empty(); q.pop()) {
        ll curd=q.top().first;
        int i=q.top().second;
        if (d[i]!=inf) continue;
        d[i]=curd;
        trav(p, g[i]) q.push({curd+p.second, p.first});
    }
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<vector<pii>> g1(n+1), g2(n+1);
    while (m--) {
        int a, b, c;
        cin >> a >> b >> c;
        g1[a].push_back({b, c});
        g2[b].push_back({a, c});
    }
    vector<ll> d1(n+1, inf), d2(n+1, inf);
    dijkstra(g1, 1, d1);
    dijkstra(g2, n, d2);
    ll ans=inf;
    rep(i, 1, n+1) trav(p, g1[i])
    ans=min(ans, d1[i]+p.second/2+d2[p.first]);
    cout << ans << '\n';
    return 0;
}
"
Flight Discount,Java,"// https://cses.fi/problemset/task/1195
// Flight Discount
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1195 {
    static final long INF = Long.MAX_VALUE;
    static class E {
        int j, c;
        E(int j, int c) {
            this.j = j; this.c = c;
        }
    }
    static class V {
        ArrayList<E> adj = new ArrayList<>();
        int i;
        long c = INF;
        V(int i) {
            this.i = i;
        }
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        V[] vv = new V[n * 2];
        for (int i = 0; i < n * 2; i++)
            vv[i] = new V(i);
        for (int h = 0; h < m; h++) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            int c = sc.nextInt();
            vv[i * 2 + 0].adj.add(new E(j * 2 + 0, c));
            vv[i * 2 + 1].adj.add(new E(j * 2 + 1, c));
            vv[i * 2 + 0].adj.add(new E(j * 2 + 1, c / 2));
        }
        TreeSet<V> pq = new TreeSet<>((u, v) -> u.c == v.c ? u.i - v.i : u.c < v.c ? -1 : 1);
        vv[0].c = vv[1].c = 0;
        pq.add(vv[0]);
        pq.add(vv[1]);
        V u;
        while ((u = pq.pollFirst()) != null) {
            if (u == vv[n * 2 - 1]) {
                System.out.println(u.c);
                return;
            }
            for (E e : u.adj) {
                V v = vv[e.j];
                long c = u.c + e.c;
                if (v.c == INF) {
                    v.c = c;
                    pq.add(v);
                } else if (v.c > c) {
                    pq.remove(v);
                    v.c = c;
                    pq.add(v);
                }
            }
        }
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Flight Discount,C++,"/*
 https://cses.fi/problemset/task/1195
 Flight Discount
 practice with Dukkha
 */
#include <stdio.h>

#define N    100000
#define M    200000
#define INF    0x3f3f3f3f3f3f3f3f

struct L {
    struct L *next;
    struct E *e;
};

struct E {
    int j, c;
};

struct V {
    int i;    /* for heap */
    struct L adj;
    long long c;
} vv[N * 2], *pq[1 + N * 2];

int cnt;

#define LT(u, v) ((u)->c < (v)->c)

int i2(int i) {
    return (i *= 2) > cnt ? 0 : i < cnt && LT(pq[i + 1], pq[i]) ? i + 1 : i;
}

void pq_up(struct V *u) {
    int i, j;
    
    for (i = u->i; (j = i / 2) && LT(u, pq[j]); i = j)
        pq[pq[j]->i = i] = pq[j];
    pq[u->i = i] = u;
}

void pq_dn(struct V *u) {
    int i, j;
    
    for (i = u->i; (j = i2(i)) && LT(pq[j], u); i = j)
        pq[pq[j]->i = i] = pq[j];
    pq[u->i = i] = u;
}

void pq_add(struct V *u) {
    u->i = ++cnt;
    pq_up(u);
}

struct V *pq_remove_first() {
    struct V *u = pq[1], *v = pq[cnt--];
    
    v->i = 1;
    pq_dn(v);
    return u;
}

void link(int i, int j, int c) {
    static struct E e91[M * 3], *e = e91;
    static struct L l91[M * 3], *l = l91;
    
    e->j = j, e->c = c;
    l->e = e++;
    l->next = vv[i].adj.next; vv[i].adj.next = l++;
}

int main() {
    int n, m, i, j, c;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d%d"", &i, &j, &c), i--, j--;
        link(i * 2 + 0, j * 2 + 0, c);
        link(i * 2 + 0, j * 2 + 1, c / 2);
        link(i * 2 + 1, j * 2 + 1, c);
    }
    for (i = 2; i < n * 2; i++)
        vv[i].c = INF;
    pq_add(&vv[0]);
    pq_add(&vv[1]);
    while (cnt) {
        struct V *u = pq_remove_first();
        struct L *l;
        
        if (u == &vv[n * 2 - 1]) {
            printf(""%lld\n"", u->c);
            return 0;
        }
        for (l = u->adj.next; l; l = l->next) {
            struct E *e = l->e;
            struct V *v = &vv[e->j];
            long long c = u->c + e->c;
            
            if (v->c == INF) {
                v->c = c;
                pq_add(v);
            } else if (v->c > c) {
                v->c = c;
                pq_up(v);
            }
        }
    }
    return 0;
}
"
Flight Routes,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;
const int MX = 200001;

int n,m,k;
priority_queue<pair<ll,int>> bes[MX];
vector<pii> adj[MX];
priority_queue<pair<pair<ll,int>,int>,vector<pair<pair<ll,int>,int>>,greater<pair<pair<ll,int>,int>>> pq;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m >> k;
    F0R(i,m) {
        int a,b,c; cin >> a >> b >> c;
        adj[a].pb({b,c});
    }
    pair<ll,int> x = {0,rand()};
    bes[1].push(x);
    pq.push({x,1});
    
    while (sz(pq)) {
        auto a = pq.top(); pq.pop();
        if (a.f > bes[a.s].top()) continue;
        for (auto i: adj[a.s]) {
            pair<ll,int> tmp = mp(a.f.f+i.s,rand());
            if (sz(bes[i.f]) < k || tmp < bes[i.f].top()) {
                bes[i.f].push(tmp);
                pq.push({tmp,i.f});
                if (sz(bes[i.f]) > k) bes[i.f].pop();
            }
        }
    }
    
    vector<ll> ans;
    F0R(i,k) {
        ans.pb(bes[n].top().f);
        bes[n].pop();
    }
    reverse(all(ans));
    for (auto a: ans) cout << a << "" "";
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Flight Routes,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;
const int MX = 200001;

int n,m,k;
priority_queue<ll> bes[MX];
vector<pii> adj[MX];
priority_queue<pair<ll,int>,vector<pair<ll,int>>,greater<pair<ll,int>>> pq;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m >> k;
    F0R(i,m) {
        int a,b,c; cin >> a >> b >> c;
        adj[a].pb({b,c});
    }
    
    bes[1].push(0);
    pq.push({0,1});
    
    while (sz(pq)) {
        auto a = pq.top(); pq.pop();
        if (a.f > bes[a.s].top()) continue;
        for (auto i: adj[a.s]) {
            ll tmp = a.f+i.s;
            if (sz(bes[i.f]) < k || tmp < bes[i.f].top()) {
                bes[i.f].push(tmp);
                pq.push({tmp,i.f});
                if (sz(bes[i.f]) > k) bes[i.f].pop();
            }
        }
    }
    
    vector<ll> ans;
    F0R(i,k) {
        ans.pb(bes[n].top());
        bes[n].pop();
    }
    reverse(all(ans));
    for (auto a: ans) cout << a << "" "";
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Flight Routes,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;
const int MX = 200001;

int n,m,k;
priority_queue<ll> bes[MX];
vector<pii> adj[MX];
priority_queue<pair<ll,int>,vector<pair<ll,int>>,greater<pair<ll,int>>> pq;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m >> k;
    F0R(i,m) {
        int a,b,c; cin >> a >> b >> c;
        adj[a].pb({b,c});
    }
    
    bes[1].push(0);
    pq.push({0,1});
    
    while (sz(pq)) {
        auto a = pq.top(); pq.pop();
        if (sz(bes[n]) == k && bes[n].top() <= a.f) break;
        if (a.f > bes[a.s].top()) continue;
        for (auto& i: adj[a.s]) {
            ll tmp = a.f+i.s;
            if (sz(bes[i.f]) < k) {
                bes[i.f].push(tmp);
                pq.push({tmp,i.f});
            } else if (tmp < bes[i.f].top()) {
                bes[i.f].pop();
                bes[i.f].push(tmp);
                pq.push({tmp,i.f});
            }
        }
    }
    
    vector<ll> ans;
    while (sz(bes[n])) {
        ans.pb(bes[n].top());
        bes[n].pop();
    }
    reverse(all(ans));
    for (auto a: ans) cout << a << "" "";
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Flight Routes,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m, k;
    cin >> n >> m >> k;
    vector<vector<pii>> g(n+1);
    while (m--) {
        int a, b, c;
        cin >> a >> b >> c;
        g[a].push_back({b, c});
    }
    vi cnt(n+1);
    typedef pair<ll, int> T;
    priority_queue<T, vector<T>, greater<T>> q;
    for(q.push({0, 1}); !q.empty(); q.pop()) {
        ll d=q.top().first;
        int i=q.top().second;
        if (cnt[i]==k) continue;
        cnt[i]++;
        if (i==n) {
            cout << d << "" \n""[cnt[n]==k];
            if (cnt[n]==k) return 0;
        }
        trav(p, g[i]) q.push({d+p.second, p.first});
    }
    return 0;
}
"
Flight Routes,C++,"// https://cses.fi/problemset/task/1196
// Flight Routes
// practice with rainboy
#include <iostream>
#include <vector>
#include <set>

using namespace std;

const int N = 100000, K = 10;
const long long INF = 0x3f3f3f3f3f3f3f3fLL;

typedef pair<int, int> pii;

vector<pii> aa[N];
long long dd[N][K];

struct Compare {
    bool operator()(const pii &p, const pii &q) const {
        int pi = p.first, ph = p.second;
        int qi = q.first, qh = q.second;
        long long pd = dd[pi][ph], qd = dd[qi][qh];
        if (pd != qd) return pd < qd;
        return pi != qi ? pi < qi : ph < qh;
    }
};

int main() {
    int n, m, k;
    scanf(""%d%d%d"", &n, &m, &k);
    while (m--) {
        int i, j, c;
        scanf(""%d%d%d"", &i, &j, &c);
        i--, j--;
        aa[i].push_back({ j, c });
    }
    for (int i = 0; i < n; i++)
        for (int h = 0; h < k; h++)
            dd[i][h] = INF;
    set<pii, Compare> pq;
    dd[0][0] = 0;
    pq.insert({ 0, 0 });
    while (!pq.empty()) {
        auto it = pq.begin();
        int i = it->first, h = it->second;
        pq.erase(it);
        long long d = dd[i][h];
        for (auto &e : aa[i]) {
            int i_ = e.first, c = e.second;
            for (int h_ = 0; h_ < k; h_++)
                if (dd[i_][h_] > d + c) {
                    long long d1 = d + c;
                    while (h_ < k && d1 != INF) {
                        long long d2 = dd[i_][h_];
                        if (d2 != INF)
                            pq.erase({ i_, h_ });
                        dd[i_][h_] = d1;
                        pq.insert({ i_, h_ });
                        d1 = d2;
                        h_++;
                    }
                    break;
                }
        }
    }
    for (int h = 0; h < k; h++)
        printf(""%lld "", dd[n - 1][h]);
    printf(""\n"");
    return 0;
}
"
Flight Routes,C++,"/*
 https://cses.fi/problemset/task/1196
 Flight Routes
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100000
#define M    200000
#define K    10
#define INF    0x3f3f3f3f3f3f3f3fLL

struct L {
    struct L *next;
    int j, c;
} aa[N];

struct V {
    int i;    /* for heap */
    int i_, h_;
} vv[N][K], *pq[1 + N * K];

long long dd[N][K];

int cnt;

#define LT(u, v) (dd[(u)->i_][(u)->h_] < dd[(v)->i_][(v)->h_])

int i2(int i) {
    return (i *= 2) > cnt ? 0 : i < cnt && LT(pq[i + 1], pq[i]) ? i + 1 : i;
}

void pq_up(struct V *u) {
    int i, j;
    
    for (i = u->i; (j = i / 2) && LT(u, pq[j]); i = j)
        pq[pq[j]->i = i] = pq[j];
    pq[u->i = i] = u;
}

void pq_dn(struct V *u) {
    int i, j;
    
    for (i = u->i; (j = i2(i)) && LT(pq[j], u); i = j)
        pq[pq[j]->i = i] = pq[j];
    pq[u->i = i] = u;
}

void pq_add(struct V *u) {
    u->i = ++cnt;
    pq_up(u);
}

struct V *pq_remove_first() {
    struct V *u = pq[1], *v = pq[cnt--];
    
    v->i = 1;
    pq_dn(v);
    return u;
}

void link(int i, int j, int c) {
    static struct L l91[M], *l = l91;
    
    l->j = j, l->c = c;
    l->next = aa[i].next; aa[i].next = l++;
}

int main() {
    int n, m, k, h, h_, i, i_, j, c;
    long long d;
    
    scanf(""%d%d%d"", &n, &m, &k);
    while (m--) {
        scanf(""%d%d%d"", &i, &j, &c), i--, j--;
        link(i, j, c);
    }
    for (i = 0; i < n; i++)
        for (h = 0; h < k; h++) {
            struct V *u = &vv[i][h];
            
            u->i_ = i, u->h_ = h;
        }
    memset(dd, 0x3f, sizeof dd);
    dd[0][0] = 0;
    pq_add(&vv[0][0]);
    while (cnt) {
        struct V *u = pq_remove_first();
        struct L *l;
        
        i = u->i_, h = u->h_;
        d = dd[i][h];
        for (l = aa[i].next; l; l = l->next) {
            i_ = l->j, c = l->c;
            for (h_ = 0; h_ < k; h_++)
                if (dd[i_][h_] > d + c) {
                    long long d1 = d + c;
                    
                    while (h_ < k && d1 != INF) {
                        long long d2 = dd[i_][h_];
                        
                        dd[i_][h_] = d1;
                        if (d2 == INF)
                            pq_add(&vv[i_][h_]);
                        else
                            pq_up(&vv[i_][h_]);
                        d1 = d2;
                        h_++;
                    }
                    break;
                }
        }
    }
    for (h = 0; h < k; h++)
        printf(""%lld "", dd[n - 1][h]);
    printf(""\n"");
    return 0;
}
"
Flight Routes Check,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<int SZ> struct scc {
    int N, comp[SZ];
    vi adj[SZ], radj[SZ], todo, allComp;
    bitset<SZ> visit;
    
    void addEdge(int a, int b) { adj[a].pb(b), radj[b].pb(a); }
    
    void dfs(int v) {
        visit[v] = 1;
        trav(w,adj[v]) if (!visit[w]) dfs(w);
        todo.pb(v);
    }
    
    void dfs2(int v, int val) {
        comp[v] = val;
        trav(w,radj[v]) if (comp[w] == -1) dfs2(w,val);
    }
    
    void genSCC(int _N) { // fills allComp
        N = _N;
        FOR(i,1,N+1) comp[i] = -1, visit[i] = 0;
        FOR(i,1,N+1) if (!visit[i]) dfs(i);
        reverse(all(todo)); // toposort
        trav(i,todo) if (comp[i] == -1) dfs2(i,i), allComp.pb(i);
    }
};

scc<MX> S;

int n,m,co, z[MX];

int main() {
    setIO(); re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        S.addEdge(a,b);
    }
    S.genSCC(n);
    // ps(S.allComp);
    if (sz(S.allComp) > 1) {
        ps(""NO"");
        ps(S.allComp[1],S.allComp[0]);
    } else {
        ps(""YES"");
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Flight Routes Check,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vi val, comp, z, cont;
int Time, ncomps;
template<class G, class F> int dfs(int j, G& g, F& f) {
    int low = val[j] = ++Time, x; z.push_back(j);
    trav(e,g[j]) if (comp[e] < 0)
        low = min(low, val[e] ?: dfs(e,g,f));
    
    if (low == val[j]) {
        do {
            x = z.back(); z.pop_back();
            comp[x] = ncomps;
            cont.push_back(x);
        } while (x != j);
        f(cont); cont.clear();
        ncomps++;
    }
    return val[j] = low;
}
template<class G, class F> void scc(G& g, F f) {
    int n = sz(g);
    val.assign(n, 0); comp.assign(n, -1);
    Time = ncomps = 0;
    rep(i,0,n) if (comp[i] < 0) dfs(i, g, f);
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<vi> g(n);
    while (m--) {
        int a, b;
        cin >> a >> b;
        g[a-1].push_back(b-1);
    }
    vi r;
    scc(g, [&](vi& c) { r.push_back(c[0]+1); } );
    if(sz(r)==1)
        cout << ""YES\n"";
    else
        cout << ""NO\n"" << r[0] << "" "" << r[1] << '\n';
    return 0;
}
"
Flight Routes Check,Java,"// https://cses.fi/problemset/task/1682
// Flight Routes Check
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1682 {
    static ArrayList[] aa, bb, cc;
    static boolean[] visited;
    static void dfs(int i) {
        if (visited[i])
            return;
        visited[i] = true;
        ArrayList<Integer> adj = cc[i];
        for (int j : adj)
            dfs(j);
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n];
        bb = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            aa[i] = new ArrayList<Integer>();
            bb[i] = new ArrayList<Integer>();
        }
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            aa[i].add(j);
            bb[j].add(i);
        }
        visited = new boolean[n];
        cc = aa;
        dfs(0);
        for (int i = 0; i < n; i++)
            if (!visited[i]) {
                System.out.println(""NO"");
                System.out.println(""1 "" + (i + 1));
                return;
            }
        Arrays.fill(visited, false);
        cc = bb;
        dfs(0);
        for (int i = 0; i < n; i++)
            if (!visited[i]) {
                System.out.println(""NO"");
                System.out.println((i + 1) + "" 1"");
                return;
            }
        System.out.println(""YES"");
    }
}
"
Flight Routes Check,C++,"/*
 https://cses.fi/problemset/task/1682
 Flight Routes Check
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int j;
} aa[N], bb[N], *cc;

char visited[N];

void link(int i, int j) {
    static struct L l91[M * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
    l->j = i;
    l->next = bb[j].next; bb[j].next = l++;
}

void dfs(int i) {
    struct L *l;
    
    if (visited[i])
        return;
    visited[i] = 1;
    for (l = cc[i].next; l; l = l->next)
        dfs(l->j);
}

int main() {
    int n, m, i, j;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j);
    }
    cc = aa;
    dfs(0);
    for (i = 0; i < n; i++)
        if (!visited[i]) {
            printf(""NO\n"");
            printf(""1 %d\n"", i + 1);
            return 0;
        }
    memset(visited, 0, n * sizeof *visited);
    cc = bb;
    dfs(0);
    for (i = 0; i < n; i++)
        if (!visited[i]) {
            printf(""NO\n"");
            printf(""%d 1\n"", i + 1);
            return 0;
        }
    printf(""YES\n"");
    return 0;
}
"
Game Routes,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

mi dp[MX];

template<int SZ> struct TopoSort {
    int N, in[SZ];
    vi res, adj[SZ];
    
    void addEdge(int x, int y) {
        adj[x].pb(y), in[y] ++;
    }
    
    bool sort(int _N) {
        N = _N; queue<int> todo;
        FOR(i,1,N+1) if (in[i] == 0) todo.push(i);
        while (sz(todo)) {
            int x = todo.front(); todo.pop();
            res.pb(x);
            trav(i,adj[x]) {
                in[i] --;
                if (!in[i]) todo.push(i);
            }
        }
        return sz(res) == N;
    }
};

TopoSort<MX> T;
int n,m;

int main() {
    re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        T.addEdge(a,b);
    }
    if (!T.sort(n)) ps(""IMPOSSIBLE"");
    else {
        reverse(all(T.res));
        trav(t,T.res) {
            if (t == n) dp[t] = 1;
            else {
                trav(x,T.adj[t]) dp[t] += dp[x];
            }
        }
        ps(dp[1]);
    }
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Game Routes,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr int P=1e9+7;

void add(int &x, int y) {
    x+=y;
    if (x>=P) x-=P;
}

vi topo_sort(const vector<vi>& gr) {
    vi indeg(sz(gr)), ret;
    trav(li, gr) trav(x, li) indeg[x]++;
    queue<int> q; // use priority queue for lexic. smallest ans.
    rep(i,0,sz(gr)) if (indeg[i] == 0) q.push(-i);
    while (!q.empty()) {
        int i = -q.front(); // top() for priority queue
        ret.push_back(i);
        q.pop();
        trav(x, gr[i])
        if (--indeg[x] == 0) q.push(-x);
    }
    return ret;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<vi> g(n);
    while (m--) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        g[a].push_back(b);
    }
    vi o=topo_sort(g), dp(n);
    dp[0]=1;
    trav(i, o) trav(j, g[i])
    add(dp[j], dp[i]);
    cout << dp[n-1] << '\n';
    return 0;
}
"
Game Routes,Java,"// https://cses.fi/problemset/task/1681
// Game Routes
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1681 {
    static final int MD = 1000000007;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        ArrayList[] aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        int[] dd = new int[n];
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            aa[i].add(j);
            dd[j]++;
        }
        int[] qq = new int[n];
        int head = 0, cnt = 0;
        for (int i = 0; i < n; i++)
            if (dd[i] == 0)
                qq[head + cnt++] = i;
        int[] dp = new int[n];
        dp[0] = 1;
        while (cnt > 0) {
            int i = qq[head++]; cnt--;
            ArrayList<Integer> adj = aa[i];
            for (int j : adj) {
                if (--dd[j] == 0)
                    qq[head + cnt++] = j;
                dp[j] = (dp[j] + dp[i]) % MD;
            }
        }
        System.out.println(dp[n - 1]);
    }
}
"
Game Routes,C++,"/*
 https://cses.fi/problemset/task/1681
 Game Routes
 practice with Dukkha
 */
#include <stdio.h>

#define N    100000
#define M    200000
#define MD    1000000007

struct L {
    struct L *next;
    int j;
} aa[N];

void link(int i, int j) {
    static struct L l91[M], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

int main() {
    static int dd[N], qq[N], dp[N];
    int n, m, i, j, head, cnt;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), dd[j]++;
    }
    head = cnt = 0;
    for (i = 0; i < n; i++)
        if (dd[i] == 0)
            qq[head + cnt++] = i;
    dp[0] = 1;
    while (cnt) {
        struct L *l;
        
        i = qq[cnt--, head++];
        for (l = aa[i].next; l; l = l->next) {
            j = l->j;
            if (--dd[j] == 0)
                qq[head + cnt++] = j;
            dp[j] = (dp[j] + dp[i]) % MD;
        }
    }
    printf(""%d\n"", dp[n - 1]);
    return 0;
}
"
Giant Pizza,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<int SZ> struct scc {
    int N, comp[SZ];
    vi adj[SZ], radj[SZ], todo, allComp;
    bitset<SZ> visit;
    
    void addEdge(int a, int b) { adj[a].pb(b), radj[b].pb(a); }
    
    void dfs(int v) {
        visit[v] = 1;
        trav(w,adj[v]) if (!visit[w]) dfs(w);
        todo.pb(v);
    }
    
    void dfs2(int v, int val) {
        comp[v] = val;
        trav(w,radj[v]) if (comp[w] == -1) dfs2(w,val);
    }
    
    void genSCC(int _N) { // fills allComp
        N = _N;
        F0R(i,N) comp[i] = -1, visit[i] = 0;
        F0R(i,N) if (!visit[i]) dfs(i);
        reverse(all(todo)); // toposort
        trav(i,todo) if (comp[i] == -1) dfs2(i,i), allComp.pb(i);
    }
};

template<int SZ> struct twosat {
    scc<2*SZ> S;
    int N;
    
    void OR(int x, int y) { S.addEdge(x^1,y); S.addEdge(y^1,x); }
    void IMPLIES(int x, int y) { OR(x^1,y); }
    
    int tmp[2*SZ];
    bitset<SZ> ans;
    
    bool solve(int _N) {
        N = _N; S.genSCC(2*N);
        for (int i = 0; i < 2*N; i += 2) if (S.comp[i] == S.comp[i^1]) return 0;
        reverse(all(S.allComp));
        trav(i,S.allComp) if (tmp[i] == 0) tmp[i] = 1, tmp[S.comp[i^1]] = -1;
        F0R(i,N) if (tmp[S.comp[2*i]] == 1) ans[i] = 1;
        return 1;
    }
};

int n,m;
twosat<100000> T;

int main() {
    setIO(); re(n,m);
    F0R(i,n) {
        char a,c; int b,d; re(a,b,c,d); b--, d--;
        T.OR(2*b+(a == '-'),2*d+(c == '-'));
        // ps()
    }
    if (!T.solve(m)) ps(""IMPOSSIBLE"");
    else {
        F0R(i,m) {
            if (T.ans[i]) pr('+');
            else pr('-');
            pr(' ');
        }
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Giant Pizza,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

struct TwoSat {
    int N;
    vector<vi> gr;
    vi values; // 0 = false, 1 = true
    
    TwoSat(int n = 0) : N(n), gr(2*n) {}
    
    int add_var() { // (optional)
        gr.emplace_back();
        gr.emplace_back();
        return N++;
    }
    
    void either(int f, int j) {
        f = max(2*f, -1-2*f);
        j = max(2*j, -1-2*j);
        gr[f].push_back(j^1);
        gr[j].push_back(f^1);
    }
    void set_value(int x) { either(x, x); }
    
    void at_most_one(const vi& li) { // (optional)
        if (sz(li) <= 1) return;
        int cur = ~li[0];
        rep(i,2,sz(li)) {
            int next = add_var();
            either(cur, ~li[i]);
            either(cur, next);
            either(~li[i], next);
            cur = ~next;
        }
        either(cur, ~li[1]);
    }
    
    vi val, comp, z; int time = 0;
    int dfs(int i) {
        int low = val[i] = ++time, x; z.push_back(i);
        trav(e, gr[i]) if (!comp[e])
            low = min(low, val[e] ?: dfs(e));
        if (low == val[i]) do {
            x = z.back(); z.pop_back();
            comp[x] = low;
            if (values[x>>1] == -1)
                values[x>>1] = x&1;
        } while (x != i);
        return val[i] = low;
    }
    
    bool solve() {
        values.assign(N, -1);
        val.assign(2*N, 0); comp = val;
        rep(i,0,2*N) if (!comp[i]) dfs(i);
        rep(i,0,N) if (comp[2*i] == comp[2*i+1]) return 0;
        return 1;
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    TwoSat f(m);
    while (n--) {
        char c1, c2;
        int i1, i2;
        cin >> c1 >> i1 >> c2 >> i2;
        i1--; i2--;
        if (c1=='-') i1=~i1;
        if (c2=='-') i2=~i2;
        f.either(i1, i2);
    }
    if (!f.solve())
        cout << ""IMPOSSIBLE\n"";
    else {
        rep(i, 0, m)
        cout << (f.values[i]? '+':'-') << "" \n""[i==m-1];
    }
    return 0;
}
"
Giant Pizza,Java,"// https://cses.fi/problemset/task/1684
// Giant Pizza
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1684 {
    static ArrayList[] aa, bb;
    static int[] cc, qq;
    static int cnt;
    static void dfs1(int i) {
        if (cc[i] != 0)
            return;
        cc[i] = 1;
        ArrayList<Integer> adj = aa[i];
        for (int j : adj)
            dfs1(j);
        qq[cnt++] = i;
    }
    static void dfs2(int j, int c) {
        if (cc[j] != 0)
            return;
        cc[j] = c;
        ArrayList<Integer> adj = bb[j];
        for (int i : adj)
            dfs2(i, c);
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int m = Integer.parseInt(st.nextToken());
        int n = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n * 2];
        bb = new ArrayList[n * 2];
        for (int i = 0; i < n * 2; i++) {
            aa[i] = new ArrayList<Integer>();
            bb[i] = new ArrayList<Integer>();
        }
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            boolean uplus = st.nextToken().charAt(0) == '+';
            int u = Integer.parseInt(st.nextToken()) - 1;
            boolean vplus = st.nextToken().charAt(0) == '+';
            int v = Integer.parseInt(st.nextToken()) - 1;
            int up = u * 2 + (uplus ? 1 : 0);
            int um = u * 2 + (uplus ? 0 : 1);
            int vp = v * 2 + (vplus ? 1 : 0);
            int vm = v * 2 + (vplus ? 0 : 1);
            aa[um].add(vp);
            bb[vp].add(um);
            aa[vm].add(up);
            bb[up].add(vm);
        }
        cc = new int[n * 2];
        qq = new int[n * 2];
        for (int i = 0; i < n * 2; i++)
            if (cc[i] == 0)
                dfs1(i);
        Arrays.fill(cc, 0);
        int c = 0;
        for (int h = n * 2 - 1; h >= 0; h--) {
            int j = qq[h];
            if (cc[j] == 0)
                dfs2(j, ++c);
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n * 2; i += 2) {
            if (cc[i] == cc[i + 1]) {
                System.out.println(""IMPOSSIBLE"");
                return;
            }
            sb.append(cc[i] < cc[i + 1] ? ""+ "" : ""- "");
        }
        System.out.println(sb);
    }
}
"
Giant Pizza,C++,"/*
 https://cses.fi/problemset/task/1684
 Giant Pizza
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100000
#define M    100000

struct L {
    struct L *next;
    int j;
} aa[N * 2], bb[N * 2];

void link(int i, int j) {
    static struct L l91[M * 4], *l = l91;
    
    l->j = j;
    l->next = aa[i].next, aa[i].next = l++;
    l->j = i;
    l->next = bb[j].next, bb[j].next = l++;
}

int cc[N * 2], qq[N * 2];

void dfs1(int i) {
    static int cnt;
    struct L *l;
    
    if (cc[i])
        return;
    cc[i] = 1;
    for (l = aa[i].next; l; l = l->next)
        dfs1(l->j);
    qq[cnt++] = i;
}

void dfs2(int j, int c) {
    struct L *l;
    
    if (cc[j])
        return;
    cc[j] = c;
    for (l = bb[j].next; l; l = l->next)
        dfs2(l->j, c);
}

int main() {
    int m, n, h, i, j, c;
    
    scanf(""%d%d"", &m, &n);
    while (m--) {
        static char s[2], t[2];
        int u, v, up, um, vp, vm;
        
        scanf(""%s%d%s%d"", s, &u, t, &v), u--, v--;
        up = u * 2 + (s[0] == '+');
        um = u * 2 + (s[0] != '+');
        vp = v * 2 + (t[0] == '+');
        vm = v * 2 + (t[0] != '+');
        link(um, vp);
        link(vm, up);
    }
    for (i = 0; i < n * 2; i++)
        if (!cc[i])
            dfs1(i);
    memset(cc, 0, n * 2 * sizeof *cc);
    c = 0;
    for (h = n * 2 - 1; h >= 0; h--) {
        j = qq[h];
        if (!cc[j])
            dfs2(j, ++c);
    }
    for (i = 0; i < n * 2; i += 2)
        if (cc[i] == cc[i + 1]) {
            printf(""IMPOSSIBLE\n"");
            return 0;
        }
    for (i = 0; i < n * 2; i += 2)
        printf(""%c "", cc[i] < cc[i + 1] ? '+' : '-');
    printf(""\n"");
    return 0;
}
"
Hamiltonian Flights,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
// const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;


const int MX = 20;

bool adj[MX][MX];
int N;
mi dp[MX][1<<MX];

mi solve() {
    dp[0][1] = 1;
    F0R(j,1<<N) F0R(i,N) if (j&(1<<i))
        F0R(k,N) if (!(j&(1<<k)) && adj[i][k])
            dp[k][j^(1<<k)] += dp[i][j];
    return dp[N-1][(1<<N)-1];
}

int m;

int main() {
    setIO(); re(N,m);
    F0R(i,m) {
        int a,b; re(a,b);
        adj[a-1][b-1] = 1;
    }
    ps(solve());
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Hamiltonian Flights,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr int P=1e9+7;

void add(int &x, int y) {
    x+=y;
    if (x>=P) x-=P;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<vi> g(n);
    while (m--) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        g[a].push_back(b);
    }
    int M=1<<n;
    vector<vi> dp(n, vi(M));
    dp[0][1]=1;
    rep(m, 0, M) rep(i, 0, n)
    if ((m&(1<<i)) && dp[i][m])
        trav(j, g[i]) if (!(m&(1<<j)))
            add(dp[j][m^(1<<j)], dp[i][m]);
    cout << dp[n-1][M-1] << '\n';
    return 0;
}
"
Hamiltonian Flights,Java,"// https://cses.fi/problemset/task/1690
// Hamiltonian Flights
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1690 {
    static final int MD = 1000000007;
    static ArrayList[] aa;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            aa[i].add(j);
        }
        int[][] dp = new int[1 << n][n];
        dp[1 << 0][0] = 1;
        for (int b = 1; b < 1 << n; b += 2)
            for (int i = 0; i < n - 1; i++) {
                int x = dp[b][i];
                if (x == 0)
                    continue;
                ArrayList<Integer> adj = aa[i];
                for (int j : adj)
                    if ((b & 1 << j) == 0) {
                        int b_ = b | 1 << j;
                        dp[b_][j] = (dp[b_][j] + x) % MD;
                    }
            }
        System.out.println(dp[(1 << n) - 1][n - 1]);
    }
}
"
Hamiltonian Flights,C++,"/*
 https://cses.fi/problemset/task/1690
 Hamiltonian Flights
 practice with Dukkha
 */
#include <stdio.h>

#define N    20
#define MD    1000000007

struct L {
    struct L *next;
    int j;
} aa[N];

void link(int i, int j) {
    static struct L l91[N * N], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

int main() {
    static int dp[1 << N][N];
    int n, m, i, j, b, b_, x;
    struct L *l;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j);
    }
    dp[1 << 0][0] = 1;
    for (b = 1; b < 1 << n; b += 2)
        for (i = 0; i < n - 1; i++) {
            x = dp[b][i];
            if (x == 0)
                continue;
            for (l = aa[i].next; l; l = l->next)
                if (!(b & 1 << (j = l->j))) {
                    b_ = b | 1 << j;
                    dp[b_][j] = (dp[b_][j] + x) % MD;
                }
        }
    printf(""%d\n"", dp[(1 << n) - 1][n - 1]);
    return 0;
}
"
High Score,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<int SZ> struct BellmanFord {
    int n;
    vector<pair<pi,int>> ed;
    void addEdge(int u, int v, int w) { ed.pb({{u,v},w}); }
    
    bool bad[SZ];
    ll dist[SZ];
    ll getDist(int x) { return bad[x] ? -INF : dist[x]; }
    
    void init(int _n, int s) {
        n = _n;
        FOR(i,1,n+1) dist[i] = INF, bad[i] = 0;
        dist[s] = 0;
        
        F0R(i,n) trav(a,ed) if (dist[a.f.f] < INF)
            dist[a.f.s] = min(dist[a.f.s], dist[a.f.f]+a.s);
        
        trav(a,ed) if (dist[a.f.f] < INF)
            if (dist[a.f.s] > dist[a.f.f]+a.s) bad[a.f.s] = 1;
        
        F0R(i,n) trav(a,ed) if (bad[a.f.f]) bad[a.f.s] = 1;
    }
};

BellmanFord<MX> B;
int n,m;

int main() {
    re(n,m);
    F0R(i,m) {
        int a,b,x; re(a,b,x);
        B.addEdge(a,b,-x);
    }
    B.init(n,1);
    ll t = B.getDist(n);
    if (t == -INF) ps(-1);
    else ps(-t);
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
High Score,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

const ll inf = LLONG_MAX;
struct Ed { int a, b, w, s() { return a < b ? a : -a; }};
struct Node { ll dist = inf; int prev = -1; };

void bellmanFord(vector<Node>& nodes, vector<Ed>& eds, int s) {
    nodes[s].dist = 0;
    sort(all(eds), [](Ed a, Ed b) { return a.s() < b.s(); });
    
    int lim = sz(nodes) / 2 + 2; // /3+100 with shuffled vertices
    rep(i,0,lim) trav(ed, eds) {
        Node cur = nodes[ed.a], &dest = nodes[ed.b];
        if (abs(cur.dist) == inf) continue;
        ll d = cur.dist + ed.w;
        if (d < dest.dist) {
            dest.prev = ed.a;
            dest.dist = (i < lim-1 ? d : -inf);
        }
    }
    rep(i,0,lim) trav(e, eds) {
        if (nodes[e.a].dist == -inf)
            nodes[e.b].dist = -inf;
    }
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<Node> v(n+1);
    vector<Ed> e(m);
    rep(i, 0, m) {
        cin >> e[i].a >> e[i].b >> e[i].w;
        e[i].w*=-1;
    }
    bellmanFord(v, e, 1);
    cout << (v[n].dist==-inf? -1:-v[n].dist) << '\n';
    return 0;
}
"
High Score,Java,"// https://cses.fi/problemset/task/1673
// High Score
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1673 {
    static ArrayList[] aa;
    static boolean[] used;
    static final long INF = 0x3f3f3f3f3f3f3f3fL;
    static int[] uu, vv, ww;
    static long[] dd;
    static void dfs(int i) {
        if (used[i])
            return;
        used[i] = true;
        ArrayList<Integer> adj = aa[i];
        for (int j : adj)
            dfs(j);
    }
    static boolean relax(int m) {
        boolean updated = false;
        for (int h = 0; h < m; h++) {
            int u = uu[h];
            int v = vv[h];
            int w = ww[h];
            if (used[u] && used[v] && dd[u] != INF) {
                long d = dd[u] + w;
                if (dd[v] > d) {
                    updated = true;
                    dd[v] = d;
                }
            }
        }
        return updated;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n + 1];
        for (int i = 1; i <= n; i++)
            aa[i] = new ArrayList<Integer>();
        uu = new int[m];
        vv = new int[m];
        ww = new int[m];
        for (int h = 0; h < m; h++) {
            st = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            int w = Integer.parseInt(st.nextToken());
            uu[h] = u;
            vv[h] = v;
            ww[h] = -w;
            aa[v].add(u);
        }
        used = new boolean[n + 1];
        dfs(n);
        dd = new long[n + 1];
        Arrays.fill(dd, INF);
        dd[1] = 0;
        for (int h = 1; h < n; h++)
            relax(m);
        System.out.println(relax(m) ? -1 : -dd[n]);
    }
}
"
High Score,Java,"// https://cses.fi/problemset/task/1673
// High Score
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1673 {
    static ArrayList[] aa;
    static boolean[] used;
    static final long INF = 0x3f3f3f3f3f3f3f3fL;
    static int[] uu, vv, ww;
    static long[] dd;
    static void dfs(int i) {
        if (used[i])
            return;
        used[i] = true;
        ArrayList<Integer> adj = aa[i];
        for (int j : adj)
            dfs(j);
    }
    static boolean relax(int m) {
        boolean updated = false;
        for (int h = 0; h < m; h++) {
            int u = uu[h];
            int v = vv[h];
            int w = ww[h];
            if (used[u] && used[v] && dd[u] != INF) {
                long d = dd[u] + w;
                if (dd[v] > d) {
                    updated = true;
                    dd[v] = d;
                }
            }
        }
        return updated;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n + 1];
        for (int i = 1; i <= n; i++)
            aa[i] = new ArrayList<Integer>();
        uu = new int[m];
        vv = new int[m];
        ww = new int[m];
        for (int h = 0; h < m; h++) {
            st = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            int w = Integer.parseInt(st.nextToken());
            uu[h] = u;
            vv[h] = v;
            ww[h] = -w;
            aa[v].add(u);
        }
        used = new boolean[n + 1];
        dfs(n);
        dd = new long[n + 1];
        Arrays.fill(dd, INF);
        dd[1] = 0;
        for (int h = 1; h < n; h++)
            relax(m);
        System.out.println(relax(m) ? -1 : dd[n] == INF ? -999999999999999999L : -dd[n]);
    }
}
"
High Score,C++,"/*
 https://cses.fi/problemset/task/1673
 High Score
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    2500
#define M    5000
#define INF    0x3f3f3f3f3f3f3f3fLL

struct L {
    struct L *next;
    int j;
} aa[N + 1];

void link(int i, int j) {
    static struct L l91[M], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

char used[N + 1];

void dfs(int i) {
    struct L *l;
    
    if (used[i])
        return;
    used[i] = 1;
    for (l = aa[i].next; l; l = l->next)
        dfs(l->j);
}

int uu[M], vv[M], ww[M];
long long dd[N + 1];

int relax(int m) {
    int h, u, v, w, updated;
    long long d;
    
    updated = 0;
    for (h = 0; h < m; h++) {
        u = uu[h], v = vv[h], w = ww[h];
        if (used[u] && used[v] && dd[u] != INF && dd[v] > (d = dd[u] + w)) {
            updated = 1;
            dd[v] = d;
        }
    }
    return updated;
}

int main() {
    int n, m, h, u, v, w;
    
    scanf(""%d%d"", &n, &m);
    for (h = 0; h < m; h++) {
        scanf(""%d%d%d"", &u, &v, &w), w = -w;
        uu[h] = u, vv[h] = v, ww[h] = w;
        link(vv[h], uu[h]);
    }
    dfs(n);
    memset(dd, 0x3f, (n + 1) * sizeof *dd);
    dd[1] = 0;
    for (h = 1; h < n; h++)
        relax(m);
    printf(""%lld\n"", relax(m) ? -1 : -dd[n]);
    return 0;
}
"
High Score,C++,"/*
 https://cses.fi/problemset/task/1673
 High Score
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    2500
#define M    5000
#define INF    0x3f3f3f3f3f3f3f3fLL

struct L {
    struct L *next;
    int j;
} aa[N + 1];

void link(int i, int j) {
    static struct L l91[M], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

char used[N + 1];

void dfs(int i) {
    struct L *l;
    
    if (used[i])
        return;
    used[i] = 1;
    for (l = aa[i].next; l; l = l->next)
        dfs(l->j);
}

int uu[M], vv[M], ww[M];
long long dd[N + 1];

int relax(int m) {
    int h, u, v, w, updated;
    long long d;
    
    updated = 0;
    for (h = 0; h < m; h++) {
        u = uu[h], v = vv[h], w = ww[h];
        if (used[u] && used[v] && dd[u] != INF && dd[v] > (d = dd[u] + w)) {
            updated = 1;
            dd[v] = d;
        }
    }
    return updated;
}

int main() {
    int n, m, h, u, v, w;
    
    scanf(""%d%d"", &n, &m);
    for (h = 0; h < m; h++) {
        scanf(""%d%d%d"", &u, &v, &w), w = -w;
        uu[h] = u, vv[h] = v, ww[h] = w;
        link(vv[h], uu[h]);
    }
    dfs(n);
    memset(dd, 0x3f, (n + 1) * sizeof *dd);
    dd[1] = 0;
    for (h = 1; h < n; h++)
        relax(m);
    printf(""%lld\n"", relax(m) ? -1 : dd[n] == INF ? -999999999999999999LL : -dd[n]);
    return 0;
}
"
Investigation,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
typedef pair<ll,ll> pll;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;
const int MX = 200001;
const ll INF = 1e18;

vector<pii> adj[MX], radj[MX];
ll dist[2][MX], num[MX], mx[MX], mn[MX];
ll ans = INF;
int n,m;

void gendist1() {
    FOR(i,2,n+1) dist[0][i] = INF;
    priority_queue<pll,vector<pll>,greater<pll>> pq;
    pq.push({0,1});
    while (sz(pq)) {
        pll x = pq.top(); pq.pop();
        if (dist[0][x.s] != x.f) continue;
        for (auto a: adj[x.s]) if (dist[0][a.f] > x.f+a.s)
            pq.push({dist[0][a.f] = x.f+a.s,a.f});
    }
}

bool cmp(int a, int b) {
    return dist[0][a] < dist[0][b];
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m;
    F0R(i,m) {
        int a,b,c; cin >> a >> b >> c;
        adj[a].pb({b,c});
    }
    gendist1();
    vi x; FOR(i,1,n+1) x.pb(i);
    sort(x.rbegin(),x.rend(),cmp);
    num[n] = 1;
    for (int i: x) if (i != n) {
        mx[i] = -MOD, mn[i] = MOD;
        for (auto j: adj[i]) if (dist[0][i]+j.s == dist[0][j.f]) {
            num[i] = (num[i]+num[j.f]) % MOD;
            mx[i] = max(mx[i],mx[j.f]+1);
            mn[i] = min(mn[i],mn[j.f]+1);
        }
    }
    cout << dist[0][n] << "" "" << num[1] << "" "" << mn[1] << "" "" << mx[1];
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Investigation,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr ll inf=1e18;
    constexpr int P=1e9+7;
    int n, m;
    cin >> n >> m;
    vector<vector<pii>> g(n+1);
    while (m--) {
        int a, b, c;
        cin >> a >> b >> c;
        g[a].push_back({b, c});
    }
    vector<ll> d(n+1, inf);
    priority_queue<pair<ll, int>> q;
    vi o;
    for (q.push({0, 1}); !q.empty(); q.pop()) {
        ll cur=-q.top().first;
        int i=q.top().second;
        if (d[i]<inf) continue;
        d[i]=cur;
        o.push_back(i);
        trav(p, g[i]) q.push({-cur-p.second, p.first});
    }
    vi cnt(n+1), sp(n+1, n), lp(n+1);
    cnt[1]=1,  sp[1]=lp[1]=0;
    trav(i, o) trav(p, g[i]) {
        int j=p.first;
        if (d[i]+p.second!=d[j]) continue;
        cnt[j]+=cnt[i];
        if(cnt[j]>=P) cnt[j]-=P;
        sp[j]=min(sp[j], 1+sp[i]);
        lp[j]=max(lp[j], 1+lp[i]);
    }
    cout << d[n] << "" "" << cnt[n] << "" "" << sp[n] << "" "" << lp[n] << '\n';
    return 0;
}
"
Investigation,C++,"// https://cses.fi/problemset/task/1202
// Investigation
// practice with rainboy
#include <iostream>
#include <vector>
#include <set>

using namespace std;

const int N = 100000, MD = 1000000007;
const long long INF = 0x3f3f3f3f3f3f3f3fLL;

typedef pair<int, int> pii;

vector<pii> aa[N];
long long dd[N];
int kk[N], lmin[N], lmax[N];

struct Compare {
    bool operator() (int i, int j) const {
        return dd[i] < dd[j] || (dd[i] == dd[j] && i < j);
    }
};

int main() {
    int n, m;
    scanf(""%d%d"", &n, &m);
    while (m--) {
        int i, j, c;
        scanf(""%d%d%d"", &i, &j, &c);
        i--, j--;
        aa[i].push_back({ j, c });
    }
    set<int, Compare> pq;
    for (int i = 0; i < n; i++)
        dd[i] = INF;
    dd[0] = 0;
    kk[0] = 1;
    lmin[0] = lmax[0] = 0;
    pq.insert(0);
    while (!pq.empty()) {
        auto it = pq.begin();
        int i = *it;
        pq.erase(it);
        for (auto &e : aa[i]) {
            int j = e.first, c = e.second;
            if (dd[j] >= dd[i] + c) {
                if (dd[j] != INF)
                    pq.erase(j);
                if (dd[j] > dd[i] + c) {
                    dd[j] = dd[i] + c;
                    kk[j] = kk[i];
                    lmin[j] = lmin[i] + 1;
                    lmax[j] = lmax[i] + 1;
                } else {
                    kk[j] = (kk[j] + kk[i]) % MD;
                    lmin[j] = min(lmin[j], lmin[i] + 1);
                    lmax[j] = max(lmax[j], lmax[i] + 1);
                }
                pq.insert(j);
            }
        }
    }
    printf(""%lld %d %d %d\n"", dd[n - 1], kk[n - 1], lmin[n - 1], lmax[n - 1]);
    return 0;
}
"
Investigation,C++,"/*
 https://cses.fi/problemset/task/1202
 Investigation
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100000
#define M    200000
#define INF    0x3f3f3f3f3f3f3f3f
#define MD    1000000007

struct L {
    struct L *next;
    int j, c;
} aa[N];

long long dd[N];
int kk[N], lmin[N], lmax[N];

struct V {
    int i;    /* for heap */
    int i_;
} vv[N], *pq[1 + N];

int cnt;

#define LT(u, v) (dd[(u)->i_] < dd[(v)->i_])

int i2(int i) {
    return (i *= 2) > cnt ? 0 : i < cnt && LT(pq[i + 1], pq[i]) ? i + 1 : i;
}

void pq_up(struct V *u) {
    int i, j;
    
    for (i = u->i; (j = i / 2) && LT(u, pq[j]); i = j)
        pq[pq[j]->i = i] = pq[j];
    pq[u->i = i] = u;
}

void pq_dn(struct V *u) {
    int i, j;
    
    for (i = u->i; (j = i2(i)) && LT(pq[j], u); i = j)
        pq[pq[j]->i = i] = pq[j];
    pq[u->i = i] = u;
}

void pq_add(struct V *u) {
    u->i = ++cnt;
    pq_up(u);
}

struct V *pq_remove_first() {
    struct V *u = pq[1], *v = pq[cnt--];
    
    v->i = 1;
    pq_dn(v);
    return u;
}

void link(int i, int j, int c) {
    static struct L l91[M], *l = l91;
    
    l->j = j, l->c = c;
    l->next = aa[i].next; aa[i].next = l++;
}

int main() {
    int n, m, i, j, c;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d%d"", &i, &j, &c), i--, j--;
        link(i, j, c);
    }
    for (i = 0; i < n; i++)
        vv[i].i_ = i;
    memset(dd, 0x3f, sizeof dd);
    dd[0] = 0;
    kk[0] = 1;
    pq_add(&vv[0]);
    while (cnt) {
        struct V *u = pq_remove_first();
        struct L *l;
        
        i = u->i_;
        for (l = aa[i].next; l; l = l->next) {
            j = l->j, c = l->c;
            if (dd[j] >= dd[i] + c) {
                int inf = dd[j] == INF;
                
                if (dd[j] > dd[i] + c) {
                    dd[j] = dd[i] + c;
                    kk[j] = kk[i];
                    lmin[j] = lmin[i] + 1;
                    lmax[j] = lmax[i] + 1;
                } else {
                    kk[j] = (kk[j] + kk[i]) % MD;
                    if (lmin[j] > lmin[i] + 1)
                        lmin[j] = lmin[i] + 1;
                    if (lmax[j] < lmax[i] + 1)
                        lmax[j] = lmax[i] + 1;
                }
                if (inf)
                    pq_add(&vv[j]);
                else
                    pq_up(&vv[j]);
            }
        }
    }
    printf(""%lld %d %d %d\n"", dd[n - 1], kk[n - 1], lmin[n - 1], lmax[n - 1]);
    return 0;
}
"
Knight's Tour,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int x,y;
int xd[8] = {2,1,-1,-2,-2,-1,1,2};
int yd[8] = {1,2,2,1,-1,-2,-2,-1};
int gr[8][8];

bool valid(int x, int y) {
    return 0 <= x && x < 8 && 0 <= y && y < 8;
}

bool emp(int x, int y) {
    return valid(x,y) && !gr[x][y];
}

int moves(int x, int y) {
    int cnt = 0;
    F0R(i,8) {
        int X = x+xd[i], Y = y+yd[i];
        if (emp(X,Y)) cnt ++;
    }
    return cnt;
}

void dfs(int cnt, int x, int y) {
    gr[x][y] = cnt;
    if (cnt == 64) {
        F0R(j,8) {
            F0R(i,8) pr(gr[i][j],' ');
            ps();
        }
        exit(0);
    }
    vpi v;
    F0R(i,8) {
        int X = x+xd[i], Y = y+yd[i];
        if (!emp(X,Y)) continue;
        v.pb({moves(X,Y),i});
    }
    sort(all(v));
    trav(t,v) dfs(cnt+1,x+xd[t.s],y+yd[t.s]);
    gr[x][y] = 0;
}

int main() {
    setIO(); re(x,y); x--,y--;
    dfs(1,x,y);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Knight's Tour,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vector<pii> nbs(int i, int j) {
    vector<pii> ans;
    rep(di, -2, 2+1) rep(dj, -2, 2+1) {
        if (di*di+dj*dj!=5) continue;
        int ii=i+di, jj=j+dj;
        if (ii>=0 && ii<8 && jj>=0 && jj<8)
            ans.push_back({ii, jj});
    }
    return ans;
}

void solve(int i, int j) {
    vector<vi> x(8, vi(8));
    // int i, j;
    // cin >> i >> j;
    i--, j--;
    x[i][j]=1;
    rep(k, 2, 65) {
        pii opt{0, 0};
        int val=100;
        trav(p, nbs(i, j)) {
            if (x[p.first][p.second]) continue;
            int cur=0;
            trav(q, nbs(p.first, p.second))
            cur+=(x[q.first][q.second]==0);
            if(cur<val || (cur==val && p.second>opt.first))
                val=cur, opt=p;
        }
        i=opt.first, j=opt.second;
        x[i][j]=k;
    }
    rep(i, 0, 8) rep(j, 0, 8) {
        //cout << x[i][j] << "" \n""[j==7];
        assert(x[i][j]);
    }
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    vector<vi> x(8, vi(8));
    int i, j;
    cin >> j >> i;
    i--, j--;
    x[i][j]=1;
    rep(k, 2, 65) {
        pii opt{0, 0};
        int val=100;
        trav(p, nbs(i, j)) {
            if (x[p.first][p.second]) continue;
            int cur=0;
            trav(q, nbs(p.first, p.second))
            cur+=(x[q.first][q.second]==0);
            if(cur<val || (cur==val && p.second>opt.first))
                val=cur, opt=p;
        }
        i=opt.first, j=opt.second;
        x[i][j]=k;
    }
    rep(i, 0, 8) rep(j, 0, 8)
    cout << x[i][j] << "" \n""[j==7];
    return 0;
}
"
Knight's Tour,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vector<pii> nbs(int i, int j) {
    vector<pii> ans;
    rep(di, -2, 2+1) rep(dj, -2, 2+1) {
        if (di*di+dj*dj!=5) continue;
        int ii=i+di, jj=j+dj;
        if (ii>=0 && ii<8 && jj>=0 && jj<8)
            ans.push_back({ii, jj});
    }
    return ans;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    vector<vi> x(8, vi(8));
    int i, j;
    cin >> j >> i;
    i--, j--;
    x[i][j]=1;
    rep(k, 2, 65) {
        pii opt{0, 0};
        int val=100;
        trav(p, nbs(i, j)) {
            if (x[p.first][p.second]) continue;
            int cur=0;
            trav(q, nbs(p.first, p.second))
            cur+=(x[q.first][q.second]==0);
            if(cur<val || (cur==val && p.second>opt.first))
                val=cur, opt=p;
        }
        i=opt.first, j=opt.second;
        x[i][j]=k;
    }
    rep(i, 0, 8) rep(j, 0, 8)
    cout << x[i][j] << "" \n""[j==7];
    return 0;
}
"
Knight's Tour,Java,"// https://cses.fi/problemset/task/1689
// Knight's Tour
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1689 {
    static int[][] aa = new int[8][8];
    static int[][][] hh = new int[8][8][8];
    static int[][] kk = new int[8][8];
    static int[] di = new int[] { -2, -2, -1, -1, 1, 1, 2, 2 };
    static int[] dj = new int[] { -1, 1, -2, 2, -2, 2, -1, 1 };
    static Random rand = new Random();
    static int count(int i, int j) {
        int k = 0;
        for (int h = 0; h < 8; h++) {
            int i_ = i + di[h];
            int j_ = j + dj[h];
            if (i_ >= 0 && i_ < 8 && j_ >= 0 && j_ < 8)
                k++;
        }
        return k;
    }
    static void init() {
        for (int i = 0; i < 8; i++)
            for (int j = 0; j < 8; j++)
                kk[i][j] = count(i, j);
        int[] dd = new int[8];
        Integer[] hh_ = new Integer[8];
        for (int i = 0; i < 8; i++)
            for (int j = 0; j < 8; j++) {
                int k = 0;
                for (int h = 0; h < 8; h++) {
                    int i_ = i + di[h];
                    int j_ = j + dj[h];
                    if (i_ >= 0 && i_ < 8 && j_ >= 0 && j_ < 8) {
                        dd[h] = kk[i_][j_];
                        hh_[k++] = h;
                    }
                }
                for (int h = 1; h < k; h++) {
                    int h_ = rand.nextInt(h + 1);
                    int tmp = hh_[h_]; hh_[h_] = hh_[h]; hh_[h] = tmp;
                }
                Arrays.sort(hh_, 0, k, (u, v) -> dd[u] - dd[v]);
                for (int h = 0; h < k; h++)
                    hh[i][j][h] = hh_[h];
            }
    }
    static boolean solve(int i, int j, int m) {
        aa[i][j] = m;
        if (m == 64)
            return true;
        m++;
        int[] hh_ = hh[i][j];
        int k = kk[i][j];
        for (int h = 0; h < k; h++) {
            int i_ = i + di[hh_[h]];
            int j_ = j + dj[hh_[h]];
            if (aa[i_][j_] == 0 && solve(i_, j_, m))
                return true;
        }
        aa[i][j] = 0;
        return false;
    }
    public static void main(String[] args) throws IOException {
        init();
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int j1 = Integer.parseInt(st.nextToken()) - 1;
        int i1 = Integer.parseInt(st.nextToken()) - 1;
        solve(i1, j1, 1);
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++)
                pw.print(aa[i][j] + "" "");
            pw.println();
        }
        pw.close();
    }
}
"
Knight's Tour,C++,"/*
 https://cses.fi/problemset/task/1689
 Knight's Tour
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int aa[8][8], hh[8][8][8], kk[8][8];

int di[8] = { -2, -2, -1, -1, 1, 1, 2, 2 };
int dj[8] = { -1, 1, -2, 2, -2, 2, -1, 1 };

int dd[8];

int compare(const void *a, const void *b) {
    int u = *(int *) a;
    int v = *(int *) b;
    
    return dd[u] - dd[v];
}

int count(int i, int j) {
    int h, i_, j_, k;
    
    k = 0;
    for (h = 0; h < 8; h++) {
        i_ = i + di[h];
        j_ = j + dj[h];
        if (i_ >= 0 && i_ < 8 && j_ >= 0 && j_ < 8)
            k++;
    }
    return k;
}

void init() {
    static int hh_[8];
    int h, h_, i, i_, j, j_, k, tmp;
    
    for (i = 0; i < 8; i++)
        for (j = 0; j < 8; j++)
            kk[i][j] = count(i, j);
    srand(time(NULL));
    for (i = 0; i < 8; i++)
        for (j = 0; j < 8; j++) {
            k = 0;
            for (h = 0; h < 8; h++) {
                i_ = i + di[h];
                j_ = j + dj[h];
                if (i_ >= 0 && i_ < 8 && j_ >= 0 && j_ < 8) {
                    dd[h] = kk[i_][j_];
                    hh_[k++] = h;
                }
            }
            kk[i][j] = k;
            for (h = 1; h < k; h++) {
                h_ = rand() % (h + 1);
                tmp = hh_[h], hh_[h] = hh_[h_], hh_[h_] = tmp;
            }
            qsort(hh_, k, sizeof *hh_, compare);
            for (h = 0; h < k; h++)
                hh[i][j][h] = hh_[h];
        }
}

int solve(int i, int j, int m) {
    int *hh_ = hh[i][j], h, i_, j_, k;
    
    if (aa[i][j])
        return 0;
    aa[i][j] = m;
    if (m == 64)
        return 1;
    m++;
    k = kk[i][j];
    for (h = 0; h < k; h++) {
        i_ = i + di[hh_[h]];
        j_ = j + dj[hh_[h]];
        if (solve(i_, j_, m))
            return 1;
    }
    aa[i][j] = 0;
    return 0;
}

int main() {
    int i1, j1, i, j;
    
    init();
    scanf(""%d%d"", &j1, &i1), j1--, i1--;
    solve(i1, j1, 1);
    for (i = 0; i < 8; i++) {
        for (j = 0; j < 8; j++)
            printf(""%d "", aa[i][j]);
        printf(""\n"");
    }
    return 0;
}
"
Labyrinth,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int r,c, dist[2500][2500];
char g[2500][2500];
pair<pii,char> PRE[2500][2500];
pii st, en;
queue<pii> q;

int xdir[4] = {0,1,0,-1}, ydir[4] = {1,0,-1,0};
string pre = ""URDL"";

bool valid(pii x) {
    return x.f >= 0 && x.f < c && x.s >= 0 && x.s < r && g[x.f][x.s] != '#';
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> r >> c;
    F0Rd(j,r) F0R(i,c) {
        dist[i][j] = MOD;
        cin >> g[i][j];
        if (g[i][j] == 'A') st = {i,j};
        else if (g[i][j] == 'B') en = {i,j};
    }
    dist[st.f][st.s] = 0;
    q.push(st);
    while (sz(q)) {
        pii x = q.front(); q.pop();
        F0R(i,4) {
            pii X = {x.f+xdir[i],x.s+ydir[i]};
            if (!valid(X) || dist[X.f][X.s] != MOD) continue;
            dist[X.f][X.s] = dist[x.f][x.s]+1;
            PRE[X.f][X.s] = {x,pre[i]};
            q.push(X);
        }
    }
    if (dist[en.f][en.s] == MOD) {
        cout << ""NO"";
        return 0;
    }
    string z;
    while (en != st) {
        z += PRE[en.f][en.s].s;
        en = PRE[en.f][en.s].f;
    }
    cout << ""YES\n"";
    reverse(all(z));
    cout << sz(z) << ""\n"";
    cout << z;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Labyrinth,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int inf=1e9;
    int dr[]={-1, 1, 0, 0}, dc[]={0, 0, -1, 1};
    char dl[]=""UDLR"";
    int R, C;
    cin >> R >> C;
    vector<string> s(R);
    queue<pii> q;
    vector<vi> ht(R, vi(C, inf)), p(R, vi(C));
    int r0=0, c0=0, r1=0, c1=0;
    rep(r, 0, R) {
        cin >> s[r];
        rep(c, 0, C) {
            if (s[r][c]=='A')
                ht[r][c]=0, r0=r, c0=c, s[r][c]='.';
            if (s[r][c]=='B')
                r1=r, c1=c, s[r][c]='.';
        }
    }
    for (q.push({r0, c0}); !q.empty(); q.pop()) {
        int r, c;
        tie(r, c)=q.front();
        if (r==r1 && c==c1) break;
        rep(d, 0, 4) {
            int rr=r+dr[d];
            int cc=c+dc[d];
            if (rr<0 || rr>=R || cc<0 || cc>=C)
                continue;
            if (s[rr][cc]=='.' && ht[rr][cc]==inf) {
                ht[rr][cc]=ht[r][c]+1;
                q.push({rr, cc});
                p[rr][cc]=d;
            }
        }
    }
    if (ht[r1][c1]==inf)
        cout << ""NO\n"";
    else {
        string ans;
        int r=r1, c=c1;
        do {
            int d=p[r][c];
            ans+=dl[d];
            r-=dr[d], c-=dc[d];
        } while (r!=r0 || c!=c0);
        reverse(all(ans));
        cout << ""YES\n"" << sz(ans) << '\n' << ans << '\n';
    }
    return 0;
}
"
Labyrinth,Java,"// practice with rainboy
// https://cses.fi/problemset/task/1193
// Labyrinth
import java.io.*;
import java.util.*;

public class CSES1193 {
    static int n, m;
    static char[][] cc;
    static int[][] dd, hh;
    static int[] ii = { -1, 0, 0, 1 };
    static int[] jj = { 0, -1, 1, 0 };
    static char[] zz = ""ULRD"".toCharArray();
    static boolean bfs(int i, int j) {
        int[] qq = new int[n * m * 2];
        int head = 0, cnt = 0;
        dd[i][j] = 0;
        qq[head + cnt++] = i;
        qq[head + cnt++] = j;
        while (cnt > 0) {
            i = qq[head++]; cnt--;
            j = qq[head++]; cnt--;
            int d = dd[i][j] + 1;
            for (int h = 0; h < 4; h++) {
                int i_ = i + ii[h];
                int j_ = j + jj[h];
                if (i_ >= 0 && i_ < n && j_ >= 0 && j_ < m && cc[i_][j_] != '#' && dd[i_][j_] > d) {
                    dd[i_][j_] = d;
                    hh[i_][j_] = h;
                    if (cc[i_][j_] == 'B')
                        return true;
                    qq[head + cnt++] = i_;
                    qq[head + cnt++] = j_;
                }
            }
        }
        return false;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        cc = new char[n][m];
        for (int i = 0; i < n; i++)
            br.readLine().getChars(0, m, cc[i], 0);
        dd = new int[n][m];
        hh = new int[n][m];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                dd[i][j] = n * m;
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                if (cc[i][j] == 'A') {
                    if (bfs(i, j)) {
                        System.out.println(""YES"");
                    out:
                        for (i = 0; i < n; i++)
                            for (j = 0; j < m; j++)
                                if (cc[i][j] == 'B')
                                    break out;
                        System.out.println(dd[i][j]);
                        StringBuilder sb = new StringBuilder();
                        for (int d = dd[i][j]; d > 0; d--) {
                            int h = hh[i][j];
                            sb.append(zz[h]);
                            i -= ii[h];
                            j -= jj[h];
                        }
                        System.out.println(sb.reverse().toString());
                        return;
                    }
                }
        System.out.println(""NO"");
    }
}
"
Labyrinth,C++,"/*
 practice with Dukkha
 https://cses.fi/problemset/task/1193
 Labyrinth
 */
#include <stdio.h>

#define N    1000

int n, m;
char cc[N][N + 1], s[N * N + 1];
int dd[N][N], hh[N][N];
int ii[] = { -1, 0, 0, 1 };
int jj[] = { 0, -1, 1, 0 };
char zz[] = ""ULRD"";

int bfs(int i, int j) {
    static int qq[N * N * 2];
    int head, cnt, d, h;
    
    dd[i][j] = 0;
    head = cnt = 0;
    qq[head + cnt++] = i, qq[head + cnt++] = j;
    while (cnt) {
        i = qq[cnt--, head++], j = qq[cnt--, head++];
        d = dd[i][j] + 1;
        for (h = 0; h < 4; h++) {
            int i_ = i + ii[h];
            int j_ = j + jj[h];
            
            if (i_ >= 0 && i_ < n && j_ >= 0 && j_ < m && cc[i_][j_] != '#' && dd[i_][j_] > d) {
                dd[i_][j_] = d;
                hh[i_][j_] = h;
                if (cc[i_][j_] == 'B')
                    return 1;
                qq[head + cnt++] = i_, qq[head + cnt++] = j_;
            }
        }
    }
    return 0;
}

int main() {
    int d, i, j;
    
    scanf(""%d%d"", &n, &m);
    for (i = 0; i < n; i++)
        scanf(""%s"", cc[i]);
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++)
            dd[i][j] = n * m;
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++)
            if (cc[i][j] == 'A') {
                if (bfs(i, j)) {
                    printf(""YES\n"");
                    for (i = 0; i < n; i++)
                        for (j = 0; j < m; j++)
                            if (cc[i][j] == 'B')
                                goto out;
                out:
                    printf(""%d\n"", dd[i][j]);
                    for (d = dd[i][j]; d > 0; d--) {
                        int h = hh[i][j];
                        
                        s[d - 1] = zz[h];
                        i -= ii[h];
                        j -= jj[h];
                    }
                    printf(""%s\n"", s);
                } else {
                    printf(""NO\n"");
                }
                return 0;
            }
    return 0;
}
"
Longest Flight Route,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int dp[MX];

template<int SZ> struct TopoSort {
    int N, in[SZ];
    vi res, adj[SZ];
    
    void addEdge(int x, int y) {
        adj[x].pb(y), in[y] ++;
    }
    
    bool sort(int _N) {
        N = _N; queue<int> todo;
        FOR(i,1,N+1) if (in[i] == 0) todo.push(i);
        while (sz(todo)) {
            int x = todo.front(); todo.pop();
            res.pb(x);
            trav(i,adj[x]) {
                in[i] --;
                if (!in[i]) todo.push(i);
            }
        }
        return sz(res) == N;
    }
};

TopoSort<MX> T;
int n,m;

int main() {
    re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        T.addEdge(a,b);
    }
    if (!T.sort(n)) ps(""IMPOSSIBLE"");
    else {
        reverse(all(T.res));
        trav(t,T.res) {
            if (t == n) dp[t] = 1;
            else {
                dp[t] = -MOD;
                trav(x,T.adj[t]) if (dp[x] != -MOD) ckmax(dp[t],dp[x]+1);
            }
        }
        if (dp[1] == -MOD) ps(""IMPOSSIBLE"");
        else {
            ps(dp[1]);
            vi cur = {1};
            while (cur.back() != n) {
                trav(x,T.adj[cur.back()]) if (dp[cur.back()] == dp[x]+1) {
                    cur.pb(x);
                    break;
                }
            }
            trav(t,cur) pr(t,' ');
        }
    }
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Longest Flight Route,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vi topo_sort(const vector<vi>& gr) {
    vi indeg(sz(gr)), ret;
    trav(li, gr) trav(x, li) indeg[x]++;
    queue<int> q; // use priority queue for lexic. smallest ans.
    rep(i,0,sz(gr)) if (indeg[i] == 0) q.push(-i);
    while (!q.empty()) {
        int i = -q.front(); // top() for priority queue
        ret.push_back(i);
        q.pop();
        trav(x, gr[i])
        if (--indeg[x] == 0) q.push(-x);
    }
    return ret;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<vi> g(n+1);
    while (m--) {
        int a, b;
        cin >> a >>b;
        g[a].push_back(b);
    }
    vi o=topo_sort(g), dp(n+1), p(n+1);
    dp[1]=1;
    trav(i, o) trav(j, g[i])
    if (dp[i] && dp[i]+1>dp[j])
        dp[j]=dp[i]+1, p[j]=i;
    int d=dp[n];
    if (!d) {
        cout << ""IMPOSSIBLE\n"";
        return 0;
    }
    cout << d << ""\n"";
    vi ans;
    for (int i=n; i; i=p[i])
        ans.push_back(i);
    rep(i, 0, d)
    cout  << ans[d-1-i] << "" \n""[i==d-1];
    return 0;
}
"
Longest Flight Route,Java,"// https://cses.fi/problemset/task/1680
// Longest Flight Route
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1680 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        ArrayList[] aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        int[] dd = new int[n];
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            aa[i].add(j);
            dd[j]++;
        }
        int[] qq = new int[n];
        int head = 0, cnt = 0;
        for (int i = 0; i < n; i++)
            if (dd[i] == 0)
                qq[head + cnt++] = i;
        int[] dp = new int[n];
        int[] pp = new int[n];
        dp[0] = 1;
        while (cnt > 0) {
            int i = qq[head++]; cnt--;
            ArrayList<Integer> adj = aa[i];
            for (int j : adj) {
                if (--dd[j] == 0)
                    qq[head + cnt++] = j;
                if (dp[i] != 0)
                    if (dp[j] < dp[i] + 1) {
                        dp[j] = dp[i] + 1;
                        pp[j] = i;
                    }
            }
        }
        int k = dp[n - 1];
        if (k == 0)
            pw.println(""IMPOSSIBLE"");
        else {
            for (int h = k - 1, i = n - 1; h >= 0; h--, i = pp[i])
                qq[h] = i;
            pw.println(k);
            for (int h = 0; h < k; h++)
                pw.print(qq[h] + 1 + "" "");
            pw.println();
        }
        pw.close();
    }
}
"
Longest Flight Route,C++,"/*
 https://cses.fi/problemset/task/1680
 Longest Flight Route
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int j;
} aa[N];

void link(int i, int j) {
    static struct L l91[M], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

int main() {
    static int dd[N], qq[N], dp[N], pp[N];
    int n, m, h, i, j, k, head, cnt;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), dd[j]++;
    }
    head = cnt = 0;
    for (i = 0; i < n; i++)
        if (dd[i] == 0)
            qq[head + cnt++] = i;
    dp[0] = 1;
    while (cnt) {
        struct L *l;
        
        i = qq[cnt--, head++];
        for (l = aa[i].next; l; l = l->next) {
            j = l->j;
            if (--dd[j] == 0)
                qq[head + cnt++] = j;
            if (dp[i] != 0 && dp[j] < dp[i] + 1) {
                dp[j] = dp[i] + 1;
                pp[j] = i;
            }
        }
    }
    k = dp[n - 1];
    if (k == 0)
        printf(""IMPOSSIBLE\n"");
    else {
        for (h = k - 1, i = n - 1; h >= 0; h--, i = pp[i])
            qq[h] = i;
        printf(""%d\n"", k);
        for (h = 0; h < k; h++)
            printf(""%d "", qq[h] + 1);
        printf(""\n"");
    }
    return 0;
}
"
Mail Delivery,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;


template<int SZ, bool directed> struct Euler {
    int N, M;
    vpi adj[SZ], circuit;
    int out[SZ], in[SZ], deg[SZ];
    bool used[SZ], bad;
    
    void clr() {
        F0R(i,N) adj[i].clear();
        circuit.clear();
        F0R(i,N) out[i] = in[i] = deg[i] = 0;
        F0R(i,M) used[i] = 0;
        N = M = bad = 0;
    }
    
    void dfs(int pre, int cur) {
        while (sz(adj[cur])) {
            pi x = adj[cur].back(); adj[cur].pop_back();
            if (used[x.s]) continue;
            used[x.s] = 1; dfs(cur,x.f);
        }
        if (sz(circuit) && circuit.back().f != cur) bad = 1;
        circuit.pb({pre,cur}); // generate circuit in reverse order
    }
    
    void addEdge(int a, int b) {
        if (directed) {
            adj[a].pb({b,M});
            out[a] ++, in[b] ++;
        } else {
            adj[a].pb({b,M}), adj[b].pb({a,M});
            deg[a] ++, deg[b] ++;
        }
        M ++;
    }
    
    vi solve(int _N) {
        N = _N; // edges only involve vertices from 0 to N-1
        
        int start = 1;
        FOR(i,1,N+1) if (deg[i]%2 != 0) return {};
        dfs(-1,start);
        
        if (sz(circuit) != M+1 || bad) return {}; // return empty if no sol
        vi ans; F0Rd(i,sz(circuit)) ans.pb(circuit[i].s);
        return ans;
    }
};

Euler<MX,0> E;
int n,m;

int main() {
    setIO(); re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        E.addEdge(a,b);
    }
    auto x = E.solve(n);
    if (!sz(x)) ps(""IMPOSSIBLE"");
    else {
        trav(t,x) pr(t,' ');
        exit(0);
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Mail Delivery,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

struct V {
    vector<pii> outs; // (dest, edge index)
    int nins = 0;
};

vi euler_walk(vector<V>& nodes, int nedges, int src=0) {
    int c = 0;
    trav(n, nodes) c += abs(n.nins - sz(n.outs));
    if (c > 2) return {};
    vector<vector<pii>::iterator> its;
    trav(n, nodes)
    its.push_back(n.outs.begin());
    vector<bool> eu(nedges);
    vi ret, s = {src};
    while(!s.empty()) {
        int x = s.back();
        auto& it = its[x], end = nodes[x].outs.end();
        while(it != end && eu[it->second]) ++it;
        if(it == end) { ret.push_back(x); s.pop_back(); }
        else { s.push_back(it->first); eu[it->second] = true; }
    }
    if(sz(ret) != nedges+1)
        ret.clear(); // No Eulerian cycles/paths.
    // else, non-cycle if ret.front() != ret.back()
    reverse(all(ret));
    return ret;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<V> g(n);
    rep(i, 0, m) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        g[a].outs.push_back({b, i});
        g[b].outs.push_back({a, i});
        g[a].nins++, g[b].nins++;
    }
    int odd=0;
    rep(i, 0, n) odd+=(g[i].nins%2);
    vi ans=euler_walk(g, m, 0);
    if (odd || sz(ans)!=m+1 || ans.back()!=0)
        cout << ""IMPOSSIBLE\n"";
    else
        rep(i, 0, m+1) cout << ans[i]+1 << "" \n""[i==m];
    return 0;
}
"
Mail Delivery,Java,"// https://cses.fi/problemset/task/1691
// Mail Delivery
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1691 {
    static class L {
        L next;
        int h;
        L(int h) {
            this.h = h;
        }
    }
    static L[] aa;
    static int[] ii, jj;
    static boolean[] removed;
    static void link(int i, int h) {
        L l = new L(h);
        l.next = aa[i]; aa[i] = l;
    }
    static L hierholzer(L e, int i) {
        L l;
        while ((l = aa[i]) != null) {
            int h = l.h;
            if (removed[h])
                aa[i] = l.next;
            else {
                removed[h] = true;
                e = e.next = new L(h);
                i ^= ii[h] ^ jj[h];
            }
        }
        return e;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        ii = new int[m + 1];
        jj = new int[m + 1];
        removed = new boolean[m + 1];
        aa = new L[n + 1];
        int[] dd = new int[n + 1];
        for (int h = 1; h <= m; h++) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken());
            int j = Integer.parseInt(st.nextToken());
            ii[h] = i;
            jj[h] = j;
            link(i, h);
            link(j, h);
            dd[i]++;
            dd[j]++;
        }
        for (int i = 1; i <= n; i++)
            if (dd[i] % 2 != 0) {
                System.out.println(""IMPOSSIBLE"");
                return;
            }
        ii[0] = 0;
        jj[0] = 1;
        L e_ = new L(0);
        int i = 0;
        m++;
        for (L e = e_; e != null; e = e.next) {
            i ^= ii[e.h] ^ jj[e.h];
            L f = e.next;
            hierholzer(e, i).next = f;
            m--;
        }
        if (m != 0) {
            System.out.println(""IMPOSSIBLE"");
            return;
        }
        PrintWriter pw = new PrintWriter(System.out);
        i = 0;
        for (L e = e_; e != null; e = e.next) {
            i ^= ii[e.h] ^ jj[e.h];
            pw.print(i + "" "");
        }
        pw.println();
        pw.close();
    }
}
"
Mail Delivery,Java,"// https://cses.fi/problemset/task/1691
// Mail Delivery
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1691 {
    static class L {
        L next;
        int h;
        L(int h) {
            this.h = h;
        }
    }
    static L[] aa;
    static int[] ij;
    static boolean[] lazy;
    static void link(int i, int h) {
        L l = new L(h);
        l.next = aa[i]; aa[i] = l;
    }
    static L hierholzer(L e, int i) {
        L l;
        while ((l = aa[i]) != null) {
            int h = l.h;
            if (lazy[h])
                aa[i] = l.next;
            else {
                lazy[h] = true;
                e = e.next = new L(h);
                i ^= ij[h];
            }
        }
        return e;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        ij = new int[m + 1];
        lazy = new boolean[m + 1];
        aa = new L[n + 1];
        int[] dd = new int[n + 1];
        for (int h = 1; h <= m; h++) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken());
            int j = Integer.parseInt(st.nextToken());
            ij[h] = i ^ j;
            link(i, h);
            link(j, h);
            dd[i]++;
            dd[j]++;
        }
        for (int i = 1; i <= n; i++)
            if (dd[i] % 2 != 0) {
                System.out.println(""IMPOSSIBLE"");
                return;
            }
        ij[0] = 1;
        L e_ = new L(0);
        int i = 0;
        m++;
        for (L e = e_; e != null; e = e.next) {
            i ^= ij[e.h];
            L f = e.next;
            hierholzer(e, i).next = f;
            m--;
        }
        if (m != 0) {
            System.out.println(""IMPOSSIBLE"");
            return;
        }
        PrintWriter pw = new PrintWriter(System.out);
        i = 0;
        for (L e = e_; e != null; e = e.next) {
            i ^= ij[e.h];
            pw.print(i + "" "");
        }
        pw.println();
        pw.close();
    }
}
"
Mail Delivery,Java,"// https://cses.fi/problemset/task/1691
// Mail Delivery
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1691 {
    static class L {
        L next;
        int h;
        L(int h) {
            this.h = h;
        }
    }
    static L[] aa;
    static int[] ij;
    static boolean[] lazy;
    static void link(int i, int h) {
        L l = new L(h);
        l.next = aa[i]; aa[i] = l;
    }
    static void hierholzer(L e, int i) {
        L f = e.next, l;
        while ((l = aa[i]) != null) {
            int h = l.h;
            if (lazy[h])
                aa[i] = l.next;
            else {
                lazy[h] = true;
                e = e.next = new L(h);
                i ^= ij[h];
            }
        }
        e.next = f;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        ij = new int[m + 1];
        lazy = new boolean[m + 1];
        aa = new L[n + 1];
        int[] dd = new int[n + 1];
        for (int h = 1; h <= m; h++) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken());
            int j = Integer.parseInt(st.nextToken());
            ij[h] = i ^ j;
            link(i, h);
            link(j, h);
            dd[i]++;
            dd[j]++;
        }
        for (int i = 1; i <= n; i++)
            if (dd[i] % 2 != 0) {
                System.out.println(""IMPOSSIBLE"");
                return;
            }
        ij[0] = 1;
        L e_ = new L(0);
        int i = 0;
        m++;
        for (L e = e_; e != null; e = e.next) {
            i ^= ij[e.h];
            hierholzer(e, i);
            m--;
        }
        if (m != 0) {
            System.out.println(""IMPOSSIBLE"");
            return;
        }
        PrintWriter pw = new PrintWriter(System.out);
        i = 0;
        for (L e = e_; e != null; e = e.next) {
            i ^= ij[e.h];
            pw.print(i + "" "");
        }
        pw.println();
        pw.close();
    }
}
"
Mail Delivery,Java,"// https://cses.fi/problemset/task/1691
// Mail Delivery
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1691 {
    static class L {
        L next;
        int h;
        L(int h) {
            this.h = h;
        }
    }
    static L[] aa;
    static int[] ij;
    static boolean[] lazy;
    static void link(int i, int h) {
        L l = new L(h);
        l.next = aa[i]; aa[i] = l;
    }
    static void hierholzer(L e, int i) {
        L f = e.next, l;
        while ((l = aa[i]) != null) {
            int h = l.h;
            if (lazy[h])
                aa[i] = l.next;
            else {
                lazy[h] = true;
                e = e.next = new L(h);
                i ^= ij[h];
            }
        }
        e.next = f;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        ij = new int[m + 1];
        lazy = new boolean[m + 1];
        aa = new L[n];
        int[] dd = new int[n];
        for (int h = 1; h <= m; h++) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            ij[h] = i ^ j;
            link(i, h);
            link(j, h);
            dd[i]++;
            dd[j]++;
        }
        for (int i = 0; i < n; i++)
            if (dd[i] % 2 != 0) {
                System.out.println(""IMPOSSIBLE"");
                return;
            }
        L e_ = new L(0);
        int i = 0;
        m++;
        for (L e = e_; e != null; e = e.next) {
            i ^= ij[e.h];
            hierholzer(e, i);
            m--;
        }
        if (m != 0) {
            System.out.println(""IMPOSSIBLE"");
            return;
        }
        PrintWriter pw = new PrintWriter(System.out);
        i = 0;
        for (L e = e_; e != null; e = e.next) {
            i ^= ij[e.h];
            pw.print(i + 1 + "" "");
        }
        pw.println();
        pw.close();
    }
}
"
Mail Delivery,C++,"/*
 https://cses.fi/problemset/task/1691
 Mail Delivery
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int h;
} *aa[N + 1];

int ii[M + 1], jj[M + 1];
char removed[M + 1];

struct L *new_L(int h) {
    struct L *l = (struct L *) calloc(1, sizeof *l);
    
    l->h = h;
    return l;
}

void link(int i, int h) {
    struct L *l = new_L(h);
    
    l->next = aa[i]; aa[i] = l;
}

struct L *hierholzer(struct L *e, int i) {
    struct L *l;
    
    while ((l = aa[i])) {
        int h = l->h;
        
        if (removed[h]) {
            aa[i] = l->next;
            free(l);
        } else {
            removed[h] = 1;
            e = e->next = new_L(h);
            i ^= ii[h] ^ jj[h];
        }
    }
    return e;
}

int main() {
    static int dd[N + 1];
    struct L *e_, *e, *f;
    int n, m, h, i, j;
    
    scanf(""%d%d"", &n, &m);
    for (h = 1; h <= m; h++) {
        scanf(""%d%d"", &i, &j);
        ii[h] = i, jj[h] = j;
        link(i, h), link(j, h);
        dd[i]++, dd[j]++;
    }
    for (i = 1; i <= n; i++)
        if (dd[i] % 2) {
            printf(""IMPOSSIBLE\n"");
            return 0;
        }
    ii[0] = 0;
    jj[0] = 1;
    e_ = new_L(0);
    i = 0;
    m++;
    for (e = e_; e; e = e->next) {
        i ^= ii[e->h] ^ jj[e->h];
        f = e->next;
        hierholzer(e, i)->next = f;
        m--;
    }
    if (m != 0) {
        printf(""IMPOSSIBLE\n"");
        return 0;
    }
    i = 0;
    for (e = e_; e; e = e->next) {
        i ^= ii[e->h] ^ jj[e->h];
        printf(""%d "", i);
    }
    printf(""\n"");
    return 0;
}
"
Mail Delivery,C++,"/*
 https://cses.fi/problemset/task/1691
 Mail Delivery
 practice with Dukkha
 */
#include <stdio.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int h;
} *aa[N + 1];

int ii[M + 1], jj[M + 1];
char removed[M + 1];

struct L *new_L(int h) {
    static struct L l91[M * 2 + 1 + M], *l = l91;
    
    l->h = h;
    return l++;
}

void link(int i, int h) {
    struct L *l = new_L(h);
    
    l->next = aa[i]; aa[i] = l;
}

struct L *hierholzer(struct L *e, int i) {
    struct L *l;
    
    while ((l = aa[i])) {
        int h = l->h;
        
        if (removed[h])
            aa[i] = l->next;
        else {
            removed[h] = 1;
            e = e->next = new_L(h);
            i ^= ii[h] ^ jj[h];
        }
    }
    return e;
}

int main() {
    static int dd[N + 1];
    struct L *e_, *e, *f;
    int n, m, h, i, j;
    
    scanf(""%d%d"", &n, &m);
    for (h = 1; h <= m; h++) {
        scanf(""%d%d"", &i, &j);
        ii[h] = i, jj[h] = j;
        link(i, h), link(j, h);
        dd[i]++, dd[j]++;
    }
    for (i = 1; i <= n; i++)
        if (dd[i] % 2) {
            printf(""IMPOSSIBLE\n"");
            return 0;
        }
    ii[0] = 0;
    jj[0] = 1;
    e_ = new_L(0);
    i = 0;
    m++;
    for (e = e_; e; e = e->next) {
        i ^= ii[e->h] ^ jj[e->h];
        f = e->next;
        hierholzer(e, i)->next = f;
        m--;
    }
    if (m != 0) {
        printf(""IMPOSSIBLE\n"");
        return 0;
    }
    i = 0;
    for (e = e_; e; e = e->next) {
        i ^= ii[e->h] ^ jj[e->h];
        printf(""%d "", i);
    }
    printf(""\n"");
    return 0;
}
"
Mail Delivery,C++,"/*
 https://cses.fi/problemset/task/1691
 Mail Delivery
 practice with Dukkha
 */
#include <stdio.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int h;
} *aa[N + 1];

int ij[M + 1];
char lazy[M + 1];

struct L *new_L(int h) {
    static struct L l91[M * 2 + 1 + M], *l = l91;
    
    l->h = h;
    return l++;
}

void link(int i, int h) {
    struct L *l = new_L(h);
    
    l->next = aa[i]; aa[i] = l;
}

struct L *hierholzer(struct L *e, int i) {
    struct L *l;
    
    while ((l = aa[i])) {
        int h = l->h;
        
        if (lazy[h])
            aa[i] = l->next;
        else {
            lazy[h] = 1;
            e = e->next = new_L(h);
            i ^= ij[h];
        }
    }
    return e;
}

int main() {
    static int dd[N + 1];
    struct L *e_, *e, *f;
    int n, m, h, i, j;
    
    scanf(""%d%d"", &n, &m);
    for (h = 1; h <= m; h++) {
        scanf(""%d%d"", &i, &j);
        ij[h] = i ^ j;
        link(i, h), link(j, h);
        dd[i]++, dd[j]++;
    }
    for (i = 1; i <= n; i++)
        if (dd[i] % 2) {
            printf(""IMPOSSIBLE\n"");
            return 0;
        }
    ij[0] = 1;
    e_ = new_L(0);
    i = 0;
    m++;
    for (e = e_; e; e = e->next) {
        i ^= ij[e->h];
        f = e->next;
        hierholzer(e, i)->next = f;
        m--;
    }
    if (m != 0) {
        printf(""IMPOSSIBLE\n"");
        return 0;
    }
    i = 0;
    for (e = e_; e; e = e->next) {
        i ^= ij[e->h];
        printf(""%d "", i);
    }
    printf(""\n"");
    return 0;
}
"
Mail Delivery,C++,"/*
 https://cses.fi/problemset/task/1691
 Mail Delivery
 practice with Dukkha
 */
#include <stdio.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int h;
} *aa[N + 1];

int ij[M + 1];
char lazy[M + 1];

struct L *new_L(int h) {
    static struct L l91[M * 2 + 1 + M], *l = l91;
    
    l->h = h;
    return l++;
}

void link(int i, int h) {
    struct L *l = new_L(h);
    
    l->next = aa[i]; aa[i] = l;
}

void hierholzer(struct L *e, int i) {
    struct L *f = e->next, *l;
    
    while ((l = aa[i])) {
        int h = l->h;
        
        if (lazy[h])
            aa[i] = l->next;
        else {
            lazy[h] = 1;
            e = e->next = new_L(h);
            i ^= ij[h];
        }
    }
    e->next = f;
}

int main() {
    static int dd[N + 1];
    struct L *e_, *e;
    int n, m, h, i, j;
    
    scanf(""%d%d"", &n, &m);
    for (h = 1; h <= m; h++) {
        scanf(""%d%d"", &i, &j);
        ij[h] = i ^ j;
        link(i, h), link(j, h);
        dd[i]++, dd[j]++;
    }
    for (i = 1; i <= n; i++)
        if (dd[i] % 2) {
            printf(""IMPOSSIBLE\n"");
            return 0;
        }
    ij[0] = 1;
    e_ = new_L(0);
    i = 0;
    m++;
    for (e = e_; e; e = e->next) {
        i ^= ij[e->h];
        hierholzer(e, i);
        m--;
    }
    if (m != 0) {
        printf(""IMPOSSIBLE\n"");
        return 0;
    }
    i = 0;
    for (e = e_; e; e = e->next) {
        i ^= ij[e->h];
        printf(""%d "", i);
    }
    printf(""\n"");
    return 0;
}
"
Mail Delivery,C++,"/*
 https://cses.fi/problemset/task/1691
 Mail Delivery
 practice with Dukkha
 */
#include <stdio.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int h;
} *aa[N];

int ij[M + 1];
char lazy[M + 1];

struct L *new_L(int h) {
    static struct L l91[M * 2 + 1 + M], *l = l91;
    
    l->h = h;
    return l++;
}

void link(int i, int h) {
    struct L *l = new_L(h);
    
    l->next = aa[i]; aa[i] = l;
}

void hierholzer(struct L *e, int i) {
    struct L *f = e->next, *l;
    
    while ((l = aa[i])) {
        int h = l->h;
        
        if (lazy[h])
            aa[i] = l->next;
        else {
            lazy[h] = 1;
            e = e->next = new_L(h);
            i ^= ij[h];
        }
    }
    e->next = f;
}

int main() {
    static int dd[N];
    struct L *e_, *e;
    int n, m, h, i, j;
    
    scanf(""%d%d"", &n, &m);
    for (h = 1; h <= m; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        ij[h] = i ^ j;
        link(i, h), link(j, h);
        dd[i]++, dd[j]++;
    }
    for (i = 0; i < n; i++)
        if (dd[i] % 2) {
            printf(""IMPOSSIBLE\n"");
            return 0;
        }
    e_ = new_L(0);
    i = 0;
    m++;
    for (e = e_; e; e = e->next) {
        i ^= ij[e->h];
        hierholzer(e, i);
        m--;
    }
    if (m != 0) {
        printf(""IMPOSSIBLE\n"");
        return 0;
    }
    i = 0;
    for (e = e_; e; e = e->next) {
        i ^= ij[e->h];
        printf(""%d "", i + 1);
    }
    printf(""\n"");
    return 0;
}
"
Message Route,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,m, dist[MX], pre[MX];
vi adj[MX];

template<int SZ> struct DSU {
    int par[SZ], sz[SZ];
    
    DSU() {
        F0R(i,SZ) par[i] = i, sz[i] = 1;
    }
    
    int get(int x) { // path compression
        if (par[x] != x) par[x] = get(par[x]);
        return par[x];
    }
    
    bool unite(int x, int y) { // union-by-rank
        x = get(x), y = get(y);
        if (x == y) return 0;
        if (sz[x] < sz[y]) swap(x,y);
        sz[x] += sz[y], par[y] = x;
        return 1;
    }
};

DSU<MX> D;

int main() {
    setIO(); re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        adj[a].pb(b), adj[b].pb(a);
    }
    FOR(i,2,n+1) dist[i] = MOD;
    queue<int> q; q.push(1);
    while (sz(q)) {
        int x = q.front(); q.pop();
        trav(t,adj[x]) if (dist[t] == MOD) {
            dist[t] = dist[x]+1; pre[t] = x;
            q.push(t);
        }
    }
    if (dist[n] == MOD) ps(""IMPOSSIBLE"");
    else {
        ps(dist[n]+1);
        vi v = {n}; while (v.back() != 1) v.pb(pre[v.back()]);
        reverse(all(v));
        trav(t,v) pr(t,' ');
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Message Route,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<vi> g(n+1);
    while    (m--) {
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    vi p(n+1);
    p[1]=-1;
    queue<int> q;
    for (q.push(1); !q.empty(); q.pop()) {
        int i=q.front();
        trav(j, g[i]) if (!p[j])
            p[j]=i, q.push(j);
    }
    if (!p[n]) {
        cout << ""IMPOSSIBLE\n"";
        return 0;
    }
    vi ans;
    for (int i=n; i>0; i=p[i])
        ans.push_back(i);
    reverse(all(ans));
    cout << sz(ans) << '\n';
    rep(i, 0, sz(ans))
    cout << ans[i] << "" \n""[i==sz(ans)-1];
    return 0;
}
"
Message Route,Java,"// https://cses.fi/problemset/task/1667
// Message Route
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1667 {
    static ArrayList[] aa;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            aa[i].add(j);
            aa[j].add(i);
        }
        int[] pp = new int[n];
        Arrays.fill(pp, -1);
        int[] qq = new int[n];
        int head = 0, cnt = 0;
        pp[0] = 0;
        qq[head + cnt++] = 0;
        while (cnt > 0) {
            int i = qq[head++]; cnt--;
            if (i == n - 1) {
                cnt = 0;
                while (i != 0) {
                    qq[cnt++] = i;
                    i = pp[i];
                }
                qq[cnt++] = 0;
                PrintWriter pw = new PrintWriter(System.out);
                pw.println(cnt);
                while (cnt-- > 0)
                    pw.print(qq[cnt] + 1 + "" "");
                pw.println();
                pw.close();
                return;
            }
            ArrayList<Integer> adj = aa[i];
            for (int j : adj)
                if (pp[j] == -1) {
                    pp[j] = i;
                    qq[head + cnt++] = j;
                }
        }
        System.out.println(""IMPOSSIBLE"");
    }
}
"
Message Route,Java,"// https://cses.fi/problemset/task/1667
// Message Route
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1667 {
    static ArrayList[] aa;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            aa[i].add(j);
            aa[j].add(i);
        }
        int[] pp = new int[n];
        Arrays.fill(pp, -1);
        int[] qq = new int[n];
        int head = 0, cnt = 0;
        pp[0] = 0;
        qq[head + cnt++] = 0;
        while (cnt > 0) {
            int i = qq[head++]; cnt--;
            ArrayList<Integer> adj = aa[i];
            for (int j : adj)
                if (pp[j] == -1) {
                    pp[j] = i;
                    if (j == n - 1) {
                        cnt = 0;
                        while (j != 0) {
                            qq[cnt++] = j;
                            j = pp[j];
                        }
                        qq[cnt++] = 0;
                        PrintWriter pw = new PrintWriter(System.out);
                        pw.println(cnt);
                        while (cnt-- > 0)
                            pw.print(qq[cnt] + 1 + "" "");
                        pw.println();
                        pw.close();
                        return;
                    }
                    qq[head + cnt++] = j;
                }
        }
        System.out.println(""IMPOSSIBLE"");
    }
}
"
Message Route,C++,"/*
 https://cses.fi/problemset/task/1667
 Message Route
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int j;
} aa[N];

void link(int i, int j) {
    static struct L l91[M * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next, aa[i].next = l++;
}

int main() {
    static int pp[N], qq[N];
    int n, m, i, j, head, cnt;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), link(j, i);
    }
    memset(pp, -1, sizeof pp);
    head = cnt = 0;
    pp[0] = 0, qq[head + cnt++] = 0;
    while (cnt) {
        struct L *l;
        
        i = qq[cnt--, head++];
        for (l = aa[i].next; l; l = l->next)
            if (pp[j = l->j] == -1) {
                pp[j] = i, qq[head + cnt++] = j;
                if (j == n - 1) {
                    cnt = 0;
                    while (j != 0) {
                        qq[cnt++] = j + 1;
                        j = pp[j];
                    }
                    qq[cnt++] = 1;
                    printf(""%d\n"", cnt);
                    while (cnt--)
                        printf(""%d "", qq[cnt]);
                    printf(""\n"");
                    return 0;
                }
            }
    }
    printf(""IMPOSSIBLE\n"");
    return 0;
}
"
Monsters,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int r,c, dist[2500][2500], DIST[2500][2500];
char g[2500][2500];
pii st;
queue<pii> q;

int xdir[4] = {0,1,0,-1}, ydir[4] = {1,0,-1,0};
string pre = ""URDL"", ans;

bool valid(pii x) {
    return x.f >= 0 && x.f < c && x.s >= 0 && x.s < r && g[x.f][x.s] != '#';
}

void solve(int x, int y) {
    pii z = {x,y};
    while (z != st) {
        F0R(i,4) {
            pii Z = {z.f+xdir[i],z.s+ydir[i]};
            if (!valid(Z)) continue;
            if (dist[Z.f][Z.s] < dist[z.f][z.s]) {
                ans += pre[i^2];
                z = Z;
                break;
            }
        }
    }
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> r >> c;
    F0Rd(j,r) F0R(i,c) {
        dist[i][j] = DIST[i][j] = MOD;
        cin >> g[i][j];
        if (g[i][j] == 'A') st = {i,j};
    }
    
    dist[st.f][st.s] = 0;
    q.push(st);
    while (sz(q)) {
        pii x = q.front(); q.pop();
        F0R(i,4) {
            pii X = {x.f+xdir[i],x.s+ydir[i]};
            if (!valid(X) || dist[X.f][X.s] != MOD) continue;
            dist[X.f][X.s] = dist[x.f][x.s]+1;
            q.push(X);
        }
    }
    F0R(i,c) F0R(j,r) {
        DIST[i][j] = MOD;
        if (g[i][j] == 'M') {
            DIST[i][j] = 0;
            q.push({i,j});
        }
    }
    while (sz(q)) {
        pii x = q.front(); q.pop();
        F0R(i,4) {
            pii X = {x.f+xdir[i],x.s+ydir[i]};
            if (!valid(X) || DIST[X.f][X.s] != MOD) continue;
            DIST[X.f][X.s] = DIST[x.f][x.s]+1;
            q.push(X);
        }
    }
    
    F0R(i,c) F0R(j,r) if ((i == 0 || i == c-1 || j == 0 || j == r-1) && valid({i,j})
                          && dist[i][j] < DIST[i][j]) {
        solve(i,j);
        reverse(all(ans));
        cout << ""YES\n"" << sz(ans) << ""\n"";
        cout << ans;
        return 0;
    }
    cout << ""NO"";
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Monsters,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int inf=1e9;
    int dr[]={-1, 1, 0, 0}, dc[]={0, 0, -1, 1};
    char dl[]=""UDLR"";
    int R, C;
    cin >> R >> C;
    vector<string> s(R);
    queue<pii> q;
    vector<vi> mt(R, vi(C, inf)), ht(R, vi(C, inf)), p(R, vi(C));
    int r0=0, c0=0;
    rep(r, 0, R) {
        cin >> s[r];
        rep(c, 0, C) {
            if (s[r][c]=='A')
                ht[r][c]=0, r0=r, c0=c, s[r][c]='.';
            if (s[r][c]=='M')
                mt[r][c]=0, q.push({r,c}), s[r][c]='.';
        }
    }
    for (; !q.empty(); q.pop()) {
        int r, c;
        tie(r, c)=q.front();
        rep(d, 0, 4) {
            int rr=r+dr[d];
            int cc=c+dc[d];
            if (rr<0 || rr>=R || cc<0 || cc>=C)
                continue;
            if (s[rr][cc]=='.' && mt[rr][cc]==inf)
                mt[rr][cc]=mt[r][c]+1, q.push({rr, cc});
        }
    }
    for (q.push({r0, c0}); !q.empty(); q.pop()) {
        int r, c;
        tie(r, c)=q.front();
        rep(d, 0, 4) {
            int rr=r+dr[d];
            int cc=c+dc[d];
            if (rr<0 || rr>=R || cc<0 || cc>=C)
                continue;
            if (s[rr][cc]=='.' && ht[rr][cc]==inf
                && ht[r][c]+1<mt[rr][cc]) {
                ht[rr][cc]=ht[r][c]+1;
                q.push({rr, cc});
                p[rr][cc]=d;
            }
        }
    }
    rep(r, 0, R) rep(c, 0, C) {
        if (r>0 && r<R-1 && c>0 && c<C-1) continue;
        if (ht[r][c]<inf) {
            string ans;
            while (r!=r0 || c!=c0) {
                int d=p[r][c];
                ans+=dl[d];
                r-=dr[d], c-=dc[d];
            }
            reverse(all(ans));
            cout << ""YES\n"" << sz(ans) << '\n' << ans << '\n';
            return 0;
        }
    }
    cout << ""NO\n"";
    return 0;
}
"
Monsters,Java,"// https://cses.fi/problemset/task/1194
// Monsters
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1194 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        char[][] cc = new char[n][m];
        for (int i = 0; i < n; i++)
            br.readLine().getChars(0, m, cc[i], 0);
        int[] qq = new int[n * m * 2];
        int head = 0, cnt = 0;
        int[][] dd = new int[n][m];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                dd[i][j] = n * m;
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                if (cc[i][j] == 'M') {
                    dd[i][j] = 0;
                    qq[head + cnt++] = i;
                    qq[head + cnt++] = j;
                }
        int[] ii = { -1, 0, 0, 1 };
        int[] jj = { 0, -1, 1, 0 };
        char[] pp = { 'U', 'L', 'R', 'D' };
        while (cnt > 0) {
            int i = qq[head++]; cnt--;
            int j = qq[head++]; cnt--;
            int d = dd[i][j] + 1;
            for (int h = 0; h < 4; h++) {
                int i_ = i + ii[h];
                int j_ = j + jj[h];
                if (i_ >= 0 && i_ < n && j_ >= 0 && j_ < m && cc[i_][j_] != '#' && dd[i_][j_] > d) {
                    dd[i_][j_] = d;
                    qq[head + cnt++] = i_;
                    qq[head + cnt++] = j_;
                }
            }
        }
        head = cnt = 0;
    out:
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                if (cc[i][j] == 'A') {
                    dd[i][j] = 0;
                    qq[head + cnt++] = i;
                    qq[head + cnt++] = j;
                    break out;
                }
        int[][] hh = new int[n][m];
        while (cnt > 0) {
            int i = qq[head++]; cnt--;
            int j = qq[head++]; cnt--;
            if (i == 0 || i == n - 1 || j == 0 || j == m - 1) {
                System.out.println(""YES"");
                System.out.println(dd[i][j]);
                StringBuilder sb = new StringBuilder();
                while (dd[i][j] > 0) {
                    int h = hh[i][j];
                    sb.append(pp[h]);
                    i -= ii[h];
                    j -= jj[h];
                }
                System.out.println(sb.reverse().toString());
                return;
            }
            int d = dd[i][j] + 1;
            for (int h = 0; h < 4; h++) {
                int i_ = i + ii[h];
                int j_ = j + jj[h];
                if (cc[i_][j_] != '#' && dd[i_][j_] > d) {
                    dd[i_][j_] = d;
                    hh[i_][j_] = h;
                    qq[head + cnt++] = i_;
                    qq[head + cnt++] = j_;
                }
            }
        }
        System.out.println(""NO"");
    }
}
"
Monsters,C++,"/*
 https://cses.fi/problemset/task/1194
 Monsters
 practice with Dukkha
 */
#include <stdio.h>

#define N    2500

int main() {
    static char cc[N][N + 1], s[N * N + 1];
    static int qq[N * N * 2], dd[N][N], hh[N][N];
    int ii[] = { -1, 0, 0, 1 };
    int jj[] = { 0, -1, 1, 0 };
    char pp[] = ""ULRD"";
    int n, m, h, i, j, d, head, cnt;
    
    scanf(""%d%d"", &n, &m);
    for (i = 0; i < n; i++)
        scanf(""%s"", cc[i]);
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++)
            dd[i][j] = n * m;
    head = cnt = 0;
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++)
            if (cc[i][j] == 'M') {
                dd[i][j] = 0;
                qq[head + cnt++] = i;
                qq[head + cnt++] = j;
            }
    while (cnt) {
        i = qq[cnt--, head++], j = qq[cnt--, head++], d = dd[i][j] + 1;
        for (h = 0; h < 4; h++) {
            int i_ = i + ii[h], j_ = j + jj[h];
            
            if (i_ >= 0 && i_ < n && j_ >= 0 && j_ < m && cc[i_][j_] != '#' && dd[i_][j_] > d) {
                dd[i_][j_] = d;
                qq[head + cnt++] = i_;
                qq[head + cnt++] = j_;
            }
        }
    }
    head = cnt = 0;
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++)
            if (cc[i][j] == 'A') {
                dd[i][j] = 0;
                qq[head + cnt++] = i;
                qq[head + cnt++] = j;
                goto out;
            }
out:
    while (cnt > 0) {
        i = qq[cnt--, head++], j = qq[cnt--, head++];
        if (i == 0 || i == n - 1 || j == 0 || j == m - 1) {
            printf(""YES\n"");
            printf(""%d\n"", dd[i][j]);
            while (dd[i][j]) {
                h = hh[i][j];
                s[dd[i][j] - 1] = pp[h];
                i -= ii[h];
                j -= jj[h];
            }
            printf(""%s\n"", s);
            return 0;
        }
        d = dd[i][j] + 1;
        for (h = 0; h < 4; h++) {
            int i_ = i + ii[h], j_ = j + jj[h];
            
            if (cc[i_][j_] != '#' && dd[i_][j_] > d) {
                dd[i_][j_] = d;
                hh[i_][j_] = h;
                qq[head + cnt++] = i_;
                qq[head + cnt++] = j_;
            }
        }
    }
    printf(""NO\n"");
    return 0;
}
"
Planets and Kingdoms,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<int SZ> struct scc {
    int N, comp[SZ];
    vi adj[SZ], radj[SZ], todo, allComp;
    bitset<SZ> visit;
    
    void addEdge(int a, int b) { adj[a].pb(b), radj[b].pb(a); }
    
    void dfs(int v) {
        visit[v] = 1;
        trav(w,adj[v]) if (!visit[w]) dfs(w);
        todo.pb(v);
    }
    
    void dfs2(int v, int val) {
        comp[v] = val;
        trav(w,radj[v]) if (comp[w] == -1) dfs2(w,val);
    }
    
    void genSCC(int _N) { // fills allComp
        N = _N;
        FOR(i,1,N+1) comp[i] = -1, visit[i] = 0;
        FOR(i,1,N+1) if (!visit[i]) dfs(i);
        reverse(all(todo)); // toposort
        trav(i,todo) if (comp[i] == -1) dfs2(i,i), allComp.pb(i);
    }
};

scc<MX> S;

int n,m,co, z[MX];

int main() {
    setIO(); re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        S.addEdge(a,b);
    }
    S.genSCC(n);
    FOR(i,1,n+1) if (!z[S.comp[i]]) z[S.comp[i]] = ++co;
    ps(co);
    FOR(i,1,n+1) pr(z[S.comp[i]],' ');
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Planets and Kingdoms,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vi val, comp, z, cont;
int Time, ncomps;
template<class G, class F> int dfs(int j, G& g, F& f) {
    int low = val[j] = ++Time, x; z.push_back(j);
    trav(e,g[j]) if (comp[e] < 0)
        low = min(low, val[e] ?: dfs(e,g,f));
    
    if (low == val[j]) {
        do {
            x = z.back(); z.pop_back();
            comp[x] = ncomps;
            cont.push_back(x);
        } while (x != j);
        f(cont); cont.clear();
        ncomps++;
    }
    return val[j] = low;
}
template<class G, class F> void scc(G& g, F f) {
    int n = sz(g);
    val.assign(n, 0); comp.assign(n, -1);
    Time = ncomps = 0;
    rep(i,0,n) if (comp[i] < 0) dfs(i, g, f);
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<vi> g(n);
    while (m--) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        g[a].push_back(b);
    }
    scc(g, [](vi&){});
    cout << ncomps << '\n';
    rep(i, 0, n)
    cout << comp[i]+1 << "" \n""[i==n-1];
    return 0;
}
"
Planets and Kingdoms,Java,"// https://cses.fi/problemset/task/1683
// Planets and Kingdoms
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1683 {
    static ArrayList[] aa, bb;
    static int[] qq, cc;
    static int cnt;
    static int[] stack;
    static void dfs1(int i) {
        int k = 0;
        stack[k++] = i;
        while (k > 0) {
            i = stack[k - 1];
            if (cc[i] == 0) {
                cc[i] = 1;
                ArrayList<Integer> adj = aa[i];
                for (int j : adj)
                    if (cc[j] == 0)
                        stack[k++] = j;
            } else {
                k--;
                if (cc[i] == 1) {
                    cc[i] = 2;
                    qq[cnt++] = i;
                }
            }
        }
    }
    static void dfs2(int j, int c) {
        int k = 0;
        stack[k++] = j; cc[j] = c;
        while (k > 0) {
            j = stack[--k];
            ArrayList<Integer> adj = bb[j];
            for (int i : adj)
                if (cc[i] == 0) {
                    stack[k++] = i; cc[i] = c;
                }
        }
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int m = sc.nextInt();
        aa = new ArrayList[n];
        bb = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            aa[i] = new ArrayList<Integer>();
            bb[i] = new ArrayList<Integer>();
        }
        stack = new int[m];
        while (m-- > 0) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            aa[i].add(j);
            bb[j].add(i);
        }
        cc = new int[n];
        qq = new int[n];
        for (int i = 0; i < n; i++)
            if (cc[i] == 0)
                dfs1(i);
        Arrays.fill(cc, 0);
        int c = 0;
        for (int h = n - 1; h >= 0; h--) {
            int j = qq[h];
            if (cc[j] == 0)
                dfs2(j, ++c);
        }
        pw.println(c);
        for (int i = 0; i < n; i++)
            pw.print(cc[i] + "" "");
        pw.println();
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb); //if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Planets and Kingdoms,Java,"// https://cses.fi/problemset/task/1683
// Planets and Kingdoms
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1683 {
    static ArrayList[] aa, bb;
    static int[] qq, cc;
    static int cnt;
    static int[] stack;
    static void dfs1(int i) {
        int k = 0;
        stack[k++] = i;
        while (k > 0) {
            i = stack[k - 1];
            if (cc[i] == 0) {
                cc[i] = 1;
                ArrayList<Integer> adj = aa[i];
                for (int j : adj)
                    if (cc[j] == 0)
                        stack[k++] = j;
            } else {
                k--;
                if (cc[i] == 1) {
                    cc[i] = 2;
                    qq[cnt++] = i;
                }
            }
        }
    }
    static void dfs2(int j, int c) {
        int k = 0;
        stack[k++] = j; cc[j] = c;
        while (k > 0) {
            j = stack[--k];
            ArrayList<Integer> adj = bb[j];
            for (int i : adj)
                if (cc[i] == 0) {
                    stack[k++] = i; cc[i] = c;
                }
        }
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int m = sc.nextInt();
        aa = new ArrayList[n];
        bb = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            aa[i] = new ArrayList<Integer>();
            bb[i] = new ArrayList<Integer>();
        }
        stack = new int[m];
        while (m-- > 0) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            aa[i].add(j);
            bb[j].add(i);
        }
        cc = new int[n];
        qq = new int[n];
        for (int i = 0; i < n; i++)
            if (cc[i] == 0)
                dfs1(i);
        Arrays.fill(cc, 0);
        int c = 0;
        for (int h = n - 1; h >= 0; h--) {
            int j = qq[h];
            if (cc[j] == 0)
                dfs2(j, ++c);
        }
        pw.println(c);
        for (int i = 0; i < n; i++)
            pw.print(cc[i] + "" "");
        pw.println();
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Planets and Kingdoms,Java,"// https://cses.fi/problemset/task/1683
// Planets and Kingdoms
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1683 {
    static ArrayList[] aa, bb;
    static int[] qq, cc;
    static int cnt;
    static int[] stack;
    static void dfs1(int i) {
        int k = 0;
        stack[k++] = i;
        while (k > 0) {
            i = stack[k - 1];
            if (cc[i] == 0) {
                cc[i] = 1;
                ArrayList<Integer> adj = aa[i];
                for (int j : adj)
                    if (cc[j] == 0)
                        stack[k++] = j;
            } else {
                k--;
                if (cc[i] == 1) {
                    cc[i] = -1;
                    qq[cnt++] = i;
                }
            }
        }
    }
    static void dfs2(int j, int c) {
        int k = 0;
        stack[k++] = j; cc[j] = c;
        while (k > 0) {
            j = stack[--k];
            ArrayList<Integer> adj = bb[j];
            for (int i : adj)
                if (cc[i] == -1) {
                    stack[k++] = i; cc[i] = c;
                }
        }
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int m = sc.nextInt();
        aa = new ArrayList[n];
        bb = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            aa[i] = new ArrayList<Integer>();
            bb[i] = new ArrayList<Integer>();
        }
        stack = new int[Math.max(m + 1, n)];
        while (m-- > 0) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            aa[i].add(j);
            bb[j].add(i);
        }
        cc = new int[n];
        qq = new int[n];
        for (int i = 0; i < n; i++)
            if (cc[i] == 0)
                dfs1(i);
        int c = 0;
        for (int h = n - 1; h >= 0; h--) {
            int j = qq[h];
            if (cc[j] == -1)
                dfs2(j, ++c);
        }
        pw.println(c);
        for (int i = 0; i < n; i++)
            pw.print(cc[i] + "" "");
        pw.println();
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l <= 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Planets and Kingdoms,C++,"/*
 https://cses.fi/problemset/task/1683
 Planets and Kingdoms
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int j;
} aa[N], bb[N];

int cc[N], qq[N];

void link(int i, int j) {
    static struct L l91[M * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
    l->j = i;
    l->next = bb[j].next; bb[j].next = l++;
}

void dfs1(int i) {
    static int cnt;
    struct L *l;
    
    if (cc[i])
        return;
    cc[i] = 1;
    for (l = aa[i].next; l; l = l->next)
        dfs1(l->j);
    qq[cnt++] = i;
}

void dfs2(int j, int c) {
    struct L *l;
    
    if (cc[j])
        return;
    cc[j] = c;
    for (l = bb[j].next; l; l = l->next)
        dfs2(l->j, c);
}

int main() {
    int n, m, h, i, j, c;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j);
    }
    for (i = 0; i < n; i++)
        dfs1(i);
    memset(cc, 0, n * sizeof *cc);
    c = 0;
    for (h = n - 1; h >= 0; h--) {
        i = qq[h];
        if (!cc[i])
            dfs2(i, ++c);
    }
    printf(""%d\n"", c);
    for (i = 0; i < n; i++)
        printf(""%d "", cc[i]);
    printf(""\n"");
    return 0;
}
"
Planets and Kingdoms,C++,"/*
 https://cses.fi/problemset/task/1683
 Planets and Kingdoms
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int j;
} aa[N], bb[N];

int cc[N], qq[N], stack[M];

void link(int i, int j) {
    static struct L l91[M * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
    l->j = i;
    l->next = bb[j].next; bb[j].next = l++;
}

void dfs1(int i) {
    static int cnt;
    struct L *l;
    int k, j;
    
    k = 0;
    stack[k++] = i;
    while (k > 0) {
        i = stack[k - 1];
        if (cc[i] == 0) {
            cc[i] = 1;
            for (l = aa[i].next; l; l = l->next)
                if (!cc[j = l->j])
                    stack[k++] = j;
        } else {
            k--;
            if (cc[i] == 1) {
                cc[i] = 2;
                qq[cnt++] = i;
            }
        }
    }
}

void dfs2(int j, int c) {
    struct L *l;
    int k, i;
    
    k = 0;
    stack[k++] = j; cc[j] = c;
    while (k > 0) {
        j = stack[--k];
        for (l = bb[j].next; l; l = l->next)
            if (!cc[i = l->j]) {
                stack[k++] = i; cc[i] = c;
            }
    }
}

int main() {
    int n, m, h, i, j, c;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j);
    }
    for (i = 0; i < n; i++)
        if (!cc[i])
            dfs1(i);
    memset(cc, 0, n * sizeof *cc);
    c = 0;
    for (h = n - 1; h >= 0; h--) {
        i = qq[h];
        if (!cc[i])
            dfs2(i, ++c);
    }
    printf(""%d\n"", c);
    for (i = 0; i < n; i++)
        printf(""%d "", cc[i]);
    printf(""\n"");
    return 0;
}
"
Planets and Kingdoms,C++,"/*
 https://cses.fi/problemset/task/1683
 Planets and Kingdoms
 practice with Dukkha
 */
#include <stdio.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int j;
} aa[N], bb[N];

int cc[N], qq[N], stack[M + 1];

void link(int i, int j) {
    static struct L l91[M * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
    l->j = i;
    l->next = bb[j].next; bb[j].next = l++;
}

void dfs1(int i) {
    static int cnt;
    struct L *l;
    int k, j;
    
    k = 0;
    stack[k++] = i;
    while (k > 0) {
        i = stack[k - 1];
        if (cc[i] == 0) {
            cc[i] = 1;
            for (l = aa[i].next; l; l = l->next)
                if (!cc[j = l->j])
                    stack[k++] = j;
        } else {
            k--;
            if (cc[i] == 1) {
                cc[i] = -1;
                qq[cnt++] = i;
            }
        }
    }
}

void dfs2(int j, int c) {
    struct L *l;
    int k, i;
    
    k = 0;
    stack[k++] = j, cc[j] = c;
    while (k > 0) {
        j = stack[--k];
        for (l = bb[j].next; l; l = l->next)
            if (cc[i = l->j] == -1)
                stack[k++] = i, cc[i] = c;
    }
}

int main() {
    int n, m, h, i, j, c;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j);
    }
    for (i = 0; i < n; i++)
        if (!cc[i])
            dfs1(i);
    c = 0;
    for (h = n - 1; h >= 0; h--) {
        i = qq[h];
        if (cc[i] == -1)
            dfs2(i, ++c);
    }
    printf(""%d\n"", c);
    for (i = 0; i < n; i++)
        printf(""%d "", cc[i]);
    printf(""\n"");
    return 0;
}
"
Planets Cycles,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,t[MX],vis[MX],ans[MX];
bool inCyc[MX];
vi radj[MX];

int dfs(int a, int b) {
    if (vis[a]) {
        if (vis[a] != b) return 0;
        return a;
    }
    vis[a] = b; return dfs(t[a],b);
}

void dfs2(int i) {
    trav(j,radj[i]) if (!inCyc[j]) {
        ans[j] = ans[i]+1;
        dfs2(j);
    }
}

int main() {
    setIO(); re(n);
    FOR(i,1,n+1) {
        re(t[i]);
        radj[t[i]].pb(i);
    }
    FOR(i,1,n+1) if (!vis[i]) {
        int x = dfs(i,i);
        vi cyc;
        while (vis[x] == i) {
            cyc.pb(x); vis[x] += n;
            x = t[x];
        }
        // ps(cyc);
        trav(t,cyc) {
            inCyc[t] = 1;
            ans[t] = sz(cyc);
        }
    }
    FOR(i,1,n+1) if (inCyc[i]) dfs2(i);
    FOR(i,1,n+1) pr(ans[i],' ');
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Planets Cycles,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vector<vi> treeJump(vi& P){
    int on = 1, d = 1;
    while(on < sz(P)) on *= 2, d++;
    vector<vi> jmp(d, P);
    rep(i,1,d) rep(j,0,sz(P))
    jmp[i][j] = jmp[i-1][jmp[i-1][j]];
    return jmp;
}

int jmp(vector<vi>& tbl, int nod, int steps){
    rep(i,0,sz(tbl))
    if(steps&(1<<i)) nod = tbl[i][nod];
    return nod;
}

int lca(vector<vi>& tbl, vi& depth, int a, int b) {
    if (depth[a] < depth[b]) swap(a, b);
    a = jmp(tbl, a, depth[a] - depth[b]);
    if (a == b) return a;
    for (int i = sz(tbl); i--;) {
        int c = tbl[i][a], d = tbl[i][b];
        if (c != d) a = c, b = d;
    }
    return tbl[0][a];
}

vi p, d, c;
void dfs(int i, int t) {
    c[i]=--t;
    int j=p[i];
    if (c[j]==0) dfs(j, t);
    if (c[j]<0) {
        d[i]=c[i]=c[j]-c[i]+1;
        for(; j!=i; j=p[j])
            c[j]=d[j]=c[i];
        return;
    }
    if (c[i]<0) {
        c[i]=c[j];
        d[i]=d[j]+1;
    }
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    p.resize(n+1);
    d.resize(n+1);
    c.resize(n+1);
    rep(i, 1, n+1) cin >> p[i];
    rep(i, 1, n+1) if(!c[i]) dfs(i, 0);
    rep(i, 1, n+1) cout << d[i] << "" \n""[i==n];
    return 0;
}
"
Planets Cycles,Java,"// https://cses.fi/problemset/task/1751
// Planets Cycles
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1751 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = Integer.parseInt(st.nextToken()) - 1;
        int[] cc = new int[n];
        Arrays.fill(cc, -1);
        int[] dd = new int[n];
        int[] qq = new int[n];
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            if (cc[i] != -1)
                continue;
            int c, d = 0;
            int j = i;
            while (cc[j] == -1) {
                cc[j] = -2;
                d++;
                j = aa[j];
            }
            if (cc[j] == -2) {
                c = cnt++;
                int q = 0;
                while (cc[j] == -2) {
                    cc[j] = c;
                    q++;
                    j = aa[j];
                }
                qq[c] = q;
                d -= q;
            } else {
                c = cc[j];
                d += dd[j];
            }
            j = i;
            while (cc[j] == -2) {
                cc[j] = c;
                dd[j] = d--;
                j = aa[j];
            }
        }
        for (int i = 0; i < n; i++)
            pw.print(dd[i] + qq[cc[i]] + "" "");
        pw.println();
        pw.close();
    }
}
"
Planets Cycles,C++,"/*
 https://cses.fi/problemset/task/1751
 Planets Cycles
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    200000

int main() {
    static int aa[N], cc[N], dd[N], qq[N];
    int n, i, j, c, d, q, cnt;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]), aa[i]--;
    memset(cc, -1, n * sizeof *cc);
    cnt = 0;
    for (i = 0; i < n; i++) {
        if (cc[i] != -1)
            continue;
        d = 0;
        j = i;
        while (cc[j] == -1) {
            cc[j] = -2;
            d++;
            j = aa[j];
        }
        if (cc[j] == -2) {
            c = cnt++;
            q = 0;
            while (cc[j] == -2) {
                cc[j] = c;
                q++;
                j = aa[j];
            }
            qq[c] = q;
            d -= q;
        } else {
            c = cc[j];
            d += dd[j];
        }
        j = i;
        while (cc[j] == -2) {
            cc[j] = c;
            dd[j] = d--;
            j = aa[j];
        }
    }
    for (i = 0; i < n; i++)
        printf(""%d "", dd[i] + qq[cc[i]]);
    printf(""\n"");
    return 0;
}
"
Planets Queries I,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,q;
int anc[MX][30];

int main() {
    re(n,q);
    FOR(i,1,n+1) re(anc[i][0]);
    FOR(j,1,30) FOR(i,1,n+1) anc[i][j] = anc[anc[i][j-1]][j-1];
    F0R(i,q) {
        int x,k; re(x,k);
        F0Rd(j,30) if (k&(1<<j)) x = anc[x][j];
        ps(x);
    }
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Planets Queries I,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,q;
int anc[MX][30];

int main() {
    setIO(); re(n,q);
    FOR(i,1,n+1) re(anc[i][0]);
    FOR(j,1,30) FOR(i,1,n+1) anc[i][j] = anc[anc[i][j-1]][j-1];
    F0R(i,q) {
        int x,k; re(x,k);
        F0Rd(j,30) if (k&(1<<j)) x = anc[x][j];
        ps(x);
    }
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Planets Queries I,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr int D=32;
vector<vi> treeJump(vi& P){
    int d = D;
    vector<vi> jmp(d, P);
    rep(i,1,d) rep(j,0,sz(P))
    jmp[i][j] = jmp[i-1][jmp[i-1][j]];
    return jmp;
}

int jmp(vector<vi>& tbl, int nod, int steps){
    rep(i,0,sz(tbl))
    if(steps&(1<<i)) nod = tbl[i][nod];
    return nod;
}

int lca(vector<vi>& tbl, vi& depth, int a, int b) {
    if (depth[a] < depth[b]) swap(a, b);
    a = jmp(tbl, a, depth[a] - depth[b]);
    if (a == b) return a;
    for (int i = sz(tbl); i--;) {
        int c = tbl[i][a], d = tbl[i][b];
        if (c != d) a = c, b = d;
    }
    return tbl[0][a];
}
int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    vi t(n+1);
    rep(i, 1, n+1) cin >> t[i];
    vector<vi> tbl=treeJump(t);
    while (q--) {
        int a, b;
        cin >> a >> b;
        cout << jmp(tbl, a, b) << '\n';
    }
    return 0;
}
"
Planets Queries I,Java,"// https://cses.fi/problemset/task/1750
// Planets Queries I
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1750 {
    static final int K = 30;
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int q = sc.nextInt();
        int[][] aa = new int[K][n];
        for (int i = 0; i < n; i++)
            aa[0][i] = sc.nextInt() - 1;
        for (int k = 1; k < K; k++)
            for (int i = 0; i < n; i++)
                aa[k][i] = aa[k - 1][aa[k - 1][i]];
        while (q-- > 0) {
            int i = sc.nextInt() - 1;
            int m = sc.nextInt();
            for (int k = K - 1; k >= 0; k--)
                if (1 << k <= m) {
                    i = aa[k][i];
                    m -= 1 << k;
                }
            pw.println(i + 1);
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Planets Queries I,C++,"/*
 https://cses.fi/problemset/task/1750
 Planets Queries I
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define K    30

int main() {
    static int aa[N][K];
    int n, q, i, k, m;
    
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i][0]), aa[i][0]--;
    for (k = 1; k < K; k++)
        for (i = 0; i < n; i++)
            aa[i][k] = aa[aa[i][k - 1]][k - 1];
    while (q--) {
        scanf(""%d%d"", &i, &m), i--;
        for (k = K - 1; k >= 0; k--)
            if (1 << k <= m) {
                i = aa[i][k];
                m -= 1 << k;
            }
        printf(""%d\n"", i + 1);
    }
    return 0;
}
"
Planets Queries I,C++,"/*
 https://cses.fi/problemset/task/1750
 Planets Queries I
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define K    30

int main() {
    static int aa[K][N];
    int n, q, i, k, m;
    
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[0][i]), aa[0][i]--;
    for (k = 1; k < K; k++)
        for (i = 0; i < n; i++)
            aa[k][i] = aa[k - 1][aa[k - 1][i]];
    while (q--) {
        scanf(""%d%d"", &i, &m), i--;
        for (k = K - 1; k >= 0; k--)
            if (1 << k <= m) {
                i = aa[k][i];
                m -= 1 << k;
            }
        printf(""%d\n"", i + 1);
    }
    return 0;
}
"
Planets Queries II,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;
const int MX = 200001;

int n,q,t[MX], ind[MX], depth[MX], comp[MX], nex[MX];
int tmp[MX], par[MX][18];
vi child[MX], adj[MX];
bool incyc[MX];

// not in cyc, not in cyc
// not in cyc, in cyc
// in cyc, not in cyc
// in cyc, in cyc

void dfs(int x) {
    int X = x;
    while (tmp[x] == 0) {
        tmp[x] = X;
        x = t[x];
    }
    while (tmp[x] == X) {
        tmp[x] = X+n; ind[x] = nex[comp[x]]++;
        incyc[x] = 1;
        x = t[x];
    }
}

void DFS(int cur) {
    for (int i: child[cur]) if (!incyc[i]) {
        depth[i] = depth[cur]+1;
        DFS(i);
    }
}

void process() {
    FOR(i,1,n+1) dfs(i);
    FOR(i,1,n+1) par[i][0] = t[i];
    FOR(i,1,18) FOR(j,1,n+1)
    par[j][i] = par[par[j][i-1]][i-1];
    FOR(i,1,n+1) if (incyc[i]) DFS(i);
}

int getPar(int a, int b) {
    F0Rd(i,18) if (b&(1<<i)) a = par[a][i];
    return a;
}

void gencomp(int x, int i) {
    if (comp[x]) return;
    comp[x] = i;
    for (int y: adj[x]) gencomp(y,i);
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> q;
    FOR(i,1,n+1) {
        cin >> t[i];
        child[t[i]].pb(i);
        adj[i].pb(t[i]), adj[t[i]].pb(i);
    }
    FOR(i,1,n+1) if (comp[i] == 0) gencomp(i,i);
    process();
    F0R(i,q) {
        int a,b; cin >> a >> b;
        if (comp[a] != comp[b]) {
            cout << ""-1\n"";
            continue;
        }
        if (!incyc[a]) {
            if (incyc[b]) {
                int x = getPar(a,depth[a]);
                cout << ((ind[b]-ind[x]+nex[comp[a]])%nex[comp[a]])+depth[a];
            } else {
                if (getPar(a,depth[a]-depth[b]) == b) cout << depth[a]-depth[b];
                else cout << -1;
            }
        } else {
            if (incyc[b]) cout << (ind[b]-ind[a]+nex[comp[a]])%nex[comp[a]];
            else cout << -1;
        }
        cout << ""\n"";
    }
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Planets Queries II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vector<vi> treeJump(vi& P){
    int on = 1, d = 1;
    while(on < sz(P)) on *= 2, d++;
    vector<vi> jmp(d, P);
    rep(i,1,d) rep(j,0,sz(P))
    jmp[i][j] = jmp[i-1][jmp[i-1][j]];
    return jmp;
}

int jmp(vector<vi>& tbl, int nod, int steps){
    rep(i,0,sz(tbl))
    if(steps&(1<<i)) nod = tbl[i][nod];
    return nod;
}

int lca(vector<vi>& tbl, vi& depth, int a, int b) {
    if (depth[a] < depth[b]) swap(a, b);
    a = jmp(tbl, a, depth[a] - depth[b]);
    if (a == b) return a;
    for (int i = sz(tbl); i--;) {
        int c = tbl[i][a], d = tbl[i][b];
        if (c != d) a = c, b = d;
    }
    return tbl[0][a];
}

vi p, d, c;
void dfs(int i, int t) {
    c[i]=--t;
    int j=p[i];
    if (c[j]==0) dfs(j, t);
    if (c[j]<0)
        c[i]=c[j]-c[i]+1, d[i]=0;
    else
        c[i]=c[j], d[i]=d[j]+1;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    p.resize(n+1);
    d.resize(n+1);
    c.resize(n+1);
    rep(i, 1, n+1) cin >> p[i];
    rep(i, 1, n+1) if(!c[i]) dfs(i, 0);
    vector<vi> tbl=treeJump(p);
    while (q--) {
        int a,  b;
        cin >> a >> b;
        if (d[b]<=d[a] && jmp(tbl, a, d[a]-d[b])==b)
            cout << d[a]-d[b] << '\n';
        else if (d[b]<c[a] && jmp(tbl, a, d[a]+c[a]-d[b])==b)
            cout << d[a]+c[a]-d[b] << '\n';
        else
            cout << ""-1\n"";
    }
    return 0;
}
"
Planets Queries II,Java,"// https://cses.fi/problemset/task/1160/
// Teleporters
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1160 {
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int q = sc.nextInt();
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = sc.nextInt() - 1;
        int[] mm = new int[1 + n];
        int[] cc = new int[n];
        int[] dd = new int[n];
        int[] hh = new int[n];
        int[][] pp = new int[n][];
        int[] ll = new int[n];
        int c_ = 0;
        int[] bb = new int[n];
        for (int i = 0, j; i < n; i++) {
            if (cc[i] != 0)
                continue;
            j = i;
            while (cc[j] == 0) {
                cc[j] = -1;
                j = aa[j];
            }
            int c, d;
            if (cc[j] == -1) {
                c = ++c_;
                d = 0;
                int h = 0;
                while (cc[j] == -1) {
                    cc[j] = c;
                    hh[j] = h++;
                    j = aa[j];
                }
                mm[c] = h;
            } else {
                c = cc[j];
                d = dd[j];
            }
            j = i;
            int m = 0;
            while (cc[j] == -1) {
                cc[j] = c;
                bb[m++] = j;
                j = aa[j];
            }
            bb[m] = j;
            for (int h = m - 1; h >= 0; h--) {
                j = bb[h];
                int d_ = dd[j] = d + m - h;
                int l = 0;
                while (1 << l + 1 <= d_)
                    l++;
                int[] qq = new int[l + 1];
                qq[0] = bb[h + 1];
                for (int k = 1; k <= l; k++)
                    qq[k] = pp[qq[k - 1]][k - 1];
                pp[j] = qq;
                ll[j] = l;
            }
        }
        while (q-- > 0) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            if (cc[i] != cc[j] || dd[i] < dd[j]) {
                pw.println(-1);
                continue;
            }
            int d = dd[i] - dd[j];
            if (d > 0)
                for (int l = ll[i]; l >= 0; l--)
                    if (1 << l <= dd[i] - dd[j])
                        i = pp[i][l];
            int ans;
            if (dd[i] != 0)
                ans = i == j ? d : -1;
            else {
                int h = hh[j] - hh[i];
                if (h < 0)
                    h += mm[cc[i]];
                ans = d + h;
            }
            pw.println(ans);
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb); //if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        String next() throws IOException {
            StringBuilder sb = new StringBuilder();
            for (byte b = skip(); b > 32; b = getc())
                sb.append((char) b);
            return sb.toString();
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Planets Queries II,Java,"// https://cses.fi/problemset/task/1160/
// Teleporters
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1160 {
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int q = sc.nextInt();
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = sc.nextInt() - 1;
        int[] mm = new int[1 + n];
        int[] cc = new int[n];
        int[] dd = new int[n];
        int[] hh = new int[n];
        int[][] pp = new int[n][];
        int[] ll = new int[n];
        int c_ = 0;
        int[] bb = new int[n];
        for (int i = 0, j; i < n; i++) {
            if (cc[i] != 0)
                continue;
            j = i;
            while (cc[j] == 0) {
                cc[j] = -1;
                j = aa[j];
            }
            int c, d;
            if (cc[j] == -1) {
                c = ++c_;
                d = 0;
                int h = 0;
                while (cc[j] == -1) {
                    cc[j] = c;
                    hh[j] = h++;
                    j = aa[j];
                }
                mm[c] = h;
            } else {
                c = cc[j];
                d = dd[j];
            }
            j = i;
            int m = 0;
            while (cc[j] == -1) {
                cc[j] = c;
                bb[m++] = j;
                j = aa[j];
            }
            bb[m] = j;
            for (int h = m - 1; h >= 0; h--) {
                j = bb[h];
                int d_ = dd[j] = d + m - h;
                int l = 0;
                while (1 << l + 1 <= d_)
                    l++;
                int[] qq = new int[l + 1];
                qq[0] = bb[h + 1];
                for (int k = 1; k <= l; k++)
                    qq[k] = pp[qq[k - 1]][k - 1];
                pp[j] = qq;
                ll[j] = l;
            }
        }
        while (q-- > 0) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            if (cc[i] != cc[j] || dd[i] < dd[j]) {
                pw.println(-1);
                continue;
            }
            int d = dd[i] - dd[j];
            if (d > 0)
                for (int l = ll[i]; l >= 0; l--)
                    if (1 << l <= dd[i] - dd[j])
                        i = pp[i][l];
            int ans;
            if (dd[i] != 0)
                ans = i == j ? d : -1;
            else {
                int h = hh[j] - hh[i];
                if (h < 0)
                    h += mm[cc[i]];
                ans = d + h;
            }
            pw.println(ans);
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Planets Queries II,C++,"/*
 https://cses.fi/problemset/task/1160
 Teleporters
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>

#define N    200000

int main() {
    static int aa[N], cc[N], mm[1 + N], dd[N], hh[N], *pp[N], ll[N], bb[N];
    int *qq, n, q, h, i, j, k, l, m, c, c_, d, d_;
    
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]), aa[i]--;
    c_ = 0;
    for (i = 0; i < n; i++) {
        if (cc[i])
            continue;
        j = i;
        while (!cc[j]) {
            cc[j] = -1;
            j = aa[j];
        }
        if (cc[j] == -1) {
            c = ++c_;
            d = 0;
            h = 0;
            while (cc[j] == -1) {
                cc[j] = c;
                hh[j] = h++;
                j = aa[j];
            }
            mm[c] = h;
        } else {
            c = cc[j];
            d = dd[j];
        }
        j = i;
        m = 0;
        while (cc[j] == -1) {
            cc[j] = c;
            bb[m++] = j;
            j = aa[j];
        }
        bb[m] = j;
        for (h = m - 1; h >= 0; h--) {
            j = bb[h];
            d_ = dd[j] = d + m - h;
            l = 0;
            while (1 << (l + 1) <= d_)
                l++;
            qq = (int *) malloc((l + 1) * sizeof *qq);
            qq[0] = bb[h + 1];
            for (k = 1; k <= l; k++)
                qq[k] = pp[qq[k - 1]][k - 1];
            pp[j] = qq;
            ll[j] = l;
        }
    }
    while (q--) {
        int ans;
        
        scanf(""%d%d"", &i, &j), i--, j--;
        if (cc[i] != cc[j] || dd[i] < dd[j]) {
            printf(""-1\n"");
            continue;
        }
        d = dd[i] - dd[j];
        if (d)
            for (l = ll[i]; l >= 0; l--)
                if (1 << l <= dd[i] - dd[j])
                    i = pp[i][l];
        ans = 0;
        if (dd[i])
            ans = i == j ? d : -1;
        else {
            h = hh[j] - hh[i];
            if (h < 0)
                h += mm[cc[i]];
            ans = d + h;
        }
        printf(""%d\n"", ans);
    }
    return 0;
}
"
Police Chase,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<int SZ> struct Dinic {
    struct Edge { int v, rev; ll flow, cap; };
    
    vector<Edge> adj[SZ];
    
    void addEdge(int u, int v, ll cap) {
        Edge a{v, sz(adj[v]), 0, cap}, b{u, sz(adj[u]), 0, 0};
        adj[u].pb(a), adj[v].pb(b);
    }
    
    int ST, EN, level[SZ], ind[SZ];
    
    bool bfs() { // level = shortest distance from source
        // after computing flow, edges {u,v} such that level[u] \neq -1, level[v] = -1 are part of min cut
        F0R(i,SZ) level[i] = -1, ind[i] = 0;
        level[ST] = 0;
        
        queue<int> q; q.push(ST);
        while (sz(q)) {
            int u = q.front(); q.pop();
            trav(e,adj[u]) if (level[e.v] < 0 && e.flow < e.cap) {
                level[e.v] = level[u] + 1;
                q.push(e.v);
            }
        }
        
        return level[EN] >= 0;
    }
    
    ll sendFlow(int s, ll flow) {
        if (s == EN) return flow;
        
        for (  ; ind[s] < sz(adj[s]); ind[s] ++) {
            Edge& e = adj[s][ind[s]];
            
            if (level[e.v] != level[s]+1 || e.flow == e.cap) continue;
            ll f = sendFlow(e.v, min(flow, e.cap - e.flow));
            
            if (f) { // saturate at least one edge
                e.flow += f; adj[e.v][e.rev].flow -= f;
                return f;
            }
        }
        
        return 0;
    }
    
    ll maxFlow(int _ST, int _EN) {
        ST = _ST, EN = _EN;
        if (ST == EN) return -1;
        ll tot = 0;
        while (bfs()) while (auto flow = sendFlow(ST, LLONG_MAX)) tot += flow;
        return tot;
    }
};

Dinic<501> D;
int n,m;

int main() {
    setIO(); re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        /*if (a == 1 && b == 101) continue;
         if (a == 1 && b == 2) continue;
         if (a == 1 && b == 68) continue;
         if (a == 1 && b == 5) continue;*/
        D.addEdge(a,b,1); D.addEdge(b,a,1);
    }
    ps(D.maxFlow(1,n));
    FOR(i,1,n+1) trav(t,D.adj[i]) if (D.level[i] >= 0 && D.level[t.v] < 0 && t.cap > 0) ps(i,t.v);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Police Chase,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

template<class T> T edmondsKarp(vector<unordered_map<int, T>>& graph, int source, int sink) {
    assert(source != sink);
    T flow = 0;
    vi par(sz(graph)), q = par;
    
    for (;;) {
        fill(all(par), -1);
        par[source] = 0;
        int ptr = 1;
        q[0] = source;
        
        rep(i,0,ptr) {
            int x = q[i];
            trav(e, graph[x]) {
                if (par[e.first] == -1 && e.second > 0) {
                    par[e.first] = x;
                    q[ptr++] = e.first;
                    if (e.first == sink) goto out;
                }
            }
        }
        return flow;
    out:
        T inc = numeric_limits<T>::max();
        for (int y = sink; y != source; y = par[y])
            inc = min(inc, graph[par[y]][y]);
        
        flow += inc;
        for (int y = sink; y != source; y = par[y]) {
            int p = par[y];
            if ((graph[p][y] -= inc) <= 0) graph[p].erase(y);
            graph[y][p] += inc;
        }
    }
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<unordered_map<int, int>> g(n+1), gc;
    rep(i, 0, m) {
        int a, b;
        cin >> a >> b;
        g[a][b]++, g[b][a]++;
    }
    gc=g;
    cout << edmondsKarp<int>(g, 1, n) << '\n';
    vi v(n+1);
    function<void(int)> dfs=[&](int i) {
        v[i]=1;
        trav(p, g[i]) if (!v[p.first]) dfs(p.first);
    };
    dfs(1);
    rep(i, 1, n+1) trav(p, gc[i])
    if(v[i] && !v[p.first])
        cout << i << "" "" << p.first << '\n';
    return 0;
}
"
Police Chase,Java,"// https://cses.fi/problemset/task/1695
// Police Chase
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1695 {
    static ArrayList[] aa;
    static int[] dd, qq;
    static int[] ij, cc;
    static boolean bfs(int n, int s, int t) {
        Arrays.fill(dd, n);
        dd[s] = 0;
        int head = 0, cnt = 0;
        qq[head + cnt++] = s;
        while (cnt > 0) {
            int i = qq[head++]; cnt--;
            int d = dd[i] + 1;
            ArrayList<Integer> adj = aa[i];
            for (int h : adj)
                if (cc[h] != 0) {
                    int j = i ^ ij[h >> 2];
                    if (dd[j] == n) {
                        dd[j] = d;
                        if (j == t)
                            return true;
                        qq[head + cnt++] = j;
                    }
                }
        }
        return false;
    }
    static boolean dfs(int n, int i, int t) {
        if (i == t)
            return true;
        int d = dd[i] + 1;
        ArrayList<Integer> adj = aa[i];
        for (int h : adj)
            if (cc[h] != 0) {
                int j = i ^ ij[h >> 2];
                if (dd[j] == d && dfs(n, j, t)) {
                    cc[h]--;
                    cc[h ^ 1]++;
                    return true;
                }
            }
        dd[i] = n;
        return false;
    }
    static int dinic(int n, int s, int t) {
        dd = new int[n];
        qq = new int[n];
        int f = 0;
        while (bfs(n, s, t))
            while (dfs(n, s, t))
                f++;
        return f;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        ij = new int[m];
        cc = new int[m * 4];
        for (int h = 0; h < m; h++) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            ij[h] = i ^ j;
            cc[h * 4 + 0] = 1;
            cc[h * 4 + 2] = 1;
            aa[i].add(h * 4 + 0);
            aa[j].add(h * 4 + 1);
            aa[j].add(h * 4 + 2);
            aa[i].add(h * 4 + 3);
        }
        pw.println(dinic(n, 0, n - 1));
        for (int i = 0; i < n; i++)
            if (dd[i] < n) {
                ArrayList<Integer> adj = aa[i];
                for (int h : adj) {
                    int j = i ^ ij[h >> 2];
                    if (dd[j] == n && (h & 1) == 0)
                        pw.println((i + 1) + "" "" + (j + 1));
                }
            }
        pw.close();
    }
}
"
Police Chase,C++,"/*
 https://cses.fi/problemset/task/1695
 Police Chase
 practice with Dukkha
 */
#include <stdio.h>

#define N    500
#define M    1000

struct L {
    struct L *next;
    int h;
} aa[N];

int ij[M], cc[M * 4];
int dd[N];

void link(int i, int h) {
    static struct L l91[M * 4], *l = l91;
    
    l->h = h;
    l->next = aa[i].next; aa[i].next = l++;
}

int bfs(int n, int s, int t) {
    static int qq[N];
    int h, i, j, head, cnt, d;
    
    for (i = 0; i < n; i++)
        dd[i] = n;
    dd[s] = 0;
    head = cnt = 0;
    qq[head + cnt++] = s;
    while (cnt) {
        struct L *l;
        
        i = qq[cnt--, head++];
        d = dd[i] + 1;
        for (l = aa[i].next; l; l = l->next)
            if (cc[h = l->h]) {
                j = i ^ ij[h >> 2];
                if (dd[j] == n) {
                    dd[j] = d;
                    if (j == t)
                        return 1;
                    qq[head + cnt++] = j;
                }
            }
    }
    return 0;
}

int dfs(int n, int i, int t) {
    struct L *l;
    int h, j, d;
    
    if (i == t)
        return 1;
    d = dd[i] + 1;
    for (l = aa[i].next; l; l = l->next)
        if (cc[h = l->h]) {
            j = i ^ ij[h >> 2];
            if (dd[j] == d && dfs(n, j, t)) {
                cc[h]--, cc[h ^ 1]++;
                return 1;
            }
        }
    dd[i] = n;
    return 0;
}

int dinic(int n, int s, int t) {
    int f = 0;
    
    while (bfs(n, s, t))
        while (dfs(n, s, t))
            f++;
    return f;
}

int main() {
    int n, m, h, i, j;
    
    scanf(""%d%d"", &n, &m);
    for (h = 0; h < m; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        ij[h] = i ^ j;
        cc[h * 4 + 0] = 1;
        cc[h * 4 + 2] = 1;
        link(i, h * 4 + 0);
        link(j, h * 4 + 1);
        link(j, h * 4 + 2);
        link(i, h * 4 + 3);
    }
    printf(""%d\n"", dinic(n, 0, n - 1));
    for (i = 0; i < n; i++)
        if (dd[i] < n) {
            struct L *l;
            
            for (l = aa[i].next; l; l = l->next) {
                h = l->h;
                j = i ^ ij[h >> 2];
                if (dd[j] == n && (h & 1) == 0)
                    printf(""%d %d\n"", i + 1, j + 1);
            }
        }
    return 0;
}
"
Road Construction,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int res = 0, numEdge;

template<int SZ> struct DSU {
    int par[SZ], sz[SZ];
    
    DSU() {
        F0R(i,SZ) par[i] = i, sz[i] = 1;
    }
    
    int get(int x) { // path compression
        if (par[x] != x) par[x] = get(par[x]);
        return par[x];
    }
    
    bool unite(int x, int y) { // union-by-rank
        x = get(x), y = get(y);
        if (x == y) return 0;
        if (sz[x] < sz[y]) swap(x,y);
        sz[x] += sz[y], par[y] = x;
        ckmax(res,sz[x]); numEdge ++;
        return 1;
    }
};

// computes the minimum spanning tree in O(ElogE) time

int cnt = 0;

template<class T> T kruskal(vector<pair<T,pi>> edge) {
    sort(all(edge));
    T ans = 0; DSU<MX> D;
    trav(a,edge) if (D.unite(a.s.f,a.s.s)) {
        ans += a.f; // edge is in MST
        cnt ++;
    }
    return ans;
}

int n,m;
vector<pair<ll,pi>> ed;

DSU<MX> D;

int main() {
    setIO(); re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        D.unite(a,b);
        ps(n-numEdge,res);
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Road Construction,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

struct UF {
    vi e;
    UF(int n) : e(n, -1) {}
    bool same_set(int a, int b) { return find(a) == find(b); }
    int size(int x) { return -e[find(x)]; }
    int find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }
    bool join(int a, int b) {
        a = find(a), b = find(b);
        if (a == b) return false;
        if (e[a] > e[b]) swap(a, b);
        e[a] += e[b]; e[b] = a;
        return true;
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    int nc=n, s=1;
    UF uf(n);
    while (q--) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        nc-=uf.join(a, b);
        s=max(s, uf.size(a));
        cout << nc << "" "" << s << '\n';
    }
    return 0;
}
"
Road Construction,Java,"// https://cses.fi/problemset/task/1676
// Road Construction
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1676 {
    static int[] dsu;
    static int find(int i) {
        return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));
    }
    static int join(int i, int j) {
        i = find(i);
        j = find(j);
        if (i == j)
            return 0;
        if (dsu[i] < dsu[j]) {
            int tmp = i; i = j; j = tmp;
        }
        dsu[j] += dsu[i];
        dsu[i] = j;
        return -dsu[j];
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        dsu = new int[n];
        Arrays.fill(dsu, -1);
        int c_ = 1;
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            int c = join(i, j);
            if (c != 0) {
                n--;
                if (c_ < c)
                    c_ = c;
            }
            pw.println(n + "" "" + c_);
        }
        pw.close();
    }
}
"
Road Construction,C++,"/*
 https://cses.fi/problemset/task/1676
 Road Construction
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100000

int dsu[N];

int find(int i) {
    return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));
}

int join(int i, int j) {
    int tmp;
    
    i = find(i);
    j = find(j);
    if (i == j)
        return 0;
    if (dsu[i] < dsu[j])
        tmp = i, i = j, j = tmp;
    dsu[j] += dsu[i];
    dsu[i] = j;
    return -dsu[j];
}

int main() {
    int n, m, i, j, c, c_;
    
    scanf(""%d%d"", &n, &m);
    memset(dsu, -1, n * sizeof *dsu);
    c_ = 1;
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        c = join(i, j);
        if (c != 0) {
            n--;
            if (c_ < c)
                c_ = c;
        }
        printf(""%d %d\n"", n, c_);
    }
    return 0;
}
"
Road Reparation,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<int SZ> struct DSU {
    int par[SZ], sz[SZ];
    
    DSU() {
        F0R(i,SZ) par[i] = i, sz[i] = 1;
    }
    
    int get(int x) { // path compression
        if (par[x] != x) par[x] = get(par[x]);
        return par[x];
    }
    
    bool unite(int x, int y) { // union-by-rank
        x = get(x), y = get(y);
        if (x == y) return 0;
        if (sz[x] < sz[y]) swap(x,y);
        sz[x] += sz[y], par[y] = x;
        return 1;
    }
};

// computes the minimum spanning tree in O(ElogE) time

int cnt = 0;

template<class T> T kruskal(vector<pair<T,pi>> edge) {
    sort(all(edge));
    T ans = 0; DSU<MX> D;
    trav(a,edge) if (D.unite(a.s.f,a.s.s)) {
        ans += a.f; // edge is in MST
        cnt ++;
    }
    return ans;
}

int n,m;
vector<pair<ll,pi>> ed;

int main() {
    setIO(); re(n,m);
    F0R(i,m) {
        int a,b,c; re(a,b,c);
        ed.pb({c,{a,b}});
    }
    ll t = kruskal(ed);
    if (cnt == n-1) ps(t);
    else ps(""IMPOSSIBLE"");
    
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Road Reparation,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

struct UF {
    vi e;
    UF(int n) : e(n, -1) {}
    bool same_set(int a, int b) { return find(a) == find(b); }
    int size(int x) { return -e[find(x)]; }
    int find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }
    bool join(int a, int b) {
        a = find(a), b = find(b);
        if (a == b) return false;
        if (e[a] > e[b]) swap(a, b);
        e[a] += e[b]; e[b] = a;
        return true;
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<tuple<int, int, int>> e;
    while (m--) {
        int a, b, c;
        cin >> a >> b >> c;
        e.push_back({c, a, b});
    }
    sort(all(e));
    ll nc=n, s=0;
    UF uf(n+1);
    trav(p, e) {
        int a, b, c;
        tie(c, a, b)=p;
        if(uf.join(a, b))
            nc--, s+=c;
    }
    if (nc>1) cout << ""IMPOSSIBLE\n"";
    else cout << s << '\n';
    return 0;
}
"
Road Reparation,Java,"// https://cses.fi/problemset/task/1675
// Road Reparation
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1675 {
    static class E {
        int i, j, w;
        E(int i, int j, int w) {
            this.i = i; this.j = j; this.w = w;
        }
    }
    static int[] dsu;
    static int find(int i) {
        return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));
    }
    static boolean join(int i, int j) {
        i = find(i);
        j = find(j);
        if (i == j)
            return false;
        if (dsu[i] > dsu[j])
            dsu[i] = j;
        else {
            if (dsu[i] == dsu[j])
                dsu[i]--;
            dsu[j] = i;
        }
        return true;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        dsu = new int[n];
        Arrays.fill(dsu, -1);
        E[] ee = new E[m];
        for (int h = 0; h < m; h++) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            int w = Integer.parseInt(st.nextToken());
            ee[h] = new E(i, j, w);
        }
        Arrays.sort(ee, (e, f) -> e.w - f.w);
        long w = 0;
        for (int h = 0; h < m && n > 1; h++) {
            E e = ee[h];
            if (join(e.i, e.j)) {
                w += e.w;
                n--;
            }
        }
        System.out.println(n == 1 ? w : ""IMPOSSIBLE"");
    }
}
"
Road Reparation,C++,"/*
 https://cses.fi/problemset/task/1675
 Road Reparation
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>

#define N    100000
#define M    200000

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

struct E {
    int i, j, w;
} ee[M];

int compare(const void *a, const void *b) {
    struct E *e = (struct E *) a;
    struct E *f = (struct E *) b;
    
    return e->w - f->w;
}

int dsu[N];

int find(int i) {
    return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));
}

int join(int i, int j) {
    i = find(i);
    j = find(j);
    if (i == j)
        return 0;
    if (dsu[i] > dsu[j])
        dsu[i] = j;
    else {
        if (dsu[i] == dsu[j])
            dsu[i]--;
        dsu[j] = i;
    }
    return 1;
}

int main() {
    int n, m, h, h_;
    long long ans;
    struct E *e, tmp;
    
    scanf(""%d%d"", &n, &m);
    for (h = 0; h < m; h++) {
        e = &ee[h];
        scanf(""%d%d%d"", &e->i, &e->j, &e->w), e->i--, e->j--;
    }
    init_rand();
    for (h = 0; h < m; h++) {
        h_ = rand_(h + 1);
        tmp = ee[h], ee[h] = ee[h_], ee[h_] = tmp;
    }
    qsort(ee, m, sizeof *ee, compare);
    memset(dsu, -1, n * sizeof *dsu);
    ans = 0;
    for (h = 0; h < m && n > 1; h++) {
        e = &ee[h];
        if (join(e->i, e->j)) {
            ans += e->w;
            n--;
        }
    }
    if (n > 1)
        printf(""IMPOSSIBLE\n"");
    else
        printf(""%lld\n"", ans);
    return 0;
}
"
Round Trip,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<int SZ> struct DSU {
    int par[SZ], sz[SZ];
    
    DSU() {
        F0R(i,SZ) par[i] = i, sz[i] = 1;
    }
    
    int get(int x) { // path compression
        if (par[x] != x) par[x] = get(par[x]);
        return par[x];
    }
    
    bool unite(int x, int y) { // union-by-rank
        x = get(x), y = get(y);
        if (x == y) return 0;
        if (sz[x] < sz[y]) swap(x,y);
        sz[x] += sz[y], par[y] = x;
        return 1;
    }
};

int pre[MX];
vi adj[MX];

void dfs(int x) {
    trav(t,adj[x]) if (t != pre[x]) {
        pre[t] = x;
        dfs(t);
    }
}

void fin(int x) {
    vi v;
    while (x) {
        v.pb(x);
        x = pre[x];
    }
    ps(sz(v)+1);
    trav(t,v) pr(t,' ');
    pr(v[0]);
    exit(0);
}

int n,m;
DSU<MX> D;

int main() {
    setIO(); re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        if (!D.unite(a,b)) {
            dfs(a);
            fin(b);
        }
        adj[a].pb(b), adj[b].pb(a);
    }
    ps(""IMPOSSIBLE"");
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Round Trip,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vector<vi> g;
vi s{0}, si, ans;

int dfs(int i, int p) {
    si[i]=sz(s);
    s.push_back(i);
    trav(j, g[i]) if (j!=p) {
        int w=si[j];
        if (w) {
            s.push_back(j);
            ans=vi(begin(s)+w, end(s));
            return 1;
        }
        if (dfs(j, i)) return 1;
    }
    s.pop_back();
    return 0;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    g.resize(n+1);
    si.resize(n+1);
    while (m--) {
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    rep(i, 1, n+1) if (!si[i] && dfs(i, 0)) {
        m=sz(ans);
        cout << m << '\n';
        rep(i, 0, m)
        cout << ans[i] << "" \n""[i==m-1];
        return 0;
    }
    cout << ""IMPOSSIBLE\n"";
    return 0;
}
"
Round Trip,Java,"// https://cses.fi/problemset/task/1669
// Round Trip
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1669 {
    static ArrayList[] aa;
    static int[] pp;
    static int[] qq;
    static int cnt;
    static boolean dfs(int i) {
        ArrayList<Integer> adj = aa[i];
        for (int j : adj) {
            if (pp[j] == -1) {
                pp[j] = i;
                if (dfs(j))
                    return true;
            } else if (j != pp[i]) {
                qq[cnt++] = j;
                while (i != j) {
                    qq[cnt++] = i;
                    i = pp[i];
                }
                qq[cnt++] = j;
                return true;
            }
        }
        return false;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            aa[i].add(j);
            aa[j].add(i);
        }
        pp = new int[n];
        Arrays.fill(pp, -1);
        qq = new int[n];
        for (int i = 0; i < n; i++)
            if (pp[i] == -1) {
                pp[i] = i;
                if (dfs(i))
                    break;
            }
        if (cnt == 0)
            pw.println(""IMPOSSIBLE"");
        else {
            pw.println(cnt);
            while (cnt-- > 0)
                pw.print(qq[cnt] + 1 + "" "");
            pw.println();
        }
        pw.close();
    }
}
"
Round Trip,Java,"// https://cses.fi/problemset/task/1669
// Round Trip
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1669 {
    static ArrayList[] aa;
    static int[] pp;
    static int[] qq;
    static int cnt;
    static boolean dfs(int i) {
        ArrayList<Integer> adj = aa[i];
        for (int j : adj) {
            if (pp[j] == -1) {
                pp[j] = i;
                if (dfs(j))
                    return true;
            } else if (j != pp[i]) {
                qq[cnt++] = j;
                while (i != j) {
                    qq[cnt++] = i;
                    i = pp[i];
                }
                qq[cnt++] = j;
                return true;
            }
        }
        return false;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            aa[i].add(j);
            aa[j].add(i);
        }
        pp = new int[n];
        Arrays.fill(pp, -1);
        qq = new int[n + 1];
        for (int i = 0; i < n; i++)
            if (pp[i] == -1) {
                pp[i] = i;
                if (dfs(i))
                    break;
            }
        if (cnt == 0)
            pw.println(""IMPOSSIBLE"");
        else {
            pw.println(cnt);
            while (cnt-- > 0)
                pw.print(qq[cnt] + 1 + "" "");
            pw.println();
        }
        pw.close();
    }
}
"
Round Trip,C++,"/*
 https://cses.fi/problemset/task/1669
 Round Trip
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int j;
} aa[N];

void link(int i, int j) {
    static struct L l91[M * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

int pp[N], qq[N + 1], cnt;

int dfs(int i) {
    struct L *l;
    int j;
    
    for (l = aa[i].next; l; l = l->next)
        if (pp[j = l->j] == -1) {
            pp[j] = i;
            if (dfs(j))
                return 1;
        } else if (j != pp[i]) {
            cnt = 0;
            qq[cnt++] = j;
            while (i != j) {
                qq[cnt++] = i;
                i = pp[i];
            }
            qq[cnt++] = j;
            return 1;
        }
    return 0;
}

int main() {
    int n, m, i, j;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), link(j, i);
    }
    memset(pp, -1, sizeof pp);
    for (i = 0; i < n; i++)
        if (pp[i] == -1) {
            pp[i] = i;
            if (dfs(i))
                break;
        }
    if (cnt == 0) {
        printf(""IMPOSSIBLE\n"");
        return 0;
    }
    printf(""%d\n"", cnt);
    while (cnt--)
        printf(""%d "", qq[cnt] + 1);
    printf(""\n"");
    return 0;
}
"
Round Trip II,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

vi adj[MX];
bool vis[MX], st[MX];
vi sta;
int n,m;

void dfs(int x) {
    st[x] = vis[x] = 1; sta.pb(x);
    // ps(""HUH"",x);
    trav(t,adj[x]) {
        if (!vis[t]) dfs(t);
        else if (st[t]) {
            vi v; while (sta.back() != t) v.pb(sta.back()), sta.pop_back();
            v.pb(t);
            v.pb(x);
            reverse(all(v));
            ps(sz(v));
            trav(z,v) pr(z,' ');
            exit(0);
        }
    }
    st[x] = 0; sta.pop_back();
}

int main() {
    setIO(); re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        adj[a].pb(b);
    }
    FOR(i,1,n+1) if (!vis[i]) dfs(i);
    ps(""IMPOSSIBLE"");
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Round Trip II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vector<vi> g;
vi v, s{0}, ans;

int dfs(int i) {
    v[i]=sz(s);
    s.push_back(i);
    trav(j, g[i]) {
        if (v[j]>0) {
            ans=vi(begin(s)+v[j], end(s));
            return 1;
        }
        if (v[j]==0 && dfs(j))
            return 1;
    }
    v[i]=-1;
    s.pop_back();
    return 0;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    g.resize(n+1);
    v.resize(n+1);
    while (m--) {
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
    }
    rep(i, 1, n+1)
    if (v[i]==0 && dfs(i)) break;
    if (!sz(ans))
        cout << ""IMPOSSIBLE\n"";
    else {
        cout << sz(ans)+1 << '\n';
        trav(i, ans) cout << i << "" "";
        cout << ans[0] << '\n';
    }
    return 0;
}
"
Round Trip II,Java,"// https://cses.fi/problemset/task/1678
// Round Trip II
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1678 {
    static ArrayList[] aa;
    static int[] pp, qq;
    static int cnt;
    static boolean[] instack;
    static boolean dfs(int i) {
        instack[i] = true;
        ArrayList<Integer> adj = aa[i];
        for (int j : adj)
            if (pp[j] == -1) {
                pp[j] = i;
                if (dfs(j))
                    return true;
            } else if (instack[j]) {
                cnt = 0;
                qq[cnt++] = j;
                while (i != j) {
                    qq[cnt++] = i;
                    i = pp[i];
                }
                qq[cnt++] = j;
                return true;
            }
        instack[i] = false;
        return false;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            aa[i].add(j);
        }
        instack = new boolean[n];
        pp = new int[n];
        Arrays.fill(pp, -1);
        qq = new int[n + 1];
        for (int i = 0; i < n; i++)
            if (pp[i] == -1) {
                pp[i] = i;
                if (dfs(i))
                    break;
            }
        if (cnt == 0)
            pw.println(""IMPOSSIBLE"");
        else {
            pw.println(cnt);
            while (cnt-- > 0)
                pw.print(qq[cnt] + 1 + "" "");
            pw.println();
        }
        pw.close();
    }
}
"
Round Trip II,C++,"/*
 https://cses.fi/problemset/task/1678
 Round Trip II
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int j;
} aa[N];

void link(int i, int j) {
    static struct L l91[M], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

int pp[N], qq[N], cnt;

int dfs(int i) {
    static char instack[N];
    struct L *l;
    int j;
    
    instack[i] = 1;
    for (l = aa[i].next; l; l = l->next)
        if (pp[j = l->j] == -1) {
            pp[j] = i;
            if (dfs(j))
                return 1;
        } else if (instack[j]) {
            cnt = 0;
            qq[cnt++] = j;
            while (i != j) {
                qq[cnt++] = i;
                i = pp[i];
            }
            qq[cnt++] = j;
            return 1;
        }
    instack[i] = 0;
    return 0;
}

int main() {
    int n, m, i, j;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j);
    }
    memset(pp, -1, n * sizeof *pp);
    for (i = 0; i < n; i++)
        if (pp[i] == -1) {
            pp[i] = i;
            if (dfs(i))
                break;
        }
    if (cnt == 0)
        printf(""IMPOSSIBLE\n"");
    else {
        printf(""%d\n"", cnt);
        while (cnt--)
            printf(""%d "", qq[cnt] + 1);
        printf(""\n"");
    }
    return 0;
}
"
Round Trip II,C++,"/*
 https://cses.fi/problemset/task/1678
 Round Trip II
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int j;
} aa[N];

void link(int i, int j) {
    static struct L l91[M], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

int pp[N], qq[N + 1], cnt;

int dfs(int i) {
    static char instack[N];
    struct L *l;
    int j;
    
    instack[i] = 1;
    for (l = aa[i].next; l; l = l->next)
        if (pp[j = l->j] == -1) {
            pp[j] = i;
            if (dfs(j))
                return 1;
        } else if (instack[j]) {
            cnt = 0;
            qq[cnt++] = j;
            while (i != j) {
                qq[cnt++] = i;
                i = pp[i];
            }
            qq[cnt++] = j;
            return 1;
        }
    instack[i] = 0;
    return 0;
}

int main() {
    int n, m, i, j;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j);
    }
    memset(pp, -1, n * sizeof *pp);
    for (i = 0; i < n; i++)
        if (pp[i] == -1) {
            pp[i] = i;
            if (dfs(i))
                break;
        }
    if (cnt == 0)
        printf(""IMPOSSIBLE\n"");
    else {
        printf(""%d\n"", cnt);
        while (cnt--)
            printf(""%d "", qq[cnt] + 1);
        printf(""\n"");
    }
    return 0;
}
"
School Dance,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<int SZ> struct Dinic {
    struct Edge { int v, rev; ll flow, cap; };
    
    vector<Edge> adj[SZ];
    
    void addEdge(int u, int v, ll cap) {
        Edge a{v, sz(adj[v]), 0, cap}, b{u, sz(adj[u]), 0, 0};
        adj[u].pb(a), adj[v].pb(b);
    }
    
    int ST, EN, level[SZ], ind[SZ];
    
    bool bfs() { // level = shortest distance from source
        // after computing flow, edges {u,v} such that level[u] \neq -1, level[v] = -1 are part of min cut
        F0R(i,SZ) level[i] = -1, ind[i] = 0;
        level[ST] = 0;
        
        queue<int> q; q.push(ST);
        while (sz(q)) {
            int u = q.front(); q.pop();
            trav(e,adj[u]) if (level[e.v] < 0 && e.flow < e.cap) {
                level[e.v] = level[u] + 1;
                q.push(e.v);
            }
        }
        
        return level[EN] >= 0;
    }
    
    ll sendFlow(int s, ll flow) {
        if (s == EN) return flow;
        
        for (  ; ind[s] < sz(adj[s]); ind[s] ++) {
            Edge& e = adj[s][ind[s]];
            
            if (level[e.v] != level[s]+1 || e.flow == e.cap) continue;
            ll f = sendFlow(e.v, min(flow, e.cap - e.flow));
            
            if (f) { // saturate at least one edge
                e.flow += f; adj[e.v][e.rev].flow -= f;
                return f;
            }
        }
        
        return 0;
    }
    
    ll maxFlow(int _ST, int _EN) {
        ST = _ST, EN = _EN;
        if (ST == EN) return -1;
        ll tot = 0;
        while (bfs()) while (auto flow = sendFlow(ST, LLONG_MAX)) tot += flow;
        return tot;
    }
};

Dinic<1002> D;
int n,m,k;

int main() {
    setIO(); re(n,m,k);
    F0R(i,k) {
        int a,b; re(a,b);
        D.addEdge(a,b+n,1);
    }
    FOR(i,1,n+1) D.addEdge(0,i,1);
    FOR(i,1,m+1) D.addEdge(i+n,n+m+1,1);
    ps(D.maxFlow(0,n+m+1));
    FOR(i,1,n+1) trav(t,D.adj[i]) if (t.flow > 0) ps(i,t.v-n);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
School Dance,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

bool find(int j, vector<vi>& g, vi& btoa, vi& vis) {
    if (btoa[j] == -1) return 1;
    vis[j] = 1; int di = btoa[j];
    trav(e, g[di])
    if (!vis[e] && find(e, g, btoa, vis)) {
        btoa[e] = di;
        return 1;
    }
    return 0;
}
int dfsMatching(vector<vi>& g, vi& btoa) {
    vi vis;
    rep(i,0,sz(g)) {
        vis.assign(sz(btoa), 0);
        trav(j,g[i])
        if (find(j, g, btoa, vis)) {
            btoa[j] = i;
            break;
        }
    }
    return sz(btoa) - (int)count(all(btoa), -1);
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m, k;
    cin >> n >> m >> k;
    vector<vi> g(n);
    while (k--) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        g[a].push_back(b);
    }
    vi btoa(m, -1);
    cout << dfsMatching(g, btoa) << '\n';
    rep(i, 0, m) if (btoa[i]>=0)
        cout << btoa[i]+1 << "" "" << i+1 << '\n';
    return 0;
}
"
School Dance,Java,"// https://cses.fi/problemset/task/1696
// School Dance
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1696 {
    static ArrayList[] aa;
    static int[] uu, vv, dd, qq;
    static boolean bfs(int n) {
        int head = 0, cnt = 0;
        dd[0] = n;
        for (int u = 1; u <= n; u++)
            if (vv[u] == 0) {
                dd[u] = 0;
                qq[head + cnt++] = u;
            } else
                dd[u] = n;
        while (cnt > 0) {
            int u = qq[head++]; cnt--;
            int d = dd[u] + 1;
            ArrayList<Integer> adj = aa[u];
            for (int v : adj) {
                int w = uu[v];
                if (dd[w] == n) {
                    dd[w] = d;
                    if (w == 0)
                        return true;
                    qq[head + cnt++] = w;
                }
            }
        }
        return false;
    }
    static boolean dfs(int n, int u) {
        if (u == 0)
            return true;
        int d = dd[u] + 1;
        ArrayList<Integer> adj = aa[u];
        for (int v : adj) {
            int w = uu[v];
            if (dd[w] == d && dfs(n, w)) {
                vv[u] = v;
                uu[v] = u;
                return true;
            }
        }
        dd[u] = n;
        return false;
    }
    static int hopcroft_karp(int n, int n_) {
        vv = new int[n + 1];
        uu = new int[n_ + 1];
        dd = new int[n + 1];
        qq = new int[n];
        int m = 0;
        while (bfs(n))
            for (int u = 1; u <= n; u++)
                if (vv[u] == 0 && dfs(n, u))
                    m++;
        return m;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int n_ = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new ArrayList[n + 1];
        for (int u = 1; u <= n; u++)
            aa[u] = new ArrayList<Integer>();
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            aa[u].add(v);
        }
        pw.println(hopcroft_karp(n, n_));
        for (int u = 1; u <= n; u++)
            if (vv[u] != 0)
                pw.println(u + "" "" + vv[u]);
        pw.close();
    }
}
"
School Dance,C++,"/*
 https://cses.fi/problemset/task/1696
 School Dance
 practice with Dukkha
 */
#include <stdio.h>

#define N    500
#define M    1000

struct L {
    struct L *next;
    int v;
} aa[N + 1];

int vv[N + 1], uu[N + 1], dd[N + 1];

void link(int u, int v) {
    static struct L l91[M], *l = l91;
    
    l->v = v;
    l->next = aa[u].next, aa[u].next = l++;
}

int bfs(int n) {
    static int qq[N];
    int u, head, cnt, d;
    
    head = cnt = 0;
    dd[0] = n;
    for (u = 1; u <= n; u++)
        if (vv[u] == 0) {
            dd[u] = 0;
            qq[head + cnt++] = u;
        } else
            dd[u] = n;
    while (cnt) {
        struct L *l;
        
        u = qq[cnt--, head++];
        d = dd[u] + 1;
        for (l = aa[u].next; l; l = l->next) {
            int v = l->v, w = uu[v];
            
            if (dd[w] == n) {
                dd[w] = d;
                if (w == 0)
                    return 1;
                qq[head + cnt++] = w;
            }
        }
    }
    return 0;
}

int dfs(int n, int u) {
    struct L *l;
    int d;
    
    if (u == 0)
        return 1;
    d = dd[u] + 1;
    for (l = aa[u].next; l; l = l->next) {
        int v = l->v, w = uu[v];
        
        if (dd[w] == d && dfs(n, w)) {
            vv[u] = v;
            uu[v] = u;
            return 1;
        }
    }
    dd[u] = n;
    return 0;
}

int hopcroft_karp(int n) {
    int m = 0;
    
    while (bfs(n)) {
        int u;
        
        for (u = 1; u <= n; u++)
            if (vv[u] == 0 && dfs(n, u))
                m++;
    }
    return m;
}

int main() {
    int n, n_, m, u, v;
    
    scanf(""%d%d%d"", &n, &n_, &m);
    while (m--) {
        scanf(""%d%d"", &u, &v);
        link(u, v);
    }
    printf(""%d\n"", hopcroft_karp(n));
    for (u = 1; u <= n; u++)
        if (vv[u])
            printf(""%d %d\n"", u, vv[u]);
    return 0;
}
"
Shortest Routes I,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;


template<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;

template<class T> T poll(pqg<T>& x) {
    T y = x.top(); x.pop();
    return y;
}

template<int SZ> struct Dijkstra {
    ll dist[SZ];
    vpi adj[SZ];
    pqg<pl> q;
    
    void addEdge(int A, int B, int C) {
        adj[A].pb({B,C}); // adj[B].pb({A,C});
    }
    
    void init(int st) {
        fill_n(dist,SZ,INF);
        q = pqg<pl>(); q.push({dist[st] = 0,st});
        while (sz(q)) {
            auto x = poll(q); if (dist[x.s] < x.f) continue;
            trav(y,adj[x.s]) if (x.f+y.s < dist[y.f])
                q.push({dist[y.f] = x.f+y.s,y.f});
        }
    }
};

int n,m;
Dijkstra<MX> D;

int main() {
    re(n,m);
    F0R(i,m) {
        int a,b,c; re(a,b,c);
        D.addEdge(a,b,c);
    }
    D.init(1);
    FOR(i,1,n+1) pr(D.dist[i],' ');
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Shortest Routes I,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr ll inf=1e18;
    int n, m;
    cin >> n >> m;
    vector<vector<pii>> g(n+1);
    while (m--) {
        int a, b, c;
        cin >> a >> b >> c;
        g[a].push_back({b, c});
    }
    vector<ll> d(n+1, inf);
    typedef pair<ll, int> T;
    priority_queue<T, vector<T>, greater<T>> q;
    for(q.push({0, 1}); !q.empty(); q.pop()) {
        ll cur=q.top().first;
        int i=q.top().second;
        if (d[i]<inf) continue;
        d[i]=cur;
        trav(p, g[i]) q.push({cur+p.second, p.first});
    }
    rep(i, 1, n+1) cout << d[i] << "" \n""[i==n];
    return 0;
}
"
Shortest Routes I,Java,"// https://cses.fi/problemset/task/1671
// Shortest Routes I
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1671 {
    static class E {
        int j, w;
        E(int j, int w) {
            this.j = j; this.w = w;
        }
    }
    static ArrayList[] aa;
    static final long INF = 0x3f3f3f3f3f3f3f3fL;
    static long[] dd;
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int m = sc.nextInt();
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<E>();
        while (m-- > 0) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            int w = sc.nextInt();
            aa[i].add(new E(j, w));
        }
        dd = new long[n];
        Arrays.fill(dd, INF);
        dd[0] = 0;
        TreeSet<Integer> pq = new TreeSet<>((i, j) -> dd[i] == dd[j] ? i - j : dd[i] < dd[j] ? -1 : 1);
        pq.add(0);
        Integer i_;
        while ((i_ = pq.pollFirst()) != null) {
            int i = i_;
            ArrayList<E> adj = aa[i];
            for (E e : adj) {
                long d = dd[i] + e.w;
                if (dd[e.j] > d) {
                    if (dd[e.j] != INF)
                        pq.remove(e.j);
                    dd[e.j] = d;
                    pq.add(e.j);
                }
            }
        }
        for (int i = 0; i < n; i++)
            pw.print(dd[i] + "" "");
        pw.println();
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb); //if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        String next() throws IOException {
            StringBuilder sb = new StringBuilder();
            for (byte b = skip(); b > 32; b = getc())
                sb.append((char) b);
            return sb.toString();
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Shortest Routes I,Java,"// https://cses.fi/problemset/task/1671
// Shortest Routes I
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1671 {
    static class E {
        int j, w;
        E(int j, int w) {
            this.j = j; this.w = w;
        }
    }
    static ArrayList[] aa;
    static final long INF = 0x3f3f3f3f3f3f3f3fL;
    static long[] dd;
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int m = sc.nextInt();
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<E>();
        while (m-- > 0) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            int w = sc.nextInt();
            aa[i].add(new E(j, w));
        }
        dd = new long[n];
        Arrays.fill(dd, INF);
        dd[0] = 0;
        TreeSet<Integer> pq = new TreeSet<>((i, j) -> dd[i] == dd[j] ? i - j : dd[i] < dd[j] ? -1 : 1);
        pq.add(0);
        Integer i_;
        while ((i_ = pq.pollFirst()) != null) {
            int i = i_;
            ArrayList<E> adj = aa[i];
            for (E e : adj) {
                long d = dd[i] + e.w;
                if (dd[e.j] > d) {
                    if (dd[e.j] != INF)
                        pq.remove(e.j);
                    dd[e.j] = d;
                    pq.add(e.j);
                }
            }
        }
        for (int i = 0; i < n; i++)
            pw.print(dd[i] + "" "");
        pw.println();
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Shortest Routes I,C++,"/*
 https://cses.fi/problemset/task/1671
 Shortest Routes I
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100000
#define M    200000
#define INF    0x3f3f3f3f3f3f3f3fLL

struct L {
    struct L *next;
    int j, c;
} aa[N];

void link(int i, int j, int c) {
    static struct L l91[M], *l = l91;
    
    l->j = j, l->c = c;
    l->next = aa[i].next, aa[i].next = l++;
}

long long dd[N];
int pq[1 + N], iq[N], cnt;

#define LT(u, v)    (dd[u] < dd[v])

int i2(int i) {
    return (i *= 2) > cnt ? 0 : i < cnt && LT(pq[i + 1], pq[i]) ? i + 1 : i;
}

void pq_up(int u) {
    int i, j;
    
    for (i = iq[u]; (j = i / 2) && LT(u, pq[j]); i = j)
        pq[iq[pq[j]] = i] = pq[j];
    pq[iq[u] = i] = u;
}

void pq_dn(int u) {
    int i, j;
    
    for (i = iq[u]; (j = i2(i)) && LT(pq[j], u); i = j)
        pq[iq[pq[j]] = i] = pq[j];
    pq[iq[u] = i] = u;
}

void pq_add(int u) {
    iq[u] = ++cnt;
    pq_up(u);
}

int pq_remove_first() {
    int u = pq[1], v = pq[cnt--];
    
    iq[v] = 1;
    pq_dn(v);
    return u;
}

int main() {
    int n, m, i, j, c;
    
    scanf(""%d%d"", &n, &m);
    while (m--) {
        scanf(""%d%d%d"", &i, &j, &c), i--, j--;
        link(i, j, c);
    }
    memset(dd, 0x3f, sizeof dd);
    dd[0] = 0;
    pq_add(0);
    while (cnt) {
        struct L *l;
        
        i = pq_remove_first();
        for (l = aa[i].next; l; l = l->next) {
            long long d = dd[i] + l->c;
            
            if (dd[l->j] == INF) {
                dd[l->j] = d;
                pq_add(l->j);
            } else if (dd[l->j] > d) {
                dd[l->j] = d;
                pq_up(l->j);
            }
        }
    }
    for (i = 0; i < n; i++)
        printf(""%lld "", dd[i]);
    printf(""\n"");
    return 0;
}
"
Shortest Routes II,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<int SZ> struct FloydWarshall {
    int n; // vertices, edges, queries
    ll dist[SZ][SZ];
    bool bad[SZ][SZ];
    vector<array<int,3>> ed;
    
    void addEdge(int u, int v, int w) { ed.pb({u,v,w}); }
    
    ll getDist(int x, int y) { // get distance from node x to node y
        return bad[x][y] ? -INF : dist[x][y];
    }
    
    void init(int _n) {
        n = _n;
        FOR(i,1,n+1) FOR(j,1,n+1) dist[i][j] = INF, bad[i][j] = 0;
        FOR(i,1,n+1) dist[i][i] = 0;
        trav(t,ed) ckmin(dist[t[0]][t[1]],(ll)t[2]);
        
        FOR(k,1,n+1) FOR(i,1,n+1) FOR(j,1,n+1) if (dist[i][k] != INF && dist[k][j] != INF)
            ckmin(dist[i][j],dist[i][k]+dist[k][j]);
        
        FOR(k,1,n+1) FOR(i,1,n+1) FOR(j,1,n+1) if (dist[i][k] != INF && dist[k][j] != INF)
            if (dist[i][j] > dist[i][k]+dist[k][j]) bad[i][j] = 1;
        
        FOR(k,1,n+1) FOR(i,1,n+1) FOR(j,1,n+1) {
            if (dist[i][k] < INF && bad[k][j]) bad[i][j] = 1;
            if (bad[i][k] && dist[k][j] < INF) bad[i][j] = 1;
        }
    }
};

FloydWarshall<501> F;
int n,m,q;

int main() {
    re(n,m,q);
    F0R(i,m) {
        int a,b,c; re(a,b,c);
        F.addEdge(a,b,c), F.addEdge(b,a,c);
    }
    F.init(n);
    F0R(i,q) {
        int a,b; re(a,b);
        auto x = F.getDist(a,b);
        if (x == INF) ps(-1);
        else ps(x);
    }
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Shortest Routes II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

const ll inf = 1LL << 62;
void floydWarshall(vector<vector<ll>>& m) {
    int n = sz(m);
    rep(i,0,n) m[i][i] = min(m[i][i], 0LL);
    rep(k,0,n) rep(i,0,n) rep(j,0,n)
    if (m[i][k] != inf && m[k][j] != inf) {
        auto newDist = max(m[i][k] + m[k][j], -inf);
        m[i][j] = min(m[i][j], newDist);
    }
    rep(k,0,n) if (m[k][k] < 0) rep(i,0,n) rep(j,0,n)
        if (m[i][k] != inf && m[k][j] != inf) m[i][j] = -inf;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    ll n, m, q;
    cin >> n >> m >> q;
    vector<vector<ll>> g(n+1, vector<ll>(n+1, inf));
    while (m--) {
        ll a, b, c;
        cin >> a >> b >> c;
        g[a][b]=g[b][a]=min(g[a][b], c);
    }
    floydWarshall(g);
    while (q--) {
        ll a, b;
        cin >> a >> b;
        cout << (g[a][b]==inf? -1:g[a][b]) << '\n';
    }
    return 0;
}
"
Shortest Routes II,Java,"// https://cses.fi/problemset/task/1672
// Shortest Routes II
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1672 {
    static final long INF = 0x3f3f3f3f3f3f3f3fL;
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int q = sc.nextInt();
        long[][] aa = new long[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++)
                aa[i][j] = INF;
            aa[i][i] = 0;
        }
        while (m-- > 0) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            int w = sc.nextInt();
            if (aa[i][j] > w)
                aa[j][i] = aa[i][j] = w;
        }
        for (int k = 0; k < n; k++)
            for (int i = 0; i < n; i++)
                for (int j = i + 1; j < n; j++) {
                    long a = aa[i][k] + aa[k][j];
                    if (aa[i][j] > a)
                        aa[j][i] = aa[i][j] = a;
                }
        while (q-- > 0) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            long a = aa[i][j];
            pw.println(a == INF ? -1 : a);
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Shortest Routes II,C++,"/*
 https://cses.fi/problemset/task/1672
 Shortest Routes II
 practice with Dukkha
 */
#include <stdio.h>

#define N    500
#define INF    0x3f3f3f3f3f3f3f3fLL

int main() {
    static long long aa[N][N];
    int n, m, q, i, j, k, c;
    long long a;
    
    scanf(""%d%d%d"", &n, &m, &q);
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            aa[i][j] = i == j ? 0 : INF;
    while (m--) {
        scanf(""%d%d%d"", &i, &j, &c), i--, j--;
        if (aa[i][j] > c)
            aa[i][j] = aa[j][i] = c;
    }
    for (k = 0; k < n; k++)
        for (i = 0; i < n; i++)
            for (j = 0; j < n; j++)
                if (aa[i][j] > (a = aa[i][k] + aa[k][j]))
                    aa[i][j] = a;
    while (q--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        printf(""%lld\n"", (a = aa[i][j]) == INF ? -1 : a);
    }
    return 0;
}
"
Shortest Routes II,C++,"/*
 https://cses.fi/problemset/task/1672
 Shortest Routes II
 practice with Dukkha
 */
#include <stdio.h>

#define N    500
#define INF    0x3f3f3f3f3f3f3f3fLL

int main() {
    static long long aa[N][N];
    int n, m, q, i, j, k, c;
    long long a;
    
    scanf(""%d%d%d"", &n, &m, &q);
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            aa[i][j] = i == j ? 0 : INF;
    while (m--) {
        scanf(""%d%d%d"", &i, &j, &c), i--, j--;
        if (aa[i][j] > c)
            aa[i][j] = aa[j][i] = c;
    }
    for (k = 0; k < n; k++)
        for (i = 0; i < n; i++)
            for (j = i + 1; j < n; j++)
                if (aa[i][j] > (a = aa[i][k] + aa[k][j]))
                    aa[i][j] = aa[j][i] = a;
    while (q--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        printf(""%lld\n"", (a = aa[i][j]) == INF ? -1 : a);
    }
    return 0;
}
"
Teleporters Path,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;


template<int SZ, bool directed> struct Euler {
    int N, M;
    vpi adj[SZ], circuit;
    int out[SZ], in[SZ], deg[SZ];
    bool used[SZ], bad;
    
    void clr() {
        F0R(i,N) adj[i].clear();
        circuit.clear();
        F0R(i,N) out[i] = in[i] = deg[i] = 0;
        F0R(i,M) used[i] = 0;
        N = M = bad = 0;
    }
    
    void dfs(int pre, int cur) {
        while (sz(adj[cur])) {
            pi x = adj[cur].back(); adj[cur].pop_back();
            if (used[x.s]) continue;
            used[x.s] = 1; dfs(cur,x.f);
        }
        if (sz(circuit) && circuit.back().f != cur) bad = 1;
        circuit.pb({pre,cur}); // generate circuit in reverse order
    }
    
    void addEdge(int a, int b) {
        if (directed) {
            adj[a].pb({b,M});
            out[a] ++, in[b] ++;
        } else {
            adj[a].pb({b,M}), adj[b].pb({a,M});
            deg[a] ++, deg[b] ++;
        }
        M ++;
    }
    
    vi solve(int _N) {
        N = _N; // edges only involve vertices from 0 to N-1
        
        int start = 1;
        dfs(-1,start);
        
        if (sz(circuit) != M+1 || bad) return {}; // return empty if no sol
        vi ans; F0Rd(i,sz(circuit)) ans.pb(circuit[i].s);
        return ans;
    }
};

Euler<MX,1> E;
int n,m;

int main() {
    setIO(); re(n,m);
    F0R(i,m) {
        int a,b; re(a,b);
        E.addEdge(a,b);
    }
    auto x = E.solve(n);
    if (!sz(x) || x.back() != n) ps(""IMPOSSIBLE"");
    else {
        trav(t,x) pr(t,' ');
        exit(0);
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Teleporters Path,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

struct V {
    vector<pii> outs; // (dest, edge index)
    int nins = 0;
};

vi euler_walk(vector<V>& nodes, int nedges, int src=0) {
    int c = 0;
    trav(n, nodes) c += abs(n.nins - sz(n.outs));
    if (c > 2) return {};
    vector<vector<pii>::iterator> its;
    trav(n, nodes)
    its.push_back(n.outs.begin());
    vector<bool> eu(nedges);
    vi ret, s = {src};
    while(!s.empty()) {
        int x = s.back();
        auto& it = its[x], end = nodes[x].outs.end();
        while(it != end && eu[it->second]) ++it;
        if(it == end) { ret.push_back(x); s.pop_back(); }
        else { s.push_back(it->first); eu[it->second] = true; }
    }
    if(sz(ret) != nedges+1)
        ret.clear(); // No Eulerian cycles/paths.
    // else, non-cycle if ret.front() != ret.back()
    reverse(all(ret));
    return ret;
}
int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<V> g(n);
    rep(i, 0, m) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        g[a].outs.push_back({b, i});
        g[b].nins++;
    }
    vi w=euler_walk(g, m, 0);
    if (!sz(w) || w.back()!=n-1)
        cout << ""IMPOSSIBLE\n"";
    else
        rep(i, 0, m+1) cout << w[i]+1 << "" \n""[i==m];
    return 0;
}
"
Teleporters Path,Java,"// https://cses.fi/problemset/task/1693
// Teleporters Path
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1693 {
    static class L {
        L next;
        int j;
        L(int j) {
            this.j = j;
        }
    }
    static L[] aa;
    static void hierholzer(L e) {
        L f = e.next, l;
        int i = e.j;
        while ((l = aa[i]) != null) {
            aa[i] = l.next;
            e = e.next = new L(l.j);
            i = l.j;
        }
        e.next = f;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        aa = new L[n];
        int[] din = new int[n];
        int[] dout = new int[n];
        for (int h = 0; h < m; h++) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            L l = new L(j);
            l.next = aa[i]; aa[i] = l;
            dout[i]++;
            din[j]++;
        }
        if (dout[0] - din[0] != 1 || din[n - 1] - dout[n - 1] != 1) {
            System.out.println(""IMPOSSIBLE"");
            return;
        }
        for (int i = 1; i < n - 1; i++)
            if (dout[i] != din[i]) {
                System.out.println(""IMPOSSIBLE"");
                return;
            }
        L e_ = new L(0);
        m++;
        hierholzer(e_);
        for (L e = e_; e != null; e = e.next) {
            hierholzer(e);
            m--;
        }
        if (m != 0) {
            System.out.println(""IMPOSSIBLE"");
            return;
        }
        PrintWriter pw = new PrintWriter(System.out);
        for (L e = e_; e != null; e = e.next)
            pw.print(e.j + 1 + "" "");
        pw.println();
        pw.close();
    }
}
"
Teleporters Path,C++,"/*
 https://cses.fi/problemset/task/1693
 Teleporters Path
 practice with Dukkha
 */
#include <stdio.h>

#define N    100000
#define M    200000

struct L {
    struct L *next;
    int j;
} *aa[N];

struct L *new_L(int j) {
    static struct L l91[M + 1 + M], *l = l91;
    
    l->j = j;
    return l++;
}

void link(int i, int j) {
    struct L *l = new_L(j);
    
    l->next = aa[i]; aa[i] = l;
}

void hierholzer(struct L *e) {
    struct L *f = e->next, *l;
    int i = e->j;
    
    while ((l = aa[i])) {
        aa[i] = l->next;
        e = e->next = new_L(l->j);
        i = l->j;
    }
    e->next = f;
}

int main() {
    static int din[N], dout[N];
    struct L *e_, *e;
    int n, m, h, i, j;
    
    scanf(""%d%d"", &n, &m);
    for (h = 0; h < m; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j);
        dout[i]++, din[j]++;
    }
    if (dout[0] - din[0] != 1 || din[n - 1] - dout[n - 1] != 1) {
        printf(""IMPOSSIBLE\n"");
        return 0;
    }
    for (i = 1; i < n - 1; i++)
        if (dout[i] != din[i]) {
            printf(""IMPOSSIBLE\n"");
            return 0;
        }
    e_ = new_L(0);
    m++;
    hierholzer(e_);
    for (e = e_; e; e = e->next) {
        hierholzer(e);
        m--;
    }
    if (m != 0) {
        printf(""IMPOSSIBLE\n"");
        return 0;
    }
    for (e = e_; e; e = e->next)
        printf(""%d "", e->j + 1);
    printf(""\n"");
    return 0;
}
"
Apple Division,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n;
vi p;
ll ans = INF;

void dfs(int a, ll b) {
    if (a == n) {
        ckmin(ans,abs(b));
        return;
    }
    dfs(a+1,b+p[a]);
    dfs(a+1,b-p[a]);
}

int main() {
    setIO(); re(n); p.resz(n); re(p);
    dfs(0,0);
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Apple Division,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr ll inf=1e18;
    int n;
    cin >> n;
    vi p(n);
    ll s=0;
    rep(i, 0, n) {
        cin >> p[i];
        s+=p[i];
    }
    int M=1<<n;
    ll opt=inf;
    rep(m, 0, M) {
        ll t=0;
        rep(j, 0, n)
        if (m&(1<<j)) t+=p[j];
        opt=min(opt, abs(2*t-s));
    }
    cout << opt <<'\n';
    return 0;
}
"
Apple Division,Java,"// https://cses.fi/problemset/task/1623
// Apple Division
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1623 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] aa = new int[n];
        long sum = 0;
        for (int i = 0; i < n; i++)
            sum += aa[i] = Integer.parseInt(st.nextToken());
        long d_ = sum;
        for (int b = 1; b < 1 << n; b += 2) {
            long a = 0;
            for (int i = 0; i < n; i++)
                if ((b & 1 << i) != 0)
                    a += aa[i];
            long d = Math.abs(sum - a - a);
            if (d_ > d)
                d_ = d;
        }
        System.out.println(d_);
    }
}
"
Apple Division,C++,"/*
 https://cses.fi/problemset/task/1623
 Apple Division
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>

#define N    20

long long abs_(long long a) {
    return a > 0 ? a : -a;
}

int main() {
    static int pp[N];
    int n, i, b;
    long long sum, sum_, d_, d;
    
    scanf(""%d"", &n);
    sum = 0;
    for (i = 0; i < n; i++) {
        scanf(""%d"", &pp[i]);
        sum += pp[i];
    }
    d_ = sum;
    for (b = 0; b < 1 << (n - 1); b++) {
        sum_ = 0;
        for (i = 0; i < n - 1; i++)
            if (b & 1 << i)
                sum_ += pp[i];
        if (d_ > (d = abs_(sum_ - (sum - sum_))))
            d_ = d;
    }
    printf(""%lld\n"", d_);
    return 0;
}
"
Bit Strings,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int main() {
    setIO(); int n; re(n);
    mi ans = exp(mi(2),n);
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Bit Strings,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr ll P=1e9+7;
    ll n, ans=1;
    cin >> n;
    while (n--)
    ans=ans*2%P;
    cout << ans << '\n';
    return 0;
}
"
Bit Strings,Java,"// https://cses.fi/problemset/task/1617
// Bit Strings
// practice with rainboy
import java.io.*;

public class CSES1617 {
    static final int MD = 1000000007;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int a = 1;
        while (n-- > 0)
            a = a * 2 % MD;
        System.out.println(a);
    }
}
"
Bit Strings,C++,"/*
 https://cses.fi/problemset/task/1617
 Bit Strings
 practice with Dukkha
 */
#include <stdio.h>

#define MD    1000000007

int main() {
    int n, ans;
    
    scanf(""%d"", &n);
    ans = 1;
    while (n--)
    ans = ans * 2 % MD;
    printf(""%d\n"", ans);
    return 0;
}
"
Chessboard and Queens,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

string g[8];
bool sum[15], dif[15], c[8];
int ans = 0;

void dfs(int r) {
    if (r == 8) {
        ans ++;
        return;
    }
    F0R(i,8) if (g[r][i] == '.' && !c[i] && !sum[i+r] && !dif[i-r+7]) {
        c[i] = sum[i+r] = dif[i-r+7] = 1;
        dfs(r+1);
        c[i] = sum[i+r] = dif[i-r+7] = 0;
    }
}

int main() {
    setIO(); F0R(i,8) re(g[i]);
    dfs(0); ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Chessboard and Queens,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vector<string> s(8);
vi h(8), d1(16), d2(16);
int ans;

void dfs(int i) {
    if(i==8) {
        ans++;
        return;
    }
    rep(j, 0, 8) {
        if(h[j] || d1[i+j] || d2[i-j+8] || s[i][j]=='*')
            continue;
        h[j]=d1[i+j]=d2[i-j+8]=1;
        dfs(i+1);
        h[j]=d1[i+j]=d2[i-j+8]=0;
    }
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    rep(i, 0, 8) cin >> s[i];
    dfs(0);
    cout << ans << '\n';
    return 0;
}
"
Chessboard and Queens,Java,"// https://cses.fi/problemset/task/1624
// Chessboard and Queens
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1624 {
    static char[][] cc = new char[8][8];
    static boolean[] col = new boolean[8];
    static boolean[] d1 = new boolean[15];
    static boolean[] d2 = new boolean[15];
    static int cnt = 0;
    static void solve(int i) {
        if (i == 8) {
            cnt++;
            return;
        }
        for (int j = 0; j < 8; j++)
            if (cc[i][j] == '.' && !col[j] && !d1[i + j] && !d2[i - j + 7]) {
                col[j] = d1[i + j] = d2[i - j + 7] = true;
                solve(i + 1);
                col[j] = d1[i + j] = d2[i - j + 7] = false;
            }
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        for (int i = 0; i < 8; i++)
            br.readLine().getChars(0, 8, cc[i], 0);
        solve(0);
        System.out.println(cnt);
    }
}
"
Chessboard and Queens,C++,"/*
 https://cses.fi/problemset/task/1624
 Chessboard and Queens
 practice with Dukkha
 */
#include <stdio.h>

char cc[8][9], col[8], d1[15], d2[15];
int cnt;

void solve(int i) {
    int j;
    
    if (i == 8) {
        cnt++;
        return;
    }
    for (j = 0; j < 8; j++)
        if (cc[i][j] == '.' && !col[j] && !d1[i + j] && !d2[i - j + 7]) {
            col[j] = d1[i + j] = d2[i - j + 7] = 1;
            solve(i + 1);
            col[j] = d1[i + j] = d2[i - j + 7] = 0;
        }
}

int main() {
    int i;
    
    for (i = 0; i < 8; i++)
        scanf(""%s"", cc[i]);
    solve(0);
    printf(""%d\n"", cnt);
    return 0;
}
"
Coin Piles,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int a,b;

bool solve() {
    re(a,b); if (a > b) swap(a,b);
    return 2*a >= b && (a+b)%3 == 0;
}

int main() {
    setIO(); int t; re(t);
    F0R(i,t) ps(solve() ? ""YES"" : ""NO"");
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Coin Piles,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int t;
    cin >> t;
    while (t--) {
        int a, b;
        cin >> a >> b;
        cout << (b>2*a || a>2*b || (a+b)%3? ""NO\n"":""YES\n"");
    }
    return 0;
}
"
Coin Piles,Java,"// https://cses.fi/problemset/task/1754
// Coin Piles
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1754 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        int t = Integer.parseInt(br.readLine());
        while (t-- > 0) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            pw.println((a + b) % 3 == 0 && a <= b * 2 && b <= a * 2 ? ""YES"" : ""NO"");
        }
        pw.close();
    }
}
"
Coin Piles,C++,"/*
 https://cses.fi/problemset/task/1754
 Coin Piles
 practice with Dukkha
 */
#include <stdio.h>

int main() {
    int t;
    
    scanf(""%d"", &t);
    while (t--) {
        int a, b;
        
        scanf(""%d%d"", &a, &b);
        printf((a + b) % 3 == 0 && a * 2 >= b && b * 2 >= a ? ""YES\n"" : ""NO\n"");
    }
    return 0;
}
"
Creating Strings I,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

vector<string> v;

int main() {
    setIO(); string a; re(a); sort(all(a));
    do {
        v.pb(a);
    } while (next_permutation(all(a)));
    ps(sz(v));
    trav(t,v) ps(t);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Creating Strings I,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    string s;
    cin >> s;
    sort(all(s));
    vector<string> ans;
    do {
        ans.push_back(s);
    } while (next_permutation(all(s)));
    cout << sz(ans) << '\n';
    trav(s, ans) cout << s << '\n';
    return 0;
}
"
Creating Strings I,Java,"// https://cses.fi/problemset/task/1622
// Creating Strings I
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1622 {
    static final int K = 40320;
    static String[] ss = new String[K];
    static int k;
    static void solve(char[] cc, int n) {
        if (n == 0) {
            ss[k++] = new String(cc);
            return;
        }
        for (int i = 0; i < n; i++) {
            char tmp;
            tmp = cc[i]; cc[i] = cc[n - 1]; cc[n - 1] = tmp;
            solve(cc, n - 1);
            tmp = cc[i]; cc[i] = cc[n - 1]; cc[n - 1] = tmp;
        }
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        char[] cc = br.readLine().toCharArray();
        int n = cc.length;
        solve(cc, n);
        Arrays.sort(ss, 0, k, (s, t) -> s.compareTo(t));
        int k_ = 1;
        for (int h = 1; h < k; h++)
            if (ss[k_ - 1].compareTo(ss[h]) != 0)
                ss[k_++] = ss[h];
        k = k_;
        pw.println(k);
        for (int h = 0; h < k; h++)
            pw.println(ss[h]);
        pw.close();
    }
}
"
Creating Strings I,C++,"/*
 https://cses.fi/problemset/task/1622
 Creating Strings I
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define N    8
#define K    40320

char *ss[K];
int k;

void solve(char *cc, int n) {
    int i;
    char tmp;
    
    if (n == 0) {
        ss[k++] = strdup(cc);
        return;
    }
    for (i = 0; i < n; i++) {
        tmp = cc[i], cc[i] = cc[n - 1], cc[n - 1] = tmp;
        solve(cc, n - 1);
        tmp = cc[i], cc[i] = cc[n - 1], cc[n - 1] = tmp;
    }
}

int compare(const void *a, const void *b) {
    char *s = *(char **) a;
    char *t = *(char **) b;
    
    return strcmp(s, t);
}

int main() {
    static char cc[N + 1];
    int n, k_, h;
    
    scanf(""%s"", cc);
    n = strlen(cc);
    solve(cc, n);
    qsort(ss, k, sizeof *ss, compare);
    k_ = 1;
    for (h = 1; h < k; h++)
        if (strcmp(ss[k_ - 1], ss[h]))
            ss[k_++] = ss[h];
    k = k_;
    printf(""%d\n"", k);
    for (h = 0; h < k; h++)
        printf(""%s\n"", ss[h]);
    return 0;
}
"
Grid Paths,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int gr[7][7];
int ans = 0;
int xd[4] = {0,1,0,-1}, yd[4] = {1,0,-1,0};
ll mask = 0;

template<int SZ> struct DSU {
    int par[SZ], sz[SZ];
    
    DSU() {
        F0R(i,SZ) par[i] = i, sz[i] = 1;
    }
    
    int get(int x) { // path compression
        if (par[x] != x) par[x] = get(par[x]);
        return par[x];
    }
    
    bool unite(int x, int y) { // union-by-rank
        x = get(x), y = get(y);
        if (x == y) return 0;
        if (sz[x] < sz[y]) swap(x,y);
        sz[x] += sz[y], par[y] = x;
        return 1;
    }
};

int countAdj(int a, int b) {
    int cnt = 0;
    F0R(i,4) {
        int A = a+xd[i], B = b+yd[i];
        if (0 <= A && A < 7 && 0 <= B && B < 7 && !gr[A][B]) cnt ++;
    }
    return cnt;
}

bool bad(ll MASK) {
    DSU<49> D = DSU<49>();
    int r = MASK>>49; int c = r%7; r /= 7;
    F0R(i,7) F0R(j,7) if (!gr[i][j] && i+j > 0 && abs(i-r)+abs(j-c) > 1 && countAdj(i,j) <= 1){
        /*F0R(i,7) {
         F0R(j,7) cout << gr[i][j];
         cout << ""\n"";
         }
         ps(r,c);
         exit(0);*/
        return 1;
    }
    F0R(i,7) F0R(j,6) if (!gr[i][j] && !gr[i][j+1]) D.unite(7*i+j,7*i+j+1);
    F0R(i,6) F0R(j,7) if (!gr[i][j] && !gr[i+1][j]) D.unite(7*i+j,7*(i+1)+j);
    /*F0R(i,7) {
     F0R(j,7) ps(i,j,D.get(7*i+j));
     }*/
    F0R(i,7) F0R(j,7) if (!gr[i][j] && D.get(7*i+j) != D.get(0)) return 1;
    return 0;
}

int st = 0;
unordered_map<ll,int> WAYS;
unordered_map<ll,bool> BAD;

/*st ++;
 if (st == 3000000) {
 F0R(i,7) {
 F0R(j,7) cout << gr[i][j];
 cout << ""\n"";
 }
 exit(0);
 }*/

string s;

bool match(int ind, int dir) {
    if (s[ind] == '?') return 1;
    if (s[ind] == 'U') return dir == 0;
    if (s[ind] == 'L') return dir == 3;
    if (s[ind] == 'D') return dir == 2;
    if (s[ind] == 'R') return dir == 1;
    exit(5);
}

int dfs(int ind, int r, int c) {
    if (r < 0 || r >= 7 || c < 0 || c >= 7 || gr[r][c]) return 0;
    if (ind == 48) {
        /*F0Rd(j,7) {
         F0R(i,7) pr(gr[i][j],'\t');
         ps();
         }
         exit(0);*/
        return mp(r,c) == mp(0,0);
    }
    gr[r][c] = ind+1; mask ^= 1LL<<(7*r+c);
    ll MASK = mask^((ll)(7*r+c)<<49);
    if (!WAYS.count(MASK)) {
        int ret = 0;
        if (!BAD.count(MASK)) BAD[MASK] = bad(MASK);
        if (!BAD[MASK]) F0R(i,4) if (match(ind,i)) {
            int z = dfs(ind+1,r+xd[i],c+yd[i]);
            // if (ind+1 == 48) ps(""HA"",z,r,c,i,r+xd[i],c+yd[i]);
            ret += z;
        }
        WAYS[MASK] = ret;
    }
    gr[r][c] = 0; mask ^= 1LL<<(7*r+c);
    return WAYS[MASK];
}

int main() {
    // ps(bad()); exit(0);
    setIO(); re(s);
    // ps(s);
    // ps(st);
    // ps(ans);
    ps(dfs(0,0,6));
    // ps(mask);
    // ps(sz(BAD),sz(WAYS));
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Grid Paths,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

bool vis[7][7];
int ret = 0;

int xd[4] = {0,1,0,-1}, yd[4] = {1,0,-1,0};

bool ok(int x, int y) {
    return 0 <= x && x < 7 && 0 <= y && y < 7 && !vis[x][y];
}

string s;
string c = ""URDL"";

bool match(int cnt, int i) {
    cnt --;
    return s[cnt] == '?' || s[cnt] == c[i];
}

void dfs(int cnt, int a, int b) {
    if (a == 0 && b == 0) {
        if (cnt == 49) ret ++;
        vis[a][b] = 0;
        return;
    }
    vis[a][b] = 1;
    bool bad = 0;
    int x = ok(a+1,b)+ok(a-1,b), y = ok(a,b+1)+ok(a,b-1);
    if (x == 2 && y == 0) bad = 1;
    if (x == 0 && y == 2) bad = 1;
    if (!bad) F0R(i,4) if (ok(a+xd[i],b+yd[i]) && match(cnt,i)) dfs(cnt+1,a+xd[i],b+yd[i]);
    vis[a][b] = 0;
}

int main() {
    setIO(); re(s);
    dfs(1,0,6);
    ps(ret);
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Grid Paths,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

string f, dl=""UDLR"";
char x[9][9];
vi di{-1, 1, 0, 0}, dj{0, 0, -1, 1};
int ans;

void dfs(int i, int j, int w) {
    if (!f[w]) {
        ans++;
        return;
    }
    if (i==7 && j==1) return;
    if (x[i-1][j] && x[i+1][j] && !x[i][j-1] && !x[i][j+1]) return;
    if (!x[i-1][j] && !x[i+1][j] && x[i][j-1] && x[i][j+1])    return;
    x[i][j]=1;
    rep(d, 0, 4) {
        int ii=i+di[d];
        int jj=j+dj[d];
        if(x[ii][jj]) continue;
        if (f[w]!='?' && f[w]!=dl[d]) continue;
        dfs(ii, jj, w+1);
    }
    x[i][j]=0;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    rep(i, 1, 8) {
        x[i][0]=x[i][8]=1;
        x[0][i]=x[8][i]=1;
    }
    cin >> f;
    dfs(1, 1, 0);
    cout << ans << '\n';
    return 0;
}
"
Grid Paths,Java,"// https://cses.fi/problemset/task/1625
// Grid Paths
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1625 {
    static boolean[][] used = new boolean[9][9];
    static {
        for (int i = 0; i <= 8; i += 8)
            for (int j = 0; j <= 8; j++)
                used[i][j] = true;
                for (int j = 0; j <= 8; j += 8)
                    for (int i = 0; i <= 8; i++)
                        used[i][j] = true;
                        }
    static char[] path;
    static int cnt;
    static boolean only(int i, int j) {
        if (i == 7 && j == 1)
            return false;
        int k = 0;
        if (!used[i - 1][j])
            k++;
        if (!used[i + 1][j])
            k++;
        if (!used[i][j - 1])
            k++;
        if (!used[i][j + 1])
            k++;
        return k == 1;
    }
    static void solve(int i, int j, int h) {
        if (h == 48 || i == 7 && j == 1) {
            if (h == 48)
                cnt++;
            return;
        }
        boolean u = !used[i - 1][j];
        boolean d = !used[i + 1][j];
        boolean l = !used[i][j - 1];
        boolean r = !used[i][j + 1];
        if (u && d && !l && !r || !u && !d && l && r)
            return;
        used[i][j] = true;
        char p = path[h++];
        if (u && only(i - 1, j)) {
            if (p == 'U' || p == '?')
                solve(i - 1, j, h);
            used[i][j] = false;
            return;
        }
        if (d && only(i + 1, j)) {
            if (p == 'D' || p == '?')
                solve(i + 1, j, h);
            used[i][j] = false;
            return;
        }
        if (l && only(i, j - 1)) {
            if (p == 'L' || p == '?')
                solve(i, j - 1, h);
            used[i][j] = false;
            return;
        }
        if (r && only(i, j + 1)) {
            if (p == 'R' || p == '?')
                solve(i, j + 1, h);
            used[i][j] = false;
            return;
        }
        if (u && (p == 'U' || p == '?'))
            solve(i - 1, j, h);
        if (d && (p == 'D' || p == '?'))
            solve(i + 1, j, h);
        if (l && (p == 'L' || p == '?'))
            solve(i, j - 1, h);
        if (r && (p == 'R' || p == '?'))
            solve(i, j + 1, h);
        used[i][j] = false;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        path = br.readLine().toCharArray();
        solve(1, 1, 0);
        System.out.println(cnt);
    }
}
"
Grid Paths,C++,"/*
 https://cses.fi/problemset/task/1625
 Grid Paths
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

char used[9][9], path[49];
int cnt;

int only(int i, int j) {
    int k = 0;
    
    if (i == 7 && j == 1)
        return 0;
    if (!used[i - 1][j])
        k++;
    if (!used[i + 1][j])
        k++;
    if (!used[i][j - 1])
        k++;
    if (!used[i][j + 1])
        k++;
    return k == 1;
}

void solve(int i, int j, int h) {
    int u, d, l, r;
    char p;
    
    if (h == 48 || (i == 7 && j == 1)) {
        if (h == 48)
            cnt++;
        return;
    }
    u = !used[i - 1][j];
    d = !used[i + 1][j];
    l = !used[i][j - 1];
    r = !used[i][j + 1];
    if ((u && d && !l && !r) || (!u && !d && l && r))
        return;
    used[i][j] = 1;
    p = path[h++];
    if (u && only(i - 1, j)) {
        if (p == 'U' || p == '?')
            solve(i - 1, j, h);
        used[i][j] = 0;
        return;
    }
    if (d && only(i + 1, j)) {
        if (p == 'D' || p == '?')
            solve(i + 1, j, h);
        used[i][j] = 0;
        return;
    }
    if (l && only(i, j - 1)) {
        if (p == 'L' || p == '?')
            solve(i, j - 1, h);
        used[i][j] = 0;
        return;
    }
    if (r && only(i, j + 1)) {
        if (p == 'R' || p == '?')
            solve(i, j + 1, h);
        used[i][j] = 0;
        return;
    }
    if (u && (p == 'U' || p == '?'))
        solve(i - 1, j, h);
    if (d && (p == 'D' || p == '?'))
        solve(i + 1, j, h);
    if (l && (p == 'L' || p == '?'))
        solve(i, j - 1, h);
    if (r && (p == 'R' || p == '?'))
        solve(i, j + 1, h);
    used[i][j] = 0;
}

int main() {
    int i, j;
    
    for (i = 0; i < 9; i++)
        for (j = 0; j < 9; j++)
            used[i][j] = i == 0 || i == 8 || j == 0 || j == 8;
    scanf(""%s"", path);
    solve(1, 1, 0);
    printf(""%d\n"", cnt);
    return 0;
}
"
Increasing Array,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int n, lst;
ll ans = 0;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n;
    F0R(i,n) {
        int x; cin >> x;
        lst = max(lst,x);
        ans += lst-x;
    }
    cout << ans;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Increasing Array,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    ll ans=0, x=0;
    while (n--) {
        ll a;
        cin >> a;
        if (a<x) ans+=x-a;
        x=max(x, a);
    }
    cout << ans << '\n';
    return 0;
}
"
Increasing Array,Java,"// https://cses.fi/problemset/task/1094
// Increasing Array
import java.io.*;
import java.util.*;

public class CSES1094 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int a = Integer.parseInt(st.nextToken());
        long ans = 0;
        for (int i = 1; i < n; i++) {
            int b = Integer.parseInt(st.nextToken());
            a = Math.max(a, b);
            ans += a - b;
        }
        System.out.println(ans);
    }
}
"
Increasing Array,C++,"/*
 https://cses.fi/problemset/task/1094
 Increasing Array
 */
#include <stdio.h>

int main() {
    int n, max, a;
    long long ans;
    
    scanf(""%d"", &n);
    max = 0;
    ans = 0;
    while (n--) {
        scanf(""%d"", &a);
        if (max < a)
        max = a;
        ans += max - a;
    }
    printf(""%lld\n"", ans);
    return 0;
}
"
Missing Number,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

ll n, sum;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n;
    F0R(i,n-1) {
        int x; cin >> x;
        sum += x;
    }
    cout << n*(n+1)/2-sum;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Missing Number,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    int ans=n;
    rep(i, 1, n) {
        int x;
        cin >> x;
        ans^=x^i;
    }
    cout << ans << '\n';
    return 0;
}
"
Missing Number,Java,"// https://cses.fi/problemset/task/1083
// Missing Number
import java.io.*;
import java.util.*;

public class CSES1083 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        boolean[] used = new boolean[n + 1];
        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 1; i < n; i++) {
            int a = Integer.parseInt(st.nextToken());
            used[a] = true;
        }
        for (int a = 1; a <= n; a++)
            if (!used[a]) {
                System.out.println(a);
                return;
            }
    }
}
"
Missing Number,C++,"/*
 https://cses.fi/problemset/task/1083
 Missing Number
 */
#include <stdio.h>

#define N    200000

int main() {
    static char used[N + 1];
    int n, i, a;
    
    scanf(""%d"", &n);
    for (i = 0; i < n - 1; i++) {
        scanf(""%d"", &a);
        used[a] = 1;
    }
    for (a = 1; a <= n; a++)
    if (!used[a])
    break;
    printf(""%d\n"", a);
    return 0;
}
"
Number Spiral,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int T;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> T;
    F0R(i,T) {
        ll a,b; cin >> a >> b;
        ll mx = max(a,b);
        if (mx % 2 == 1) {
            if (b == mx) cout << mx*mx-a+1;
            else cout << (mx-1)*(mx-1)+b;
        } else {
            if (a == mx) cout << mx*mx-b+1;
            else cout << (mx-1)*(mx-1)+a;
        }
        cout << ""\n"";
    }
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Number Spiral,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    ll t;
    cin >> t;
    while (t--) {
        ll r, c, ans;
        cin >> r >> c;
        ll d=max(r-1, c-1);
        if (d%2==0) {
            if(r==d+1) ans=d*d+c;
            else ans=(d+1)*(d+1)-r+1;
        }
        else {
            if (c==d+1) ans=d*d+r;
            else ans=(d+1)*(d+1)-c+1;
        }
        cout << ans << '\n';
    }
    return 0;
}
"
Number Spiral,Java,"// https://cses.fi/problemset/task/1071
// Number Spiral
import java.io.*;
import java.util.*;

public class CSES1071 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        int t = Integer.parseInt(br.readLine());
        while (t-- > 0) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken());
            int j = Integer.parseInt(st.nextToken());
            int a = Math.max(i, j);
            long n;
            if (a % 2 == 1)
                n = (long) a * a - (i - 1) - (a - j);
            else
                n = (long) (a - 1) * (a - 1) + (i - 0) + (a - j);
            pw.println(n);
        }
        pw.close();
    }
}
"
Number Spiral,C++,"/*
 https://cses.fi/problemset/task/1071
 Number Spiral
 */
#include <stdio.h>

int main() {
    int t;
    
    scanf(""%d"", &t);
    while (t--) {
        int x, y, tmp;
        long long a;
        
        scanf(""%d%d"", &x, &y);
        a = x > y ? x : y;
        if (a % 2 == 1)
        tmp = x, x = y, y = tmp;
        printf(""%lld\n"", x > y ? a * a - (y - 1) : (a - 1) * (a - 1) + x);
    }
    return 0;
}
"
Palindrome Reorder,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

string s;
int co[26];
string beg, extra;

int main() {
    re(s); trav(t,s) co[t-'A'] ++;
    F0R(i,26) {
        // ps(i,co[i]);
        while (co[i] >= 2) {
            beg += char('A'+i);
            co[i] -= 2;
        }
        if (co[i]) extra += char('A'+i);
    }
    // ps(beg);
    if (sz(extra) > 1) {
        ps(""NO SOLUTION"");
        exit(0);
    }
    pr(beg,extra); reverse(all(beg)); ps(beg);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Palindrome Reorder,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    string s;
    cin >>  s;
    map<char, int> f;
    trav(c, s) f[c]++;
    string ans, odd;
    trav(p, f) {
        ans+=string(p.second/2, p.first);
        if (p.second%2) odd+=p.first;
    }
    if (sz(odd)>1)
        cout << ""NO SOLUTION\n"";
    else {
        cout << ans + odd;
        reverse(all(ans));
        cout << ans <<'\n';
    }
    return 0;
}
"
Palindrome Reorder,Java,"// https://cses.fi/problemset/task/1755
// Palindrome Reorder
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1755 {
    static final int A = 26;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        char[] cc = br.readLine().toCharArray();
        int[] kk = new int[A];
        int n = cc.length;
        for (int i = 0; i < n; i++) {
            int a = cc[i] - 'A';
            kk[a]++;
        }
        int odd = -1;
        for (int a = 0; a < A; a++)
            if (kk[a] % 2 == 1) {
                if (odd == -1)
                    odd = a;
                else {
                    System.out.println(""NO SOLUTION"");
                    return;
                }
            }
        n = 0;
        int k;
        char c;
        for (int a = 0; a < A; a++) {
            if (a == odd)
                continue;
            k = kk[a] / 2;
            c = (char) (a + 'A');
            while (k-- > 0)
                cc[n++] = c;
        }
        if (odd != -1) {
            k = kk[odd];
            c = (char) (odd + 'A');
            while (k-- > 0)
                cc[n++] = c;
        }
        for (int a = A - 1; a >= 0; a--) {
            if (a == odd)
                continue;
            k = kk[a] / 2;
            c = (char) (a + 'A');
            while (k-- > 0)
                cc[n++] = c;
        }
        System.out.println(cc);
    }
}
"
Palindrome Reorder,C++,"/*
 https://cses.fi/problemset/task/1755
 Palindrome Reorder
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    1000000

int main() {
    static char cc[N + 1];
    static int kk[26];
    int n, i, j, c, c_;
    
    scanf(""%s"", cc);
    n = strlen(cc);
    for (i = 0; i < n; i++)
        kk[cc[i] - 'A']++;
    c_ = -1;
    for (c = 0; c < 26; c++)
        if (kk[c] % 2 == 1) {
            if (c_ == -1)
                c_ = c;
            else {
                printf(""NO SOLUTION\n"");
                return 0;
            }
        }
    for (i = 0, j = n - 1, c = 0; c < 26; c++)
        while (kk[c] >= 2) {
            cc[i++] = cc[j--] = c + 'A';
            kk[c] -= 2;
        }
    if (c_ != -1)
        cc[i++] = c_ + 'A';
    printf(""%s\n"", cc);
    return 0;
}
"
Permutations,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int n, lst;
ll ans = 0;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n;
    if (n == 2 || n == 3) {
        cout << ""NO SOLUTION"";
    } else {
        for (int i = 2; i <= n; i += 2) cout << i << "" "";
        for (int i = 1; i <= n; i += 2) cout << i << "" "";
    }
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Permutations,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    if (n==2 || n==3)
    cout << ""NO SOLUTION\n"";
    else {
        for(int i=2; i<=n; i+=2)
        cout << i << "" "";
        for(int i=1; i<=n; i+=2)
        cout << i << "" \n""[i+2>n];
    }
    return 0;
}
"
Permutations,Java,"// https://cses.fi/problemset/task/1070
// Permutations
import java.io.*;

public class CSES1070 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        if (n == 2 || n == 3) {
            System.out.println(""NO SOLUTION"");
            return;
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 2; i <= n; i += 2)
            sb.append(i + "" "");
        for (int i = 1; i <= n; i += 2)
            sb.append(i + "" "");
        System.out.println(sb);
    }
}
"
Permutations,C++,"/*
 https://cses.fi/problemset/task/1070
 Permutations
 */
#include <stdio.h>

int main() {
    int n, a;
    
    scanf(""%d"", &n);
    if (n == 2 || n == 3) {
        printf(""NO SOLUTION\n"");
        return 0;
    }
    for (a = 2; a <= n; a += 2)
    printf(""%d "", a);
    for (a = 1; a <= n; a += 2)
    printf(""%d "", a);
    printf(""\n"");
    return 0;
}
"
Repetitions,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;


int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    string s; cin >> s;
    int ans = 0;
    for (int i = 0; i < s.length(); ) {
        int i1 = i;
        while (i < s.length() && s[i] == s[i1]) i++;
        ans = max(ans,i-i1);
    }
    cout << ans;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Repetitions,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    string s;
    cin >> s;
    int ans=1, r=1;
    rep(i, 1, sz(s)) {
        if (s[i]==s[i-1]) r++;
        else r=1;
        ans=max(ans, r);
    }
    cout << ans << '\n';
    return 0;
}
"
Repetitions,Java,"// https://cses.fi/problemset/task/1069
// Repetitions
import java.io.*;

public class CSES1069 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        char[] cc = br.readLine().toCharArray();
        int n = cc.length;
        int ans = 1, cnt = 1;
        for (int i = 1; i < n; i++) {
            if (cc[i] == cc[i - 1])
                cnt++;
            else
                cnt = 1;
            if (ans < cnt)
                ans = cnt;
        }
        System.out.println(ans);
    }
}
"
Repetitions,C++,"/*
 https://cses.fi/problemset/task/1069
 Repetitions
 */
#include <stdio.h>
#include <string.h>

#define N    1000000

int main() {
    static char cc[N + 1];
    int n, i, max, cnt;
    
    scanf(""%s"", cc);
    n = strlen(cc);
    max = cnt = 0;
    for (i = 0; i < n; i++)
    if (max < (cnt = i == 0 || cc[i - 1] != cc[i] ? 1 : cnt + 1))
    max = cnt;
    printf(""%d\n"", max);
    return 0;
}
"
Trailing Zeros,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int main() {
    setIO(); int n; re(n);
    int ans = 0;
    while (n) ans += (n /= 5);
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Trailing Zeros,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, ans=0;
    cin >> n;
    while (n) ans+=(n=n/5);
    cout << ans << '\n';
    return 0;
}
"
Trailing Zeros,Java,"// https://cses.fi/problemset/task/1618
// Trailing Zeros
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1618 {
    static int solve(int n) {
        return n < 5 ? 0 : solve(n / 5) + n / 5;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        System.out.println(solve(n));
    }
}
"
Trailing Zeros,C++,"/*
 https://cses.fi/problemset/task/1618
 Trailing Zeros
 practice with Dukkha
 */
#include <stdio.h>

int zeros(int n) {
    return n == 0 ? 0 : zeros(n / 5) + n / 5;
}

int main() {
    int n;
    
    scanf(""%d"", &n);
    printf(""%d\n"", zeros(n));
    return 0;
}
"
Two Knights,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    int n; cin >> n;
    FOR(i,1,n+1) {
        ll tot = (ll)i*i;
        ll t = tot*(tot-1LL)/2;
        t -= 4LL*(i-1)*(i-2);
        cout << t << ""\n"";
    }
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Two Knights,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    rep(i, 1, n+1)
    cout << 1LL*i*i*(i*i-1)/2 - 4*(i-1)*(i-2) << '\n';
    return 0;
}
"
Two Knights,Java,"// https://cses.fi/problemset/task/1072
// Two Knights
import java.io.*;

public class CSES1072 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        int n = Integer.parseInt(br.readLine());
        for (int k = 1; k <= n; k++) {
            int k2 = k * k;
            pw.println((long) k2 * (k2 - 1) / 2 - (k - 1) * (k - 2) * 4);
        }
        pw.close();
    }
}
"
Two Knights,C++,"/*
 https://cses.fi/problemset/task/1072
 Two Knights
 */
#include <stdio.h>

int main() {
    int n, k;
    
    scanf(""%d"", &n);
    for (k = 1; k <= n; k++)
    printf(""%lld\n"", (long long) k * k * (k * k - 1) / 2 - (k - 1) * (k - 2) * 4);
    return 0;
}
"
Two Sets,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

vi a,b;

void solve(int n) {
    if (n == 3) {
        a.pb(3);
        b.pb(1), b.pb(2);
        return;
    }
    if (n == 0) return;
    a.pb(n), a.pb(n-3), b.pb(n-1), b.pb(n-2);
    solve(n-4);
}
int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    int n; cin >> n;
    if (n % 4 == 1 || n % 4 == 2) {
        cout << ""NO"";
        return 0;
    }
    solve(n);
    cout << ""YES\n"";
    cout << sz(a) << ""\n"";
    for (int i: a) cout << i << "" "";
    cout << ""\n"";
    cout << sz(b) << ""\n"";
    for (int i: b) cout << i << "" "";
    cout << ""\n"";
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Two Sets,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    if(n%4==1 || n%4==2)
    cout << ""NO\n"";
    else {
        vi a[2];
        if(n%4==3) a[0]={1, 2}, a[1]={3};
        for(int i=n%4+1; i<n; i+=4) {
            a[0].push_back(i), a[0].push_back(i+3);
            a[1].push_back(i+1), a[1].push_back(i+2);
        }
        cout << ""YES\n"";
        rep(i, 0, 2) {
            cout << sz(a[i]) << '\n';
            rep(j, 0, sz(a[i]))
            cout << a[i][j] << "" \n""[j==sz(a[i])-1];
        }
    }
    return 0;
}
"
Two Sets,Java,"// https://cses.fi/problemset/task/1092
// Two Sets
import java.io.*;
import java.util.*;

public class CSES1092 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        if (n % 4 == 1 || n % 4 == 2) {
            System.out.println(""NO"");
            return;
        }
        System.out.println(""YES"");
        StringBuilder sb1 = new StringBuilder();
        StringBuilder sb2 = new StringBuilder();
        if (n % 4 == 0) {
            for (int i = 1; i < n + 1 - i; i += 2)
                sb1.append(i + "" "" + (n + 1 - i) + "" "");
            for (int i = 2; i < n + 1 - i; i += 2)
                sb2.append(i + "" "" + (n + 1 - i) + "" "");
        } else {
            sb1.append(""1 2 "");
            sb2.append(""3 "");
            for (int i = 4; i < n + 4 - i; i += 2)
                sb1.append(i + "" "" + (n + 4 - i) + "" "");
            for (int i = 5; i < n + 4 - i; i += 2)
                sb2.append(i + "" "" + (n + 4 - i) + "" "");
        }
        System.out.println((n + 1) / 2);
        System.out.println(sb1);
        System.out.println(n / 2);
        System.out.println(sb2);
    }
}
"
Two Sets,C++,"/*
 https://cses.fi/problemset/task/1092
 Two Sets
 */
#include <stdio.h>

int main() {
    int n, i;
    
    scanf(""%d"", &n);
    if (n % 4 == 1 || n % 4 == 2) {
        printf(""NO\n"");
        return 0;
    }
    printf(""YES\n"");
    if (n % 4 == 0) {
        printf(""%d\n"", n / 2);
        for (i = 1; i < n + 1 - i; i += 2)
        printf(""%d %d "", i, n + 1 - i);
        printf(""\n"");
        printf(""%d\n"", n / 2);
        for (i = 2; i < n + 1 - i; i += 2)
        printf(""%d %d "", i, n + 1 - i);
        printf(""\n"");
    } else {
        printf(""%d\n"", n / 2 + 1);
        printf(""1 2 "");
        for (i = 4; i < n + 4 - i; i += 2)
        printf(""%d %d "", i, n + 4 - i);
        printf(""\n"");
        printf(""%d\n"", n / 2);
        printf(""3 "");
        for (i = 5; i < n + 4 - i; i += 2)
        printf(""%d %d "", i, n + 4 - i);
        printf(""\n"");
    }
    return 0;
}
"
Weird Algorithm,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    ll x; cin >> x;
    while (x != 1) {
        cout << x << "" "";
        if (x % 2 == 0) x /= 2;
        else x = 3*x+1;
    }
    cout << x;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Weird Algorithm,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    ll n;
    cin >> n;
    cout << n;
    while (n!=1) {
        n=(n%2? 3*n+1 : n/2);
        cout << "" "" << n;
    }
    cout << '\n';
    return 0;
}
"
Weird Algorithm,Java,"// https://cses.fi/problemset/task/1068
// Weird Algorithm
import java.io.*;

public class CSES1068 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        long n = Long.parseLong(br.readLine());
        StringBuilder sb = new StringBuilder();
        while (n != 1) {
            sb.append(n + "" "");
            if (n % 2 == 0)
                n /= 2;
            else
                n = n * 3 + 1;
        }
        sb.append(1);
        System.out.println(sb);
    }
}
"
Weird Algorithm,C++,"/*
 https://cses.fi/problemset/task/1068
 Weird Algorithm
 */
#include <stdio.h>

int main() {
    long long n;
    
    scanf(""%lld"", &n);
    while (n != 1) {
        printf(""%lld "", n);
        n = n % 2 == 0 ? n / 2 : n * 3 + 1;
    }
    printf(""1\n"");
    return 0;
}
"
Binomial Coefficients,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

template<int SZ> struct Combo {
    ll fac[SZ+1], ifac[SZ+1];
    
    Combo() {
        fac[0] = ifac[0] = 1;
        FOR(i,1,SZ+1) {
            fac[i] = i*fac[i-1] % MOD;
            ifac[i] = inv(fac[i]);
        }
    }
    
    ll po (ll b, ll p) {
        return !p?1:po(b*b%MOD,p/2)*(p&1?b:1)%MOD;
    }
    
    ll inv (ll b) { return po(b,MOD-2); }
    
    ll comb(ll a, ll b) {
        if (a < b) return 0;
        ll tmp = fac[a]*ifac[b] % MOD;
        tmp = tmp*ifac[a-b] % MOD;
        return tmp;
    }
};

Combo<1000000> C;

int main() {
    int n; cin >> n;
    F0R(i,n) {
        int a,b; cin >> a >> b;
        cout << C.comb(a,b) << ""\n"";
    }
}
"
Binomial Coefficients,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

const ll mod = 1000000007; // faster if const

ll modpow(ll b, ll e) {
    ll ans = 1;
    for (; e; b = b * b % mod, e /= 2)
        if (e & 1) ans = ans * b % mod;
    return ans;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int N=1e6+1;
    vector<ll> f(N), invf(N);
    
    const ll LIM = N;
    ll* inv = new ll[LIM] - 1; inv[1] = 1;
    rep(i,2,LIM) inv[i] = mod - (mod / i) * inv[mod % i] % mod;
    
    f[0]=invf[0]=1;
    rep(i, 1, N) f[i]=f[i-1]*i%mod;
    rep(i, 1, N) invf[i]=invf[i-1]*inv[i]%mod;
    int t;
    cin >> t;
    while (t--) {
        int a, b;
        cin >> a >> b;
        cout << f[a]*invf[b]%mod*invf[a-b]%mod << '\n';
    }
    return 0;
}
"
Binomial Coefficients,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

const ll mod = 1000000007; // faster if const

ll modpow(ll b, ll e) {
    ll ans = 1;
    for (; e; b = b * b % mod, e /= 2)
        if (e & 1) ans = ans * b % mod;
    return ans;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int N=1e6+1;
    vector<ll> f(N), invf(N);
    
    f[0]=invf[0]=1;
    rep(i, 1, N) f[i]=f[i-1]*i%mod;
    invf[N-1]=modpow(f[N-1], mod-2);
    rep(i, 1, N) invf[N-i-1]=invf[N-i]*(N-i)%mod;
    int t;
    cin >> t;
    while (t--) {
        int a, b;
        cin >> a >> b;
        cout << f[a]*invf[b]%mod*invf[a-b]%mod << '\n';
    }
    return 0;
}
"
Binomial Coefficients,Java,"// https://cses.fi/problemset/task/1079
// Binomial Coefficients
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1079 {
    static final int MD = 1000000007, A = 1000000;
    static int[] ff, gg;
    static long power(long a, int k) {
        if (k == 0)
            return 1;
        long p = power(a, k / 2);
        p = p * p % MD;
        if (k % 2 == 1)
            p = p * a % MD;
        return p;
    }
    static void init() {
        ff = new int[A + 1];
        gg = new int[A + 1];
        long f = 1;
        for (int a = 0; a <= A; a++) {
            ff[a] = (int) f;
            gg[a] = (int) power(f, MD - 2);
            f = f * (a + 1) % MD;
        }
    }
    public static void main(String[] args) throws IOException {
        init();
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        while (n-- > 0) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            pw.println((long) ff[a] * gg[b] % MD * gg[a - b] % MD);
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb); //if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Binomial Coefficients,Java,"// https://cses.fi/problemset/task/1079
// Binomial Coefficients
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1079 {
    static final int MD = 1000000007, A = 1000000;
    static int[] ff, gg;
    static long power(long a, int k) {
        if (k == 0)
            return 1;
        long p = power(a, k / 2);
        p = p * p % MD;
        if (k % 2 == 1)
            p = p * a % MD;
        return p;
    }
    static void init() {
        ff = new int[A + 1];
        gg = new int[A + 1];
        long f = 1;
        for (int a = 0; a <= A; a++) {
            ff[a] = (int) f;
            gg[a] = (int) power(f, MD - 2);
            f = f * (a + 1) % MD;
        }
    }
    public static void main(String[] args) throws IOException {
        init();
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        while (n-- > 0) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            pw.println((long) ff[a] * gg[b] % MD * gg[a - b] % MD);
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Binomial Coefficients,C++,"/*
 https://cses.fi/problemset/task/1079
 Binomial Coefficients
 practice with Dukkha
 */
#include <stdio.h>

#define N    1000000
#define MD    1000000007

int ff[N + 1], gg[N + 1];

long long power(int a, int b) {
    long long p;
    
    if (b == 0)
        return 1;
    p = power(a, b / 2);
    p = p * p % MD;
    if (b % 2)
        p = p * a % MD;
    return p;
}

void init() {
    int a;
    long long f = 1;
    
    for (a = 0; a <= N; a++) {
        ff[a] = f;
        gg[a] = power(f, MD - 2);
        f = f * (a + 1) % MD;
    }
}

int main() {
    int n;
    
    init();
    scanf(""%d"", &n);
    while (n--) {
        int a, b;
        
        scanf(""%d%d"", &a, &b);
        printf(""%lld\n"", (long long) ff[a] * gg[b] % MD * gg[a - b] % MD);
    }
    return 0;
}
"
Candy Lottery,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,k;

int main() {
    setIO(); cout << fixed << setprecision(6);
    re(n,k);
    ld ans = 0;
    FOR(i,1,k+1) ans += 1-pow((ld)(i-1)/k,n);
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Candy Lottery,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, k;
    cin >> n >> k;
    long double s=k;
    rep(i, 1, k) s-=pow(i*1.0L/k, n);
    cout << setprecision(6) << fixed;
    cout << s << '\n';
    return 0;
}
"
Candy Lottery,Java,"// https://cses.fi/problemset/task/1727
// Candy Lottery
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1727 {
    static double power(double a, int k) {
        if (k == 0)
            return 1;
        double p = power(a, k / 2);
        p *= p;
        if (k % 2 == 1)
            p *= a;
        return p;
    }
    public static void main(String[] __) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out, true);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        double ans = k;
        for (int x = 1; x < k; x++)
            ans -= power((double) x / k, n);
        pw.printf(""%.6f\n"", ans);
        pw.close();
    }
}
"
Candy Lottery,C++,"/*
 https://cses.fi/problemset/task/1727
 Candy Lottery
 practice with Dukkha
 */
#include <stdio.h>

double power(double a, int k) {
    double p;
    
    if (k == 0)
        return 1;
    p = power(a, k / 2);
    p *= p;
    if (k % 2)
        p *= a;
    return p;
}

int main() {
    int n, k, x;
    double ans;
    
    scanf(""%d%d"", &n, &k);
    ans = k;
    for (x = 1; x < k; x++)
        ans -= power((double) x / k, n);
    printf(""%.6f\n"", ans);
    return 0;
}
"
Christmas Party,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n;
mi dp[1000001];

int main() {
    setIO(); dp[2] = 1; re(n);
    FOR(i,3,n+1) dp[i] = (i-1)*(dp[i-1]+dp[i-2]);
    ps(dp[n]);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Christmas Party,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr ll P=1e9+7;
    ll n, ans=0;
    cin >> n;
    rep(i, 2, n+1)
    ans=(ans*i+(i%2? P-1:1))%P;
    cout << ans << '\n';
    return 0;
}
"
Christmas Party,Java,"// https://cses.fi/problemset/task/1717
// Christmas Party
// practice with rainboy
import java.io.*;

public class CSES1717 {
    static final int MD = 1000000007;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int k;
        if (n == 1)
            k = 0;
        else {
            int a = 0, b = 1;
            k = b;
            for (int i = 2; i < n; i++) {
                k = (int) ((long) (a + b) * i % MD); a = b; b = k;
            }
        }
        System.out.println(k);
    }
}
"
Christmas Party,C++,"/*
 https://cses.fi/problemset/task/1717
 Christmas Party
 practice with Dukkha
 */
#include <stdio.h>

#define MD    1000000007

int main() {
    int n, a, b, k, i;
    
    scanf(""%d"", &n);
    if (n == 1)
        k = 0;
    else {
        a = 0, b = 1;
        k = b;
        for (i = 2; i < n; i++)
            k = (long long) (a + b) * i % MD, a = b, b = k;
    }
    printf(""%d\n"", k);
    return 0;
}
"
Common Divisors,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int co[1000001], n;

int get(int ind) {
    int z = 0;
    for (int i = ind; i <= 1000000; i += ind) z += co[i];
    return z;
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n;
    F0R(i,n) {
        int x; cin >> x;
        co[x] ++;
    }
    FORd(i,1,1000001) if (get(i) > 1) {
        cout << i;
        return 0;
    }
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Common Divisors,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int M=1000000;
    vi c(M+1);
    int n;
    cin >> n;
    rep(i, 0, n) {
        int x;
        cin >> x;
        c[x]++;
    }
    int ans=1;
    rep(i, 2, M+1) {
        int cnt=0;
        for(int j=i; j<=M; j+=i)
            cnt+=c[j];
        if (cnt>=2) ans=i;
    }
    cout << ans << '\n';
    return 0;
}
"
Common Divisors,Java,"// https://cses.fi/problemset/task/1081
// Common Divisors
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1081 {
    static final int X = 1000000;
    static int[] kk = new int[X + 1];
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        if (n == 1) {
            int x = sc.nextInt();
            System.out.println(x);
            return;
        }
        while (n-- > 0) {
            int x = sc.nextInt();
            kk[x]++;
        }
        for (int a = X; a >= 2; a--) {
            int k = 0;
            for (int b = a; b <= X; b += a)
                k += kk[b];
            if (k >= 2) {
                System.out.println(a);
                return;
            }
        }
        System.out.println(1);
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Common Divisors,C++,"/*
 https://cses.fi/problemset/task/1081
 Common Divisors
 practice with Dukkha
 */
#include <stdio.h>

#define X    1000000

int main() {
    static int kk[X + 1];
    int n, x, a, b, k;
    
    scanf(""%d"", &n);
    if (n == 1) {
        scanf(""%d"", &x);
        printf(""%d\n"", x);
        return 0;
    }
    while (n--) {
        scanf(""%d"", &x);
        kk[x]++;
    }
    for (a = X; a >= 2; a--) {
        k = 0;
        for (b = a; b <= X; b += a)
            k += kk[b];
        if (k >= 2) {
            printf(""%d\n"", a);
            return 0;
        }
    }
    printf(""1\n"");
    return 0;
}
"
Counting Divisors,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

namespace basicFactor {
    template<class T> vector<pair<T,int>> factor(T x) { // x <= 10^{14} is fine
        vector<pair<T,int>> pri;
        
        for (T i = 2; i*i <= x; ++i) if (x % i == 0) {
            int t = 0;
            while (x % i == 0) x /= i, t ++;
            pri.pb({i,t});
        }
        
        if (x > 1) pri.pb({x,1});
        return pri;
    }
    
    /* Note:
     * number of operations needed s.t.
     *                phi(phi(...phi(n)...))=1
     * is O(log n).
     * Euler's theorem: a^{\phi(p)}\equiv 1 (mod p), gcd(a,p)=1
     */
    
    ll phi(ll x) {
        trav(a,factor(x)) x /= a.f, x *= a.f-1;
        return x;
    }
    
    template<class T> void tour(vector<pair<T,int>>& v, vector<T>& V, int ind, T cur) {
        if (ind == sz(v)) V.pb(cur);
        else {
            T mul = 1;
            F0R(i,v[ind].s+1) {
                tour(v,V,ind+1,cur*mul);
                mul *= v[ind].f;
            }
        }
    }
    
    template<class T> vector<T> getDivi(T x) {
        auto v = factor(x);
        vector<T> V; tour(v,V,0,(T)1); sort(all(V));
        return V;
    }
}

using namespace basicFactor;

int n;

int main() {
    setIO();
    re(n);
    F0R(i,n) {
        int x; re(x);
        ps(sz(getDivi(x)));
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Counting Divisors,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int N=1e6+10;
    vi d(N);
    rep(i, 1, N) for(int j=i; j<N; j+=i) d[j]++;
    int q;
    cin >> q;
    while (q--) {
        int a;
        cin >> a;
        cout << d[a] << '\n';
    }
    return 0;
}
"
Counting Divisors,Java,"// https://cses.fi/problemset/task/1713
// Counting Divisors
// practice with rainboy
import java.io.*;

public class CSES1713 {
    static final int N = 1000000;
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int[] dd = new int[N + 1];
        for (int a = 1; a <= N; a++)
            for (int b = a; b <= N; b += a)
                dd[b]++;
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            pw.println(dd[n]);
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Counting Divisors,C++,"/*
 https://cses.fi/problemset/task/1713
 Counting Divisors
 practice with Dukkha
 */
#include <stdio.h>

#define N    1000000

int main() {
    static int dd[N + 1];
    int a, b, t;
    
    for (a = 1; a <= N; a++)
        for (b = a; b <= N; b += a)
            dd[b]++;
    scanf(""%d"", &t);
    while (t--) {
        int n;
        
        scanf(""%d"", &n);
        printf(""%d\n"", dd[n]);
    }
    return 0;
}
"
Creating Strings II,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;


template<int SZ> struct Combo {
    mi smallInv[SZ], fac[SZ], ifac[SZ];
    vpi factors; vi cnt[SZ];
    
    void genInv() {
        if (sz(factors) == 1 && factors[0].s == 1) {
            F0R(i,2) smallInv[i] = i;
            FOR(i,2,SZ) { // use only O(SZ) operations for MOD a prime
                int x = (MOD+i-1)/i;
                smallInv[i] = smallInv[i*x-MOD]*x;
            }
        } else {
            F0R(i,SZ) {
                int x = invGeneral(i,MOD);
                if (x == -1) smallInv[i] = 0;
                else smallInv[i] = x;
            }
        }
    }
    
    void init() {
        // factors = factor(MOD);
        factors = {{MOD,1}};
        genInv(); cnt[0] = vi(sz(factors)); fac[0] = ifac[0] = 1;
        FOR(i,1,SZ) {
            cnt[i] = cnt[i-1]; int I = i;
            F0R(j,sz(factors)) while (I % factors[j].f == 0)
                I /= factors[j].f, cnt[i][j] ++;
            fac[i] = fac[i-1]*I; ifac[i] = ifac[i-1]*smallInv[I];
        }
    }
    
    mi comb(int a, int b) {
        if (a < b || b < 0) return 0;
        auto tmp = fac[a]*ifac[b]*ifac[a-b];
        F0R(i,sz(factors)) {
            int t = cnt[a][i]-cnt[a-b][i]-cnt[b][i];
            tmp *= exp(mi(factors[i].f),t);
        }
        return tmp;
    }
};

Combo<1000001> C;
string s;
int co[26];

int main() {
    setIO(); re(s);
    trav(t,s) co[t-'a'] ++;
    C.init();
    mi ans = C.fac[sz(s)];
    F0R(i,26) ans *= C.ifac[co[i]];
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Creating Strings II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

const ll P = 1000000007;

ll modpow(ll b, ll e) {
    ll ans = 1;
    for (; e; b = b * b % P, e /= 2)
        if (e & 1) ans = ans * b % P;
    return ans;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    string s;
    cin >> s;
    int n=sz(s);
    vector<ll> f(n+1), invf(n+1);
    f[0]=1;
    rep(i, 1, n+1)
    f[i]=f[i-1]*i%P;
    invf[n]=modpow(f[n], P-2);
    for(int i=n; i; i--)
        invf[i-1]=invf[i]*i%P;
    vi cnt(26);
    trav(c, s) cnt[c-'a']++;
    ll ans=f[n];
    trav(i, cnt)
    ans=ans*invf[i]%P;
    cout << ans << '\n';
    return 0;
}
"
Creating Strings II,Java,"// https://cses.fi/problemset/task/1715
// Creating Strings II
// practice with rainboy
import java.io.*;

public class CSES1715 {
    static final int A = 26, MD = 1000000007;
    static long power(int a, int k) {
        if (k == 0)
            return 1;
        long p = power(a, k / 2);
        p = p * p % MD;
        if (k % 2 == 1)
            p = p * a % MD;
        return p;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        char[] cc = br.readLine().toCharArray();
        int n = cc.length;
        int[] kk = new int[A];
        for (int i = 0; i < n; i++)
            kk[cc[i] - 'a']++;
        int[] ff = new int[n + 1];
        int f = 1;
        for (int i = 0; i <= n; i++) {
            ff[i] = f;
            f = (int) ((long) f * (i + 1) % MD);
        }
        long ans = ff[n];
        for (int a = 0; a < A; a++)
            ans = ans * power(ff[kk[a]], MD - 2) % MD;
        System.out.println(ans);
    }
}
"
Creating Strings II,C++,"/*
 https://cses.fi/problemset/task/1715
 Creating Strings II
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    1000000
#define A    26
#define MD    1000000007

long long power(int a, int k) {
    long long p;
    
    if (k == 0)
        return 1;
    p = power(a, k / 2);
    p = p * p % MD;
    if (k % 2)
        p = p * a % MD;
    return p;
}

int main() {
    static char cc[N + 1];
    static int kk[A], ff[N + 1];
    int n, i, f, c;
    long long ans;
    
    scanf(""%s"", cc);
    n = strlen(cc);
    for (i = 0; i < n; i++)
        kk[cc[i] - 'a']++;
    for (i = 0, f = 1; i <= n; i++) {
        ff[i] = f;
        f = (long long) f * (i + 1) % MD;
    }
    ans = ff[n];
    for (c = 0; c < 26; c++)
        ans = ans * power(ff[kk[c]], MD - 2) % MD;
    printf(""%lld\n"", ans);
    return 0;
}
"
Dice Probability,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

vd prob(1);
int n;

void adv() {
    vd PROB(sz(prob)+7);
    F0R(i,sz(prob)) FOR(j,1,7) PROB[i+j] += prob[i]/6;
    swap(prob,PROB);
}

int main() {
    setIO(); prob[0] = 1; re(n); F0R(i,n) adv();
    int a,b; re(a,b);
    ld ans = 0; FOR(i,a,b+1) ans += prob[i];
    cout << fixed << setprecision(6) << ans;
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Dice Probability,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    typedef long double dbl;
    int n, a, b;
    cin >> n >> a >> b;
    vector<dbl> dp(b+1);
    dp[0]=1;
    rep(i, 0, n) {
        for(int j=b; j>=0; j--) {
            dp[j]=0;
            rep(k, 1, 7) if (j>=k) dp[j]+=dp[j-k];
        }
    }
    dbl ans=0;
    rep(i, a, b+1) ans+=dp[i];
    cout << fixed << setprecision(6);
    cout << ans/pow(6, n) << '\n';
    return 0;
}
"
Dice Probability,Java,"// https://cses.fi/problemset/task/1725
// Dice Probability
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1725 {
    public static void main(String[] __) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out, true);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int a = Integer.parseInt(st.nextToken());
        int b = Integer.parseInt(st.nextToken());
        int m = n * 6;
        double[] dp = new double[m + 1];
        dp[0] = 1;
        while (n-- > 0)
            for (int j = m; j >= 0; j--) {
                double x = dp[j] / 6;
                for (int h = 1; h <= 6 && j + h <= m; h++)
                    dp[j + h] += x;
                dp[j] = 0;
            }
        double ans = 0;
        for (int j = a; j <= b; j++)
            ans += dp[j];
        pw.printf(""%.6f\n"", ans);
        pw.close();
    }
}
"
Dice Probability,C++,"/*
 https://cses.fi/problemset/task/1725
 Dice Probability
 practice with Dukkha
 */
#include <stdio.h>

#define N    100
#define M    (N * 6)

int main() {
    static double dp[M + 1];
    int n, m, a, b, h, j;
    double ans;
    
    scanf(""%d%d%d"", &n, &a, &b);
    m = n * 6;
    dp[0] = 1;
    while (n--)
        for (j = m; j >= 0; j--) {
            double x = dp[j] / 6;
            
            for (h = 1; h <= 6 && j + h <= m; h++)
                dp[j + h] += x;
            dp[j] = 0;
        }
    ans = 0;
    for (j = a; j <= b; j++)
        ans += dp[j];
    printf(""%.6f\n"", ans);
    return 0;
}
"
Distributing Apples,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;


template<int SZ> struct Combo {
    mi smallInv[SZ], fac[SZ], ifac[SZ];
    vpi factors; vi cnt[SZ];
    
    void genInv() {
        if (sz(factors) == 1 && factors[0].s == 1) {
            F0R(i,2) smallInv[i] = i;
            FOR(i,2,SZ) { // use only O(SZ) operations for MOD a prime
                int x = (MOD+i-1)/i;
                smallInv[i] = smallInv[i*x-MOD]*x;
            }
        } else {
            F0R(i,SZ) {
                int x = invGeneral(i,MOD);
                if (x == -1) smallInv[i] = 0;
                else smallInv[i] = x;
            }
        }
    }
    
    void init() {
        // factors = factor(MOD);
        factors = {{MOD,1}};
        genInv(); cnt[0] = vi(sz(factors)); fac[0] = ifac[0] = 1;
        FOR(i,1,SZ) {
            cnt[i] = cnt[i-1]; int I = i;
            F0R(j,sz(factors)) while (I % factors[j].f == 0)
                I /= factors[j].f, cnt[i][j] ++;
            fac[i] = fac[i-1]*I; ifac[i] = ifac[i-1]*smallInv[I];
        }
    }
    
    mi comb(int a, int b) {
        if (a < b || b < 0) return 0;
        auto tmp = fac[a]*ifac[b]*ifac[a-b];
        F0R(i,sz(factors)) {
            int t = cnt[a][i]-cnt[a-b][i]-cnt[b][i];
            tmp *= exp(mi(factors[i].f),t);
        }
        return tmp;
    }
};

Combo<2000005> C;

int main() {
    setIO();  C.init();
    int n,m; re(n,m);
    ps(C.comb(n-1+m,m));
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Distributing Apples,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;


const ll mod = 1000000007; // faster if const

ll modpow(ll b, ll e) {
    ll ans = 1;
    for (; e; b = b * b % mod, e /= 2)
        if (e & 1) ans = ans * b % mod;
    return ans;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    vector<ll> f(n+m, 1);
    rep(i, 1, n+m) f[i]=f[i-1]*i%mod;
    ll ans=f[n+m-1]*modpow(f[n-1], mod-2)%mod;
    ans=ans*modpow(f[m], mod-2)%mod;
    cout << ans << '\n';
    return 0;
}
"
Distributing Apples,Java,"// https://cses.fi/problemset/task/1716
// Distributing Apples
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1716 {
    static final int MD = 1000000007;
    static long power(long a, int k) {
        if (k == 0)
            return 1;
        long p = power(a, k / 2);
        p = p * p % MD;
        if (k % 2 == 1)
            p = p * a % MD;
        return p;
    }
    static int choose(int a, int b) {
        int c = a - b;
        int fa = 0, fb = 0, fc = 0;
        int f = 1;
        for (int i = 0; i <= a; i++) {
            if (i == a)
                fa = f;
            if (i == b)
                fb = f;
            if (i == c)
                fc = f;
            f = (int) ((long) f * (i + 1) % MD);
        }
        return (int) (fa * power((long) fb * fc % MD, MD - 2) % MD);
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        System.out.println(choose(m + n - 1, m));
    }
}
"
Distributing Apples,C++,"/*
 https://cses.fi/problemset/task/1716
 Distributing Apples
 practice with Dukkha
 */
#include <stdio.h>

#define MD    1000000007

long long power(int a, int k) {
    long long p;
    
    if (k == 0)
        return 1;
    p = power(a, k / 2);
    p = p * p % MD;
    if (k % 2)
        p = p * a % MD;
    return p;
}

int choose(int a, int b) {
    int c = a - b, fa, fb, fc, f, i;
    
    f = 1;
    for (i = 0; i <= a; i++) {
        if (i == a)
            fa = f;
        if (i == b)
            fb = f;
        if (i == c)
            fc = f;
        f = (long long) f * (i + 1) % MD;
    }
    return fa * power((long long) fb * fc % MD, MD - 2) % MD;
}

int main() {
    int n, m;
    
    scanf(""%d%d"", &n, &m);
    printf(""%d\n"", choose(m + n - 1, m));
    return 0;
}
"
Exponentiation,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

ll po (ll b, ll p) {
    return !p?1:po(b*b%MOD,p/2)*(p&1?b:1)%MOD;
}

int n;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n;
    F0R(i,n) {
        int a,b; cin >> a >> b;
        cout << po(a,b) << ""\n"";
    }
}
"
Exponentiation,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr ll P=1e9+7;

ll modpow(ll b, ll e) {
    ll ans = 1;
    for (; e; b = b * b % P, e /= 2)
        if (e & 1) ans = ans * b % P;
    return ans;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int t;
    cin >> t;
    while (t--) {
        ll a, b;
        cin >> a >> b;
        cout << modpow(a, b) << '\n';
    }
    return 0;
}
"
Exponentiation,Java,"// https://cses.fi/problemset/task/1095
// Exponentiation
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1095 {
    static final int MD = 1000000007;
    static long power(int a, int b) {
        if (b == 0)
            return 1;
        long p = power(a, b / 2);
        p = p * p % MD;
        if (b % 2 == 1)
            p = p * a % MD;
        return p;
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        PrintWriter pw = new PrintWriter(System.out);
        while (n-- > 0) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            pw.println(power(a, b));
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb); //if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        String next() throws IOException {
            StringBuilder sb = new StringBuilder();
            for (byte b = skip(); b > 32; b = getc())
                sb.append((char) b);
            return sb.toString();
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Exponentiation,Java,"// https://cses.fi/problemset/task/1095
// Exponentiation
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1095 {
    static final int MD = 1000000007;
    static long power(int a, int b) {
        if (b == 0)
            return 1;
        long p = power(a, b / 2);
        p = p * p % MD;
        if (b % 2 == 1)
            p = p * a % MD;
        return p;
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        PrintWriter pw = new PrintWriter(System.out);
        while (n-- > 0) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            pw.println(power(a, b));
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Exponentiation,C++,"/*
 https://cses.fi/problemset/task/1095
 Exponentiation
 practice with Dukkha
 */
#include <stdio.h>

#define MD    1000000007

long long power(int a, int b) {
    long long p;
    
    if (b == 0)
        return 1;
    p = power(a, b / 2);
    p = p * p % MD;
    if (b % 2 == 1)
        p = p * a % MD;
    return p;
}

int main() {
    int n;
    
    scanf(""%d"", &n);
    while (n--) {
        int a, b;
        
        scanf(""%d%d"", &a, &b);
        printf(""%lld\n"", power(a, b));
    }
    return 0;
}
"
Exponentiation II,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n;

int main() {
    setIO();
    re(n);
    F0R(i,n) {
        int a,b,c; re(a,b,c);
        if (b == 0 && c != 0) ps(1);
        else {
            MOD --;
            int t = (int)exp(mi(b),c);
            MOD ++;
            ps(exp(mi(a),t));
        }
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Exponentiation II,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n;

int main() {
    setIO();
    re(n);
    F0R(i,n) {
        int a,b,c; re(a,b,c);
        if (a == 0) {
            if (b == 0 && c != 0) ps(1);
            else ps(0);
        } else {
            MOD --;
            int t = (int)exp(mi(b),c);
            MOD ++;
            ps(exp(mi(a),t));
        }
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Exponentiation II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

ll modpow(ll b, ll e, ll mod) {
    ll ans = 1;
    for (; e; b = b * b % mod, e /= 2)
        if (e & 1) ans = ans * b % mod;
    return ans;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr ll P=1e9+7;
    ll t;
    cin >> t;
    while (t--) {
        ll a, b, c;
        cin >> a >> b >> c;
        ll e=modpow(b, c, P-1);
        cout << modpow(a, e, P) << '\n';
    }
    return 0;
}
"
Exponentiation II,Java,"// https://cses.fi/problemset/task/1712
// Exponentiation II
// practice with rainboy
import java.io.*;

public class CSES1712 {
    static final int MD = 1000000007, T = MD - 1;
    static long power(int a, int k, int md) {
        if (k == 0)
            return 1;
        long p = power(a, k / 2, md);
        p = p * p % md;
        if (k % 2 == 1)
            p = p * a % md;
        return p;
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        while (n-- > 0) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            int c = sc.nextInt();
            pw.println(power(a, (int) power(b, c, T), MD));
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Exponentiation II,C++,"/*
 https://cses.fi/problemset/task/1712
 Exponentiation II
 practice with Dukkha
 */
#include <stdio.h>

#define MD    1000000007
#define T    (MD - 1)

long long power(int a, int k, int md) {
    long long p;
    
    if (k == 0)
        return 1;
    p = power(a, k / 2, md);
    p = p * p % md;
    if (k % 2)
        p = p * a % md;
    return p;
}

int main() {
    int n;
    
    scanf(""%d"", &n);
    while (n--) {
        int a, b, c;
        
        scanf(""%d%d%d"", &a, &b, &c);
        printf(""%lld\n"", power(a, power(b, c, T), MD));
    }
    return 0;
}
"
Fibonacci Numbers,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<class T> struct Mat {
    T** d;
    int a, b;
    
    Mat() { a = b = 0; }
    Mat(int _a, int _b) : a(_a), b(_b) {
        d = new T*[a];
        F0R(i,a) {
            d[i] = new T[b];
            F0R(j,b) d[i][j] = 0;
        }
    }
    Mat (const vector<vector<T>>& v) : Mat(sz(v),sz(v[0])) {
        F0R(i,a) F0R(j,b) d[i][j] = v[i][j];
    }
    
    operator vector<vector<T>> () {
        auto ret = vector<vector<T>>(a,vector<T>(b));
        F0R(i,a) F0R(j,b) ret[i][j] = d[i][j];
        return ret;
    }
    friend void pr(const Mat& m) {
        Mat M(m); pr(vector<vector<T>>(M));
    }
    
    Mat operator+(const Mat& m) {
        assert(a == m.a && b == m.b);
        Mat r(a,b);
        F0R(i,a) F0R(j,b) r.d[i][j] = d[i][j]+m.d[i][j];
        return r;
    }
    Mat operator-(const Mat& m) {
        assert(a == m.a && b == m.b);
        Mat r(a,b);
        F0R(i,a) F0R(j,b) r.d[i][j] = d[i][j]-m.d[i][j];
        return r;
    }
    Mat operator*(const Mat& m) {
        assert(b == m.a);
        Mat r(a,m.b);
        F0R(i,a) F0R(j,b) F0R(k,m.b) r.d[i][k] += d[i][j]*m.d[j][k];
        return r;
    }
    
    Mat& operator+=(const Mat& m) { return *this = (*this)+m; }
    Mat& operator-=(const Mat& m) { return *this = (*this)-m; }
    Mat& operator*=(const Mat& m) { return *this = (*this)*m; }
    
    friend Mat exp(Mat m, ll p) {
        Mat r(m.a,m.a); assert(m.a == m.b);
        F0R(i,m.a) r.d[i][i] = 1;
        for (; p; p /= 2, m *= m) if (p&1) r *= m;
        return r;
    }
};

Mat<mi> M;

int main() {
    setIO(); ll n; re(n);
    M = exp(Mat<mi>({{1,1},{1,0}}),n);
    ps(M.d[1][0]);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Fibonacci Numbers,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

const ll mod = 1e9+7;

typedef vector<ll> Poly;
ll linearRec(Poly S, Poly tr, ll k) {
    int n = sz(tr);
    
    auto combine = [&](Poly a, Poly b) {
        Poly res(n * 2 + 1);
        rep(i,0,n+1) rep(j,0,n+1)
        res[i + j] = (res[i + j] + a[i] * b[j]) % mod;
        for (int i = 2 * n; i > n; --i) rep(j,0,n)
            res[i - 1 - j] = (res[i - 1 - j] + res[i] * tr[j]) % mod;
        res.resize(n + 1);
        return res;
    };
    
    Poly pol(n + 1), e(pol);
    pol[0] = e[1] = 1;
    
    for (++k; k; k /= 2) {
        if (k % 2) pol = combine(pol, e);
        e = combine(e, e);
    }
    
    ll res = 0;
    rep(i,0,n) res = (res + pol[i + 1] * S[i]) % mod;
    return res;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    ll n;
    cin >> n;
    cout << linearRec({0, 1}, {1, 1}, n) << '\n';
    return 0;
}
"
Fibonacci Numbers,Java,"// https://cses.fi/problemset/task/1722
// Fibonacci Numbers
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1722 {
    static final int MD = 1000000007;
    static void mult(int[][] aa, int[][] bb, int[][] cc) {
        for (int i = 0; i < 2; i++)
            for (int j = 0; j < 2; j++) {
                long c = 0;
                for (int k = 0; k < 2; k++)
                    c += (long) aa[i][k] * bb[k][j];
                cc[i][j] = (int) (c % MD);
            }
    }
    static void power(int[][] aa, int[][] pp, int[][] tt, long k) {
        if (k == 0) {
            pp[0][0] = pp[1][1] = 1;
            pp[0][1] = pp[1][0] = 0;
            return;
        }
        if (k % 2 == 0) {
            power(aa, tt, pp, k / 2);
            mult(tt, tt, pp);
        } else {
            power(aa, pp, tt, k / 2);
            mult(pp, pp, tt);
            mult(tt, aa, pp);
        }
    }
    public static void main(String[] __) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out, true);
        StringTokenizer st;
        int[][] aa = new int[2][2];
        int[][] pp = new int[2][2];
        int[][] tt = new int[2][2];
        aa[0][1] = aa[1][0] = aa[1][1] = 1;
        st = new StringTokenizer(br.readLine());
        long n = Long.parseLong(st.nextToken());
        power(aa, pp, tt, n);
        pw.println(pp[0][1]);
        pw.close();
    }
}
"
Fibonacci Numbers,C++,"/*
 https://cses.fi/problemset/task/1722
 Fibonacci Numbers
 practice with Dukkha
 */
#include <stdio.h>

#define MD    1000000007

void mult(int aa[][2], int bb[][2], int cc[][2]) {
    int i, j, k;
    
    for (i = 0; i < 2; i++)
        for (j = 0; j < 2; j++) {
            int c = 0;
            
            for (k = 0; k < 2; k++)
                c = (c + (long long) aa[i][k] * bb[k][j]) % MD;
            cc[i][j] = c;
        }
}

void power(int aa[][2], int pp[][2], int tt[][2], long long k) {
    if (k == 0) {
        pp[0][0] = 1; pp[0][1] = 0;
        pp[1][0] = 0; pp[1][1] = 1;
        return;
    }
    if (k % 2 == 0) {
        power(aa, tt, pp, k / 2);
        mult(tt, tt, pp);
    } else {
        power(aa, pp, tt, k / 2);
        mult(pp, pp, tt);
        mult(tt, aa, pp);
    }
}

int main() {
    static int aa[2][2], pp[2][2], tt[2][2];
    long long n;
    
    scanf(""%lld"", &n);
    aa[0][0] = 0; aa[0][1] = 1;
    aa[1][0] = 1; aa[1][1] = 1;
    power(aa, pp, tt, n);
    printf(""%d\n"", pp[0][1]);
    return 0;
}
"
Graph Paths I,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<class T> struct Mat {
    T** d;
    int a, b;
    
    Mat() { a = b = 0; }
    Mat(int _a, int _b) : a(_a), b(_b) {
        d = new T*[a];
        F0R(i,a) {
            d[i] = new T[b];
            F0R(j,b) d[i][j] = 0;
        }
    }
    Mat (const vector<vector<T>>& v) : Mat(sz(v),sz(v[0])) {
        F0R(i,a) F0R(j,b) d[i][j] = v[i][j];
    }
    
    operator vector<vector<T>> () {
        auto ret = vector<vector<T>>(a,vector<T>(b));
        F0R(i,a) F0R(j,b) ret[i][j] = d[i][j];
        return ret;
    }
    friend void pr(const Mat& m) {
        Mat M(m); pr(vector<vector<T>>(M));
    }
    
    Mat operator+(const Mat& m) {
        assert(a == m.a && b == m.b);
        Mat r(a,b);
        F0R(i,a) F0R(j,b) r.d[i][j] = d[i][j]+m.d[i][j];
        return r;
    }
    Mat operator-(const Mat& m) {
        assert(a == m.a && b == m.b);
        Mat r(a,b);
        F0R(i,a) F0R(j,b) r.d[i][j] = d[i][j]-m.d[i][j];
        return r;
    }
    Mat operator*(const Mat& m) {
        assert(b == m.a);
        Mat r(a,m.b);
        F0R(i,a) F0R(j,b) F0R(k,m.b) r.d[i][k] += d[i][j]*m.d[j][k];
        return r;
    }
    
    Mat& operator+=(const Mat& m) { return *this = (*this)+m; }
    Mat& operator-=(const Mat& m) { return *this = (*this)-m; }
    Mat& operator*=(const Mat& m) { return *this = (*this)*m; }
    
    friend Mat exp(Mat m, ll p) {
        Mat r(m.a,m.a); assert(m.a == m.b);
        F0R(i,m.a) r.d[i][i] = 1;
        for (; p; p /= 2, m *= m) if (p&1) r *= m;
        return r;
    }
};

Mat<mi> M;
int n,m,k;

int main() {
    setIO(); re(n,m,k);
    M = Mat<mi>(n,n);
    F0R(i,m) {
        int a,b; re(a,b);
        M.d[a-1][b-1] += 1;
    }
    M = exp(M,k);
    ps(M.d[0][n-1]);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Graph Paths I,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<class T> struct Mat {
    int r,c;
    vector<vector<T>> d;
    Mat(int _r, int _c) : r(_r), c(_c) {
        d.assign(r,vector<T>(c));
    }
    Mat (const vector<vector<T>>& _d) : r(sz(_d)), c(sz(_d[0])) {
        d = _d;
    }
    
    friend void pr(const Mat& m) { pr(m.d); }
    Mat& operator+=(const Mat& m) {
        assert(r == m.r && c == m.c);
        F0R(i,r) F0R(j,c) d[i][j] += m.d[i][j];
        return *this;
    }
    Mat operator-=(const Mat& m) {
        assert(r == m.r && c == m.c);
        F0R(i,r) F0R(j,c) d[i][j] -= m.d[i][j];
        return *this;
    }
    Mat operator*(const Mat& m) {
        assert(c == m.r); Mat x(r,m.c);
        F0R(i,r) F0R(j,c) F0R(k,m.c) x.d[i][k] += d[i][j]*m.d[j][k];
        return x;
    }
    
    Mat operator+(const Mat& m) { return Mat(*this)+=m; }
    Mat operator-(const Mat& m) { return Mat(*this)-=m; }
    Mat& operator*=(const Mat& m) { return *this = (*this)*m; }
    
    friend Mat exp(Mat m, ll p) {
        assert(m.r == m.c);
        Mat r(m.r,m.c);
        F0R(i,m.r) r.d[i][i] = 1;
        for (; p; p /= 2, m *= m) if (p&1) r *= m;
        return r;
    }
};

int n,m,k;

int main() {
    setIO(); re(n,m,k);
    Mat<mi> M = Mat<mi>(n,n);
    F0R(i,m) {
        int a,b; re(a,b);
        M.d[a-1][b-1] += 1;
    }
    M = exp(M,k);
    ps(M.d[0][n-1]);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Graph Paths I,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

template<class T, int N, ll P> struct Matrix {
    typedef Matrix M;
    array<array<T, N>, N> d{};
    M operator*(const M& m) const {
        M a;
        rep(i,0,N) rep(j,0,N)
        rep(k,0,N)
        a.d[i][j] = (a.d[i][j] + d[i][k]*m.d[k][j]) % P;
        return a;
    }
    vector<T> operator*(const vector<T>& vec) const {
        vector<T> ret(N);
        rep(i,0,N) rep(j,0,N)
        ret[i] = (ret[i]  + d[i][j] * vec[j]) % P;
        return ret;
    }
    M operator^(ll p) const {
        assert(p >= 0);
        M a, b(*this);
        rep(i,0,N) a.d[i][i] = 1;
        while (p) {
            if (p&1) a = a*b;
            b = b*b;
            p >>= 1;
        }
        return a;
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int N=101;
    constexpr ll P=1e9+7;
    Matrix<ll, N, P> x;
    int n, m, k;
    cin >> n >> m >> k;
    while (m--) {
        int a, b;
        cin >> a >> b;
        x.d[a][b]++;
    }
    cout << (x^k).d[1][n] << '\n';
    return 0;
}
"
Graph Paths I,Java,"// https://cses.fi/problemset/task/1723
// Graph Paths I
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1723 {
    static final int MD = 1000000007;
    static void mult(int[][] aa, int[][] bb, int[][] cc, int n) {
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++) {
                long c = 0;
                for (int k = 0; k < n; k++)
                    c = (c + (long) aa[i][k] * bb[k][j]) % MD;
                cc[i][j] = (int) c;
            }
    }
    static void power(int[][] aa, int[][] pp, int[][] tt, int n, int k) {
        if (k == 0) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++)
                    pp[i][j] = 0;
                pp[i][i] = 1;
            }
            return;
        }
        if (k % 2 == 0) {
            power(aa, tt, pp, n, k / 2);
            mult(tt, tt, pp, n);
        } else {
            power(aa, pp, tt, n, k / 2);
            mult(pp, pp, tt, n);
            mult(tt, aa, pp, n);
        }
    }
    public static void main(String[] __) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out, true);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        int[][] aa = new int[n][n];
        int[][] pp = new int[n][n];
        int[][] tt = new int[n][n];
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            aa[i][j]++;
        }
        power(aa, pp, tt, n, k);
        pw.println(pp[0][n - 1]);
        pw.close();
    }
}
"
Graph Paths I,Java,"// https://cses.fi/problemset/task/1723
// Graph Paths I
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1723 {
    static final int MD = 1000000007;
    static void mult(int[][] aa, int[][] bb, int[][] cc, int n) {
        for (int i = 0; i < n; i++) {
            int[] ci = cc[i];
            for (int j = 0; j < n; j++)
                ci[j] = 0;
            for (int k = 0; k < n; k++) {
                long a = aa[i][k];
                if (a != 0) {
                    int[] bk = bb[k];
                    for (int j = 0; j < n; j++)
                        ci[j] = (int) ((ci[j] + a * bk[j]) % MD);
                }
            }
        }
    }
    static void power(int[][] aa, int[][] pp, int[][] tt, int n, int k) {
        if (k == 0) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++)
                    pp[i][j] = 0;
                pp[i][i] = 1;
            }
            return;
        }
        if (k % 2 == 0) {
            power(aa, tt, pp, n, k / 2);
            mult(tt, tt, pp, n);
        } else {
            power(aa, pp, tt, n, k / 2);
            mult(pp, pp, tt, n);
            mult(tt, aa, pp, n);
        }
    }
    public static void main(String[] __) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out, true);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        int[][] aa = new int[n][n];
        int[][] pp = new int[n][n];
        int[][] tt = new int[n][n];
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            aa[i][j]++;
        }
        power(aa, pp, tt, n, k);
        pw.println(pp[0][n - 1]);
        pw.close();
    }
}
"
Graph Paths I,C++,"/*
 https://cses.fi/problemset/task/1723
 Graph Paths I
 practice with Dukkha
 */
#include <stdio.h>

#define N    100
#define MD    1000000007

void mult(int aa[][N], int bb[][N], int cc[][N], int n) {
    int i, j, k;
    
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++) {
            int c = 0;
            
            for (k = 0; k < n; k++)
                c = (c + (long long) aa[i][k] * bb[k][j]) % MD;
            cc[i][j] = c;
        }
}

void power(int aa[][N], int pp[][N], int tt[][N], int n, int k) {
    if (k == 0) {
        int i, j;
        
        for (i = 0; i < n; i++)
            for (j = 0; j < n; j++)
                pp[i][j] = i == j;
        return;
    }
    if (k % 2 == 0) {
        power(aa, tt, pp, n, k / 2);
        mult(tt, tt, pp, n);
    } else {
        power(aa, pp, tt, n, k / 2);
        mult(pp, pp, tt, n);
        mult(tt, aa, pp, n);
    }
}

int main() {
    static int aa[N][N], pp[N][N], tt[N][N];
    int n, m, k, i, j;
    
    scanf(""%d%d%d"", &n, &m, &k);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        aa[i][j]++;
    }
    power(aa, pp, tt, n, k);
    printf(""%d\n"", pp[0][n - 1]);
    return 0;
}
"
Graph Paths I,C++,"/*
 https://cses.fi/problemset/task/1723
 Graph Paths I
 practice with Dukkha
 */
#include <stdio.h>

#define N    100
#define MD    1000000007

void mult(int aa[][N], int bb[][N], int cc[][N], int n) {
    int i, j, k;
    
    for (i = 0; i < n; i++) {
        int *ci = cc[i];
        
        for (j = 0; j < n; j++)
            ci[j] = 0;
        for (k = 0; k < n; k++) {
            long long a = aa[i][k];
            
            if (a != 0) {
                int *bk = bb[k];
                
                for (j = 0; j < n; j++)
                    ci[j] = (ci[j] + a * bk[j]) % MD;
            }
        }
    }
}

void power(int aa[][N], int pp[][N], int tt[][N], int n, int k) {
    if (k == 0) {
        int i, j;
        
        for (i = 0; i < n; i++)
            for (j = 0; j < n; j++)
                pp[i][j] = i == j;
        return;
    }
    if (k % 2 == 0) {
        power(aa, tt, pp, n, k / 2);
        mult(tt, tt, pp, n);
    } else {
        power(aa, pp, tt, n, k / 2);
        mult(pp, pp, tt, n);
        mult(tt, aa, pp, n);
    }
}

int main() {
    static int aa[N][N], pp[N][N], tt[N][N];
    int n, m, k, i, j;
    
    scanf(""%d%d%d"", &n, &m, &k);
    while (m--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        aa[i][j]++;
    }
    power(aa, pp, tt, n, k);
    printf(""%d\n"", pp[0][n - 1]);
    return 0;
}
"
Graph Paths II,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 2e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<class T> struct Mat {
    T** d;
    int a, b;
    
    Mat() { a = b = 0; }
    Mat(int _a, int _b) : a(_a), b(_b) {
        d = new T*[a];
        F0R(i,a) {
            d[i] = new T[b];
            F0R(j,b) {
                d[i][j] = INF;
            }
        }
    }
    Mat (const vector<vector<T>>& v) : Mat(sz(v),sz(v[0])) {
        F0R(i,a) F0R(j,b) d[i][j] = v[i][j];
    }
    
    operator vector<vector<T>> () {
        auto ret = vector<vector<T>>(a,vector<T>(b));
        F0R(i,a) F0R(j,b) ret[i][j] = d[i][j];
        return ret;
    }
    friend void pr(const Mat& m) {
        Mat M(m); pr(vector<vector<T>>(M));
    }
    
    Mat operator+(const Mat& m) {
        assert(a == m.a && b == m.b);
        Mat r(a,b);
        F0R(i,a) F0R(j,b) r.d[i][j] = d[i][j]+m.d[i][j];
        return r;
    }
    Mat operator-(const Mat& m) {
        assert(a == m.a && b == m.b);
        Mat r(a,b);
        F0R(i,a) F0R(j,b) r.d[i][j] = d[i][j]-m.d[i][j];
        return r;
    }
    Mat operator*(const Mat& m) {
        assert(b == m.a);
        Mat r(a,m.b);
        F0R(i,a) F0R(j,b) F0R(k,m.b) ckmin(r.d[i][k],d[i][j]+m.d[j][k]);
        return r;
    }
    
    Mat& operator+=(const Mat& m) { return *this = (*this)+m; }
    Mat& operator-=(const Mat& m) { return *this = (*this)-m; }
    Mat& operator*=(const Mat& m) { return *this = (*this)*m; }
    
    friend Mat exp(Mat m, ll p) {
        Mat r(m.a,m.a); assert(m.a == m.b);
        F0R(i,m.a) r.d[i][i] = 0;
        for (; p; p /= 2, m *= m) if (p&1) r *= m;
        return r;
    }
};

Mat<ll> M;
int n,m,k;

int main() {
    setIO(); re(n,m,k);
    M = Mat<ll>(n,n);
    F0R(i,m) {
        int a,b,c; re(a,b,c);
        ckmin(M.d[a-1][b-1],(ll)c);
    }
    M = exp(M,k);
    if (M.d[0][n-1] == INF) ps(-1);
    else ps(M.d[0][n-1]);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Graph Paths II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr ll inf=2e18;
template<class T, int N> struct Matrix {
    typedef Matrix M;
    array<array<T, N>, N> d;
    Matrix() {
        rep(i, 0, N) rep(j, 0, N)
        d[i][j] = inf;
    }
    M operator*(const M& m) const {
        M a;
        rep(i,0,N) rep(j,0,N)
        rep(k,0,N)
        a.d[i][j] = min(a.d[i][j], d[i][k]+m.d[k][j]);
        return a;
    }
    vector<T> operator*(const vector<T>& vec) const {
        vector<T> ret(N, inf);
        rep(i,0,N) rep(j,0,N)
        ret[i] = min(ret[i], d[i][j] + vec[j]);
        return ret;
    }
    M operator^(ll p) const {
        assert(p >= 0);
        M a, b(*this);
        rep(i, 0, N) a.d[i][i]=0;
        while (p) {
            if (p&1) a = a*b;
            b = b*b;
            p >>= 1;
        }
        return a;
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int N=101;
    Matrix<ll, N> x;
    ll n, m, k;
    cin >> n >> m >> k;
    while (m--) {
        ll a, b, c;
        cin >> a >> b >> c;
        x.d[a][b]=min(x.d[a][b], c);
    }
    ll ans=(x^k).d[1][n];
    cout << (ans==inf? -1:ans) << '\n';
    return 0;
}
"
Graph Paths II,Java,"// https://cses.fi/problemset/task/1724
// Graph Paths II
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1724 {
    static final long INF = 0x3f3f3f3f3f3f3f3fL;
    static void mult(long[][] aa, long[][] bb, long[][] cc, int n) {
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++) {
                long c = INF;
                for (int k = 0; k < n; k++)
                    c = Math.min(c, aa[i][k] + bb[k][j]);
                cc[i][j] = c;
            }
    }
    static void power(long[][] aa, long[][] pp, long[][] tt, int n, int k) {
        if (k == 0) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++)
                    pp[i][j] = INF;
                pp[i][i] = 0;
            }
            return;
        }
        if (k % 2 == 0) {
            power(aa, tt, pp, n, k / 2);
            mult(tt, tt, pp, n);
        } else {
            power(aa, pp, tt, n, k / 2);
            mult(pp, pp, tt, n);
            mult(tt, aa, pp, n);
        }
    }
    public static void main(String[] __) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out, true);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        long[][] aa = new long[n][n];
        long[][] pp = new long[n][n];
        long[][] tt = new long[n][n];
        for (int i = 0; i < n; i++)
            Arrays.fill(aa[i], INF);
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            int w = Integer.parseInt(st.nextToken());
            aa[i][j] = Math.min(aa[i][j], w);
        }
        power(aa, pp, tt, n, k);
        long ans = pp[0][n - 1];
        pw.println(ans == INF ? -1 : ans);
        pw.close();
    }
}
"
Graph Paths II,Java,"// https://cses.fi/problemset/task/1724
// Graph Paths II
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1724 {
    static final long INF = 0x3f3f3f3f3f3f3f3fL;
    static void mult(long[][] aa, long[][] bb, long[][] cc, int n) {
        for (int i = 0; i < n; i++) {
            long[] ci = cc[i];
            for (int j = 0; j < n; j++)
                ci[j] = INF;
            for (int k = 0; k < n; k++) {
                long a = aa[i][k];
                if (a != INF) {
                    long[] bk = bb[k];
                    for (int j = 0; j < n; j++)
                        ci[j] = Math.min(ci[j], a + bk[j]);
                }
            }
        }
    }
    static void power(long[][] aa, long[][] pp, long[][] tt, int n, int k) {
        if (k == 0) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++)
                    pp[i][j] = INF;
                pp[i][i] = 0;
            }
            return;
        }
        if (k % 2 == 0) {
            power(aa, tt, pp, n, k / 2);
            mult(tt, tt, pp, n);
        } else {
            power(aa, pp, tt, n, k / 2);
            mult(pp, pp, tt, n);
            mult(tt, aa, pp, n);
        }
    }
    public static void main(String[] __) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out, true);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        long[][] aa = new long[n][n];
        long[][] pp = new long[n][n];
        long[][] tt = new long[n][n];
        for (int i = 0; i < n; i++)
            Arrays.fill(aa[i], INF);
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int i = Integer.parseInt(st.nextToken()) - 1;
            int j = Integer.parseInt(st.nextToken()) - 1;
            int w = Integer.parseInt(st.nextToken());
            aa[i][j] = Math.min(aa[i][j], w);
        }
        power(aa, pp, tt, n, k);
        long ans = pp[0][n - 1];
        pw.println(ans == INF ? -1 : ans);
        pw.close();
    }
}
"
Graph Paths II,C++,"/*
 https://cses.fi/problemset/task/1724
 Graph Paths II
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100
#define INF    0x3f3f3f3f3f3f3f3f

void mult(long long aa[][N], long long bb[][N], long long cc[][N], int n) {
    int i, j, k;
    
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++) {
            long long c = INF, d;
            
            for (k = 0; k < n; k++)
                if (c > (d = aa[i][k] + bb[k][j]))
                    c = d;
            cc[i][j] = c;
        }
}

void power(long long aa[][N], long long pp[][N], long long tt[][N], int n, int k) {
    if (k == 0) {
        int i, j;
        
        for (i = 0; i < n; i++)
            for (j = 0; j < n; j++)
                pp[i][j] = i == j ? 0 : INF;
        return;
    }
    if (k % 2 == 0) {
        power(aa, tt, pp, n, k / 2);
        mult(tt, tt, pp, n);
    } else {
        power(aa, pp, tt, n, k / 2);
        mult(pp, pp, tt, n);
        mult(tt, aa, pp, n);
    }
}

int main() {
    static long long aa[N][N], pp[N][N], tt[N][N];
    int n, m, k, i, j, a;
    long long ans;
    
    scanf(""%d%d%d"", &n, &m, &k);
    for (i = 0; i < n; i++)
        memset(aa[i], 0x3f, n * sizeof *aa[i]);
    while (m--) {
        scanf(""%d%d%d"", &i, &j, &a), i--, j--;
        if (aa[i][j] > a)
            aa[i][j] = a;
    }
    power(aa, pp, tt, n, k);
    ans = pp[0][n - 1];
    printf(""%lld\n"", ans == INF ? -1 : ans);
    return 0;
}
"
Graph Paths II,C++,"/*
 https://cses.fi/problemset/task/1724
 Graph Paths II
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100
#define INF    0x3f3f3f3f3f3f3f3f

void mult(long long aa[][N], long long bb[][N], long long cc[][N], int n) {
    int i, j, k;
    
    for (i = 0; i < n; i++) {
        long long *ci = cc[i];
        
        for (j = 0; j < n; j++)
            ci[j] = INF;
        for (k = 0; k < n; k++) {
            long long a = aa[i][k];
            
            if (a != INF) {
                long long *bk = bb[k], d;
                
                for (j = 0; j < n; j++)
                    if (ci[j] > (d = a + bk[j]))
                        ci[j] = d;
            }
        }
    }
}

void power(long long aa[][N], long long pp[][N], long long tt[][N], int n, int k) {
    if (k == 0) {
        int i, j;
        
        for (i = 0; i < n; i++)
            for (j = 0; j < n; j++)
                pp[i][j] = i == j ? 0 : INF;
        return;
    }
    if (k % 2 == 0) {
        power(aa, tt, pp, n, k / 2);
        mult(tt, tt, pp, n);
    } else {
        power(aa, pp, tt, n, k / 2);
        mult(pp, pp, tt, n);
        mult(tt, aa, pp, n);
    }
}

int main() {
    static long long aa[N][N], pp[N][N], tt[N][N];
    int n, m, k, i, j, a;
    long long ans;
    
    scanf(""%d%d%d"", &n, &m, &k);
    for (i = 0; i < n; i++)
        memset(aa[i], 0x3f, n * sizeof *aa[i]);
    while (m--) {
        scanf(""%d%d%d"", &i, &j, &a), i--, j--;
        if (aa[i][j] > a)
            aa[i][j] = a;
    }
    power(aa, pp, tt, n, k);
    ans = pp[0][n - 1];
    printf(""%lld\n"", ans == INF ? -1 : ans);
    return 0;
}
"
Inversion Probability,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n;

int main() {
    setIO(); re(n);
    vi r(n); re(r);
    ld ans = 0;
    F0R(i,n) FOR(j,i+1,n) {
        int ret = 0;
        FOR(I,1,r[i]+1) FOR(J,1,r[j]+1) if (I > J) ret ++;
        ans += (ld)ret/r[i]/r[j];
    }
    cout << fixed << setprecision(6) << ans;
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Inversion Probability,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vi r(n);
    rep(i, 0, n) cin >> r[i];
    double  ans=0;
    rep(i, 0, n) rep(j, i+1, n) {
        if(r[i]<r[j]) ans+=(r[i]-1)*0.5/r[j];
        else ans+=1-(r[j]+1)*0.5/r[i];
    }
    cout << fixed <<setprecision(6);
    cout << ans << '\n';
    return 0;
}
"
Inversion Probability,Java,"// https://cses.fi/problemset/task/1728
// Inversion Probability
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1728 {
    static final int A = 100;
    static int[] t1, t2;
    static void update(int[] tt, int i, int x) {
        while (i <= A) {
            tt[i] += x;
            i |= i + 1;
        }
    }
    static int query(int[] tt, int i) {
        int x = 0;
        while (i >= 0) {
            x += tt[i];
            i &= i + 1;
            i--;
        }
        return x;
    }
    public static void main(String[] __) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out, true);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int[] aa = new int[n];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++)
            aa[i] = Integer.parseInt(st.nextToken());
        t1 = new int[A + 1];
        t2 = new int[A + 1];
        double ans = 0;
        for (int i = 0; i < n; i++) {
            int b = aa[i];
            int sum = query(t2, b);
            ans += sum / 2.0 / b;
            update(t2, b, b - 1);
        }
        Arrays.fill(t2, 0);
        for (int i = n - 1; i >= 0; i--) {
            int a = aa[i];
            int sum = query(t2, a - 1);
            int cnt = query(t1, a - 1);
            ans += cnt - sum / 2.0 / a;
            update(t2, a, a + 1);
            update(t1, a, 1);
        }
        pw.printf(""%.06f\n"", ans);
    }
}
"
Inversion Probability,C++,"/*
 https://cses.fi/problemset/task/1728
 Inversion Probability
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    100
#define A    100

void update(int *tt, int i, int x) {
    while (i <= A) {
        tt[i] += x;
        i |= i + 1;
    }
}

int query(int *tt, int i) {
    int sum = 0;
    
    while (i >= 0) {
        sum += tt[i];
        i &= i + 1;
        i--;
    }
    return sum;
}

int main() {
    static int aa[N], t1[A + 1], t2[A + 1];
    int n, i, a, b, sum, cnt;
    double ans;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    ans = 0;
    for (i = 0; i < n; i++) {
        b = aa[i];
        sum = query(t2, b);
        ans += sum / 2.0 / b;
        update(t2, b, b - 1);
    }
    memset(t2, 0, sizeof t2);
    for (i = n - 1; i >= 0; i--) {
        a = aa[i];
        sum = query(t2, a - 1);
        cnt = query(t1, a - 1);
        ans += cnt - sum / 2.0 / a;
        update(t2, a, a + 1);
        update(t1, a, 1);
    }
    printf(""%.6f\n"", ans);
    return 0;
}
"
Moving Robots,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

ld emp[8][8];
array<array<ld,8>,8> prob, PROB;
int k;

int xd[4] = {0,1,0,-1}, yd[4] = {1,0,-1,0};

void adv() {
    F0R(I,8) F0R(J,8) PROB[I][J] = 0;
    F0R(i,8) F0R(j,8) {
        vpi mov;
        F0R(k,4) {
            int I = i+xd[k], J = j+yd[k];
            if (0 <= I && I < 8 && 0 <= J && J < 8) mov.pb({I,J});
        }
        trav(t,mov) PROB[t.f][t.s] += prob[i][j]/sz(mov);
    }
    swap(prob,PROB);
}

int main() {
    setIO(); re(k);
    F0R(i,8) F0R(j,8) emp[i][j] = 1;
    F0R(i,8) F0R(j,8) {
        F0R(I,8) F0R(J,8) prob[I][J] = 0;
        prob[i][j] = 1;
        F0R(x,k) adv();
        F0R(I,8) F0R(J,8) emp[I][J] *= 1-prob[I][J];
        /*F0R(I,8) {
         F0R(J,8) pr(prob[I][J],' ');
         ps();
         }
         ps();*/
    }
    ld ans = 0; F0R(i,8) F0R(j,8) ans += emp[i][j];
    cout << fixed << setprecision(6) << ans;
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Moving Robots,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int N=8;
    constexpr int M=N*N;
    vector<vi> g(M);
    rep(i, 0, N) rep(j, 0, N)
    rep(ii, i-1, i+2) rep(jj, j-1, j+2) {
        if (abs(i-ii)+abs(j-jj)!=1) continue;
        if (ii<0 || ii==N || jj<0 || jj==N) continue;
        g[N*i+j].push_back(N*ii+jj);
    }
    vector<long double> ans(M, 1), x(M), y(M);
    int n;
    cin >> n;
    rep(s, 0, M) {
        rep(i, 0, M) x[i]=(i==s);
        rep(k, 0, n) {
            y.assign(M, 0);
            rep(i, 0, M) trav(j, g[i])
            y[j]+=x[i]/sz(g[i]);
            swap(x, y);
        }
        rep(i, 0, M) ans[i]*=1-x[i];
    }
    cout << fixed << setprecision(6);
    cout << accumulate(all(ans), 0.0) << '\n';
    return 0;
}
"
Moving Robots,Java,"// https://cses.fi/problemset/task/1726
// Moving Robots
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1726 {
    static final int N = 64;
    static void mult(double[][] aa, double[][] bb, double[][] cc) {
        for (int i = 0; i < N; i++)
            for (int j = 0; j < N; j++) {
                double x = 0;
                for (int k = 0; k < N; k++)
                    x += aa[i][k] * bb[k][j];
                cc[i][j] = x;
            }
    }
    static void power(double[][] aa, double[][] pp, double[][] tt, int k) {
        if (k == 0) {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++)
                    pp[i][j] = 0;
                pp[i][i] = 1;
            }
            return;
        }
        if (k % 2 == 0) {
            power(aa, tt, pp, k / 2);
            mult(tt, tt, pp);
        } else {
            power(aa, pp, tt, k / 2);
            mult(pp, pp, tt);
            mult(tt, aa, pp);
        }
    }
    public static void main(String[] __) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out, true);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int k = Integer.parseInt(st.nextToken());
        double[][] aa = new double[N][N];
        double[][] pp = new double[N][N];
        double[][] tt = new double[N][N];
        for (int r = 0; r < 8; r++)
            for (int c = 0; c < 8; c++) {
                int h = r * 8 + c;
                int m = 0;
                if (r > 0) m++;
                if (r < 7) m++;
                if (c > 0) m++;
                if (c < 7) m++;
                double x = 1.0 / m;
                if (r > 0) aa[(r - 1) * 8 + c][h] = x;
                if (r < 7) aa[(r + 1) * 8 + c][h] = x;
                if (c > 0) aa[r * 8 + c - 1][h] = x;
                if (c < 7) aa[r * 8 + c + 1][h] = x;
            }
        power(aa, pp, tt, k);
        double ans = 0;
        for (int i = 0; i < N; i++) {
            double x = 1;
            for (int j = 0; j < N; j++)
                x *= 1 - pp[i][j];
            ans += x;
        }
        pw.printf(""%.6f\n"", ans);
        pw.close();
    }
}
"
Moving Robots,C++,"/*
 https://cses.fi/problemset/task/1726
 Moving Robots
 practice with Dukkha
 */
#include <stdio.h>

#define N    64

void mult(double aa[][N], double bb[][N], double cc[][N]) {
    int i, j, k;
    
    for (i = 0; i < N; i++)
        for (j = 0; j < N; j++) {
            double c = 0;
            
            for (k = 0; k < N; k++)
                c += aa[i][k] * bb[k][j];
            cc[i][j] = c;
        }
}

void power(double aa[][N], double pp[][N], double tt[][N], int k) {
    if (k == 0) {
        int i, j;
        
        for (i = 0; i < N; i++)
            for (j = 0; j < N; j++)
                pp[i][j] = i == j;
        return;
    }
    if (k % 2 == 0) {
        power(aa, tt, pp, k / 2);
        mult(tt, tt, pp);
    } else {
        power(aa, pp, tt, k / 2);
        mult(pp, pp, tt);
        mult(tt, aa, pp);
    }
}

int main() {
    static double aa[N][N], pp[N][N], tt[N][N];
    int k, h, i, j, r, c, m;
    double ans, x;
    
    scanf(""%d"", &k);
    for (r = 0; r < 8; r++)
        for (c = 0; c < 8; c++) {
            h = r * 8 + c;
            m = 0;
            if (r > 0) m++;
            if (r < 7) m++;
            if (c > 0) m++;
            if (c < 7) m++;
            x = 1.0 / m;
            if (r > 0) aa[(r - 1) * 8 + c][h] = x;
            if (r < 7) aa[(r + 1) * 8 + c][h] = x;
            if (c > 0) aa[r * 8 + c - 1][h] = x;
            if (c < 7) aa[r * 8 + c + 1][h] = x;
        }
    power(aa, pp, tt, k);
    ans = 0;
    for (i = 0; i < N; i++) {
        double x = 1;
        
        for (j = 0; j < N; j++)
            x *= 1 - pp[i][j];
        ans += x;
    }
    printf(""%.6f\n"", ans);
    return 0;
}
"
Nim Game I,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,k;
vi p;
bitset<1000001> win;

int main() {
    setIO();
    int t; re(t);
    F0R(i,t) {
        int n; re(n);
        int tot = 0;
        F0R(j,n) {
            int z; re(z); tot ^= z;
        }
        if (tot) ps(""first"");
        else ps(""second"");
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Nim Game I,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int t;
    cin >> t;
    while (t--) {
        int n, sg=0;
        cin >> n;
        while (n--) {
            int a;
            cin >> a;
            sg^=a;
        }
        cout << (sg? ""first\n"" : ""second\n"");
    }
    return 0;
}
"
Nim Game I,Java,"// https://cses.fi/problemset/task/1730
// Nim Game I
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1730 {
    public static void main(String[] __) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int t = Integer.parseInt(st.nextToken());
        while (t-- > 0) {
            st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken());
            st = new StringTokenizer(br.readLine());
            int x = 0;
            while (n-- > 0)
                x ^= Integer.parseInt(st.nextToken());
            pw.println(x == 0 ? ""second"" : ""first"");
        }
        pw.close();
    }
}
"
Nim Game I,Java,"// https://cses.fi/problemset/task/1730
// Nim Game I
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1730 {
    public static void main(String[] __) throws IOException {
        Scanner_ sc = new Scanner_();
        PrintWriter pw = new PrintWriter(System.out);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            int x = 0;
            while (n-- > 0)
                x ^= sc.nextInt();
            pw.println(x == 0 ? ""second"" : ""first"");
        }
        pw.close();
    }
    static class Scanner_ {
        int k, l;
        byte[] bb = new byte[1 << 15];
        byte read() {
            if (k >= l) {
                k = 0;
                try {
                    if ((l = System.in.read(bb)) < 0)
                        return -1;
                } catch (IOException e) { return -1; }
            }
            return bb[k++];
        }
        int m = 1 << 7;
        byte[] cc = new byte[m];
        String next() {
            byte b = 0;
            while (b <= 32)
                b = read();
            int n = 0;
            while (b > 32) {
                if (n == m)
                    cc = Arrays.copyOf(cc, m <<= 1);
                cc[n++] = b;
                b = read();
            }
            return new String(cc, 0, n);
        }
        int nextInt() { return Integer.parseInt(next()); }
    }
}
"
Nim Game I,Java,"// https://cses.fi/problemset/task/1730
// Nim Game I
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1730 {
    public static void main(String[] __) throws IOException {
        Scanner_ sc = new Scanner_();
        PrintWriter pw = new PrintWriter(System.out);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            int x = 0;
            while (n-- > 0)
                x ^= sc.nextInt();
            pw.println(x == 0 ? ""second"" : ""first"");
        }
        pw.close();
    }
    static class Scanner_ {
        int k, l;
        byte[] bb = new byte[1 << 15];
        byte read() {
            if (k >= l) {
                k = 0;
                try {
                    if ((l = System.in.read(bb)) < 0)
                        return -1;
                } catch (IOException e) { return -1; }
            }
            return bb[k++];
        }
        int nextInt() {
            byte b = 0;
            while (b <= 32)
                b = read();
            int n = 0;
            while (b > 32) {
                n = n * 10 + b - '0';
                b = read();
            }
            return n;
        }
    }
}
"
Nim Game I,Java,"// https://cses.fi/problemset/task/1730
// Nim Game I
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1730 {
    public static void main(String[] __) {
        Scanner sc = new Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            int x = 0;
            while (n-- > 0)
                x ^= sc.nextInt();
            pw.println(x == 0 ? ""second"" : ""first"");
        }
        pw.close();
    }
}
"
Nim Game I,Java,"// https://cses.fi/problemset/task/1730
// Nim Game I
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1730 {
    public static void main(String[] __) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in), 1 << 15);
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int t = Integer.parseInt(st.nextToken());
        while (t-- > 0) {
            st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken());
            st = new StringTokenizer(br.readLine());
            int x = 0;
            while (n-- > 0)
                x ^= Integer.parseInt(st.nextToken());
            pw.println(x == 0 ? ""second"" : ""first"");
        }
        pw.close();
    }
}
"
Nim Game I,C++,"/*
 https://cses.fi/problemset/task/1730
 Nim Game I
 practice with Dukkha
 */
#include <stdio.h>

int main() {
    int t;
    
    scanf(""%d"", &t);
    while (t--) {
        int n, x, y;
        
        scanf(""%d"", &n);
        y = 0;
        while (n--)
            scanf(""%d"", &x), y ^= x;
        printf(y ? ""first\n"" : ""second\n"");
    }
    return 0;
}
"
Nim Game II,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int t;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> t;
    F0R(i,t) {
        int n; cin >> n;
        int z = 0;
        F0R(j,n) {
            int k; cin >> k;
            z ^= k;
        }
        if (z % 4 == 0) cout << ""second\n"";
        else cout << ""first\n"";
    }
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Nim Game II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int t;
    cin >> t;
    while (t--) {
        int n, sg=0;
        cin >> n;
        while (n--) {
            int x;
            cin >> x;
            sg^=x%4;
        }
        cout << (sg? ""first\n"":""second\n"");
    }
    return 0;
}
"
Nim Game II,Java,"// https://cses.fi/problemset/task/1098
// Stick Game
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1098 {
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            int a = 0;
            for (int i = 0; i < n; i++) {
                int x = sc.nextInt();
                a ^= x % 4;
            }
            pw.println(a == 0 ? ""second"" : ""first"");
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb); //if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Nim Game II,Java,"// https://cses.fi/problemset/task/1098
// Nim Game II
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1098 {
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            int a = 0;
            for (int i = 0; i < n; i++) {
                int x = sc.nextInt();
                a ^= x % 4;
            }
            pw.println(a == 0 ? ""second"" : ""first"");
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Nim Game II,C++,"/*
 https://cses.fi/problemset/task/1098
 Stick Game
 practice with Dukkha
 */
#include <stdio.h>

int main() {
    int t;
    
    scanf(""%d"", &t);
    while (t--) {
        int n, x, y;
        
        scanf(""%d"", &n);
        y = 0;
        while (n--) {
            scanf(""%d"", &x);
            y ^= x % 4;
        }
        printf(y ? ""first\n"" : ""second\n"");
    }
    return 0;
}
"
Nim Game II,C++,"/*
 https://cses.fi/problemset/task/1098
 Nim Game II
 practice with Dukkha
 */
#include <stdio.h>

int main() {
    int t;
    
    scanf(""%d"", &t);
    while (t--) {
        int n, x, y;
        
        scanf(""%d"", &n);
        y = 0;
        while (n--) {
            scanf(""%d"", &x);
            y ^= x % 4;
        }
        printf(y ? ""first\n"" : ""second\n"");
    }
    return 0;
}
"
Stair Game,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

bool win[20][20][20];

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    int T; cin >> T;
    F0R(i,T) {
        int N,z=0; cin >> N;
        F0R(j,N) {
            int k; cin >> k;
            if (j&1) z ^= k;
        }
        if (z == 0) cout << ""second\n"";
        else cout << ""first\n"";
    }
    /*F0R(c,20) F0R(b,20) F0R(a,20) {
     int sum = a+b+c;
     if (sum == 0) continue;
     F0R(A,a) if (!win[A][b][c]) win[a][b][c] = 1;
     F0R(B,b) if (!win[a+b-B][B][c]) win[a][b][c] = 1;
     F0R(C,c) if (!win[a][b+c-C][C]) win[a][b][c] = 1;
     if (!win[a][b][c] && a+b+c < 20) cout << a << "" "" << b << "" "" << c << ""\n"";
     }*/
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Stair Game,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

bool win[20][20][20];

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    int T; cin >> T;
    F0R(i,T) {
        int N,z=0; cin >> N;
        F0R(j,N) {
            int k; cin >> k;
            if (j&1) z ^= k;
        }
        if (z == 0) cout << ""second\n"";
        else cout << ""first\n"";
    }
    /*F0R(c,20) F0R(b,20) F0R(a,20) {
     int sum = a+b+c;
     if (sum == 0) continue;
     F0R(A,a) if (!win[A][b][c]) win[a][b][c] = 1;
     F0R(B,b) if (!win[a+b-B][B][c]) win[a][b][c] = 1;
     F0R(C,c) if (!win[a][b+c-C][C]) win[a][b][c] = 1;
     if (!win[a][b][c] && a+b+c < 20) cout << a << "" "" << b << "" "" << c << ""\n"";
     }*/
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
"
Stair Game,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int t;
    cin >> t;
    while(t--) {
        int n;
        cin >> n;
        int r=0;
        rep(i, 0, n) {
            int x;
            cin >> x;
            if (i%2) r^=x;
        }
        cout << (r? ""first"" : ""second"") << '\n';
    }
    return 0;
}
"
Stair Game,C++,"// https://cses.fi/problemset/task/1099
// Stair Game
// practice with rainboy
#include <iostream>

using namespace std;

int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        int n;
        scanf(""%d"", &n);
        int x = 0;
        for (int i = 0; i < n; i++) {
            int p;
            scanf(""%d"", &p);
            if (i % 2)
                x ^= p;
        }
        printf(x ? ""first\n"" : ""second\n"");
    }
    return 0;
}
"
Stair Game,C++,"/*
 https://cses.fi/problemset/task/1099
 Stair Game
 practice with Dukkha
 */
#include <stdio.h>

int main() {
    int t;
    
    scanf(""%d"", &t);
    while (t--) {
        int n, i, x, p;
        
        scanf(""%d"", &n);
        x = 0;
        for (i = 0; i < n; i++) {
            scanf(""%d"", &p);
            if (i % 2)
                x ^= p;
        }
        printf(x ? ""first\n"" : ""second\n"");
    }
    return 0;
}
"
Stick Game,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,k;
vi p;
bitset<1000001> win;

int main() {
    setIO();
    re(n,k); p.resz(k); re(p);
    FOR(i,1,n+1) {
        trav(t,p) if (i >= t && !win[i-t]) win[i] = 1;
    }
    FOR(i,1,n+1) {
        if (win[i]) pr('W');
        else pr('L');
    }
    cout << fixed << setprecision(6);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Stick Game,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, k;
    cin >> n >> k;
    vi p(k);
    rep(i, 0, k) cin >> p[i];
    string s(n+1, 'L');
    rep(i, 1, n+1) trav(j, p)
    if (i>=j && s[i-j]=='L') {
        s[i]='W';
        break;
    }
    cout << s.substr(1) <<'\n';
    return 0;
}
"
Stick Game,Java,"// https://cses.fi/problemset/task/1729
// Stick Game
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1729 {
    public static void main(String[] __) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out, true);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        int[] pp = new int[k];
        st = new StringTokenizer(br.readLine());
        for (int h = 0; h < k; h++)
            pp[h] = Integer.parseInt(st.nextToken());
        pp = Arrays.stream(pp).boxed().sorted().mapToInt(i->i).toArray();
        byte[] aa = new byte[n + 1];
        Arrays.fill(aa, (byte) 'L');
        for (int i = 0; i < n; i++)
            if (aa[i] == 'L')
                for (int h = 0, j; h < k && (j = i + pp[h]) <= n; h++)
                    aa[j] = 'W';
        pw.println(new String(aa, 1, n));
    }
}
"
Stick Game,Java,"// https://cses.fi/problemset/task/1729
// Stick Game
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1729 {
    public static void main(String[] __) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out, true);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        int[] pp = new int[k];
        st = new StringTokenizer(br.readLine());
        for (int h = 0; h < k; h++)
            pp[h] = Integer.parseInt(st.nextToken());
        Arrays.sort(pp);
        byte[] aa = new byte[n + 1];
        Arrays.fill(aa, (byte) 'L');
        for (int i = 0; i < n; i++)
            if (aa[i] == 'L')
                for (int h = 0, j; h < k && (j = i + pp[h]) <= n; h++)
                    aa[j] = 'W';
        pw.println(new String(aa, 1, n));
    }
}
"
Stick Game,Java,"// https://cses.fi/problemset/task/1729
// Stick Game
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1729 {
    public static void main(String[] __) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out, true);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        int[] pp = new int[k];
        st = new StringTokenizer(br.readLine());
        for (int h = 0; h < k; h++)
            pp[h] = Integer.parseInt(st.nextToken());
        Arrays.sort(pp);
        char[] aa = new char[n + 1];
        Arrays.fill(aa, 'L');
        for (int i = 0; i < n; i++)
            if (aa[i] == 'L')
                for (int h = 0, j; h < k && (j = i + pp[h]) <= n; h++)
                    aa[j] = 'W';
        pw.println(new String(aa, 1, n));
    }
}
"
Stick Game,C++,"/*
 https://cses.fi/problemset/task/1729
 Stick Game
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define N    1000000
#define K    100

int compare(const void *a, const void *b) {
    int ia = *(int *) a;
    int ib = *(int *) b;
    
    return ia - ib;
}

int main() {
    static int pp[K];
    static char aa[N + 2];
    int n, k, h, i, j;
    
    scanf(""%d%d"", &n, &k);
    for (h = 0; h < k; h++)
        scanf(""%d"", &pp[h]);
    qsort(pp, k, sizeof *pp, compare);
    memset(aa, 'L', (n + 1) * sizeof *aa);
    for (i = 0; i < n; i++)
        if (aa[i] == 'L')
            for (h = 0; h < k && (j = i + pp[h]) <= n; h++)
                aa[j] = 'W';
    printf(""%s\n"", aa + 1);
    return 0;
}
"
Sum of Divisors,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

ll n,ans;

int main() {
    cin >> n;
    for (ll i = 1; i <= 1000000; ++i) {
        if (n/i <= 1000000) break;
        ans += (n/i)*i;
        ans %= MOD;
    }
    FOR(j,1,1000001) {
        ll x = n/j, y = n/(j+1);
        // y+1 to x
        __int128 t = (x+y+1) % MOD;
        t = t*(x-y) % MOD;
        t = t*(MOD+1)/2 % MOD;
        t = t*j % MOD;
        ans = (ans+t) % MOD;
    }
    cout << ans;
}
"
Sum of Divisors,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int P=1e9+7;
    constexpr int P2=(P+1)/2;
    ll n, ans=0;
    cin >> n;
    for(ll i=1; i<=n/i; i++)
        ans=(ans+(n/i)*i)%P;
    for(ll j=1; j<n/j; j++) {
        ll L=max(j+1, n/(j+1)+1);
        ll R=n/j+1;
        ans=(ans+(R-L)%P*((R+L-1)%P)%P*P2%P*j)%P;
    }
    cout << ans << '\n';
    return 0;
}
"
Sum of Divisors,Java,"// https://cses.fi/problemset/task/1082
// Sum of Divisors
// practice with rainboy
import java.io.*;

public class CSES1082 {
    static final int MD = 1000000007;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        long n = Long.parseLong(br.readLine());
        long ans = 0;
        for (long a = 1; a <= n / a; a++) {
            long q = n / a;
            ans = (ans + a * q) % MD;
            if (a != q) {
                long p = n / (a + 1);
                p %= MD;
                q %= MD;
                long k = (q - p) * (q + p + 1) / 2 % MD;
                ans = (ans + k * a) % MD;
            }
        }
        if (ans < 0)
            ans += MD;
        System.out.println(ans);
    }
}
"
Sum of Divisors,C++,"/*
 https://cses.fi/problemset/task/1082
 Sum of Divisors
 practice with Dukkha
 */
#include <stdio.h>

#define MD    1000000007

int main() {
    long long n, a, p, q, k, ans;
    
    scanf(""%lld"", &n);
    ans = 0;
    for (a = 1; a <= n / a; a++) {
        q = n / a;
        ans = (ans + a * q) % MD;
        if (a != q) {
            p = n / (a + 1);
            p %= MD;
            q %= MD;
            k = (q - p) * (q + p + 1) / 2 % MD;
            ans = (ans + k * a) % MD;
        }
    }
    if (ans < 0)
        ans += MD;
    printf(""%lld\n"", ans);
    return 0;
}
"
Throwing Dice,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

template<int SZ> struct mat {
    array<array<ll,SZ>,SZ> d;
    
    mat() {
        F0R(i,SZ) F0R(j,SZ) d[i][j] = 0;
    }
    
    mat operator+(const mat& m) {
        mat<SZ> a;
        F0R(i,SZ) F0R(j,SZ) a.d[i][j] = (d[i][j]+m.d[i][j]) % MOD;
        return a;
    }
    
    mat operator*(const mat& m) {
        mat<SZ> a;
        F0R(i,SZ) F0R(j,SZ) F0R(k,SZ)
        a.d[i][k] = (a.d[i][k]+d[i][j]*m.d[j][k]) % MOD;
        return a;
    }
    
    mat operator^(ll p) {
        mat<SZ> a, b(*this);
        F0R(i,SZ) a.d[i][i] = 1;
        
        while (p) {
            if (p&1) a = a*b;
            b = b*b;
            p /= 2;
        }
        
        return a;
    }
    
    void print() {
        F0R(i,SZ) {
            F0R(j,SZ) cout << d[i][j] << "" "";
            cout << ""\n"";
        }
        cout << ""------------\n"";
    }
};

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    mat<6> m;
    F0R(i,6) m.d[0][i] = 1;
    FOR(i,1,6) m.d[i][i-1] = 1;
    
    ll n; cin >> n;
    m = m^n;
    cout << m.d[0][0];
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Throwing Dice,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

const ll mod = 1e9+7;

typedef vector<ll> Poly;
ll linearRec(Poly S, Poly tr, ll k) {
    int n = sz(tr);
    
    auto combine = [&](Poly a, Poly b) {
        Poly res(n * 2 + 1);
        rep(i,0,n+1) rep(j,0,n+1)
        res[i + j] = (res[i + j] + a[i] * b[j]) % mod;
        for (int i = 2 * n; i > n; --i) rep(j,0,n)
            res[i - 1 - j] = (res[i - 1 - j] + res[i] * tr[j]) % mod;
        res.resize(n + 1);
        return res;
    };
    
    Poly pol(n + 1), e(pol);
    pol[0] = e[1] = 1;
    
    for (++k; k; k /= 2) {
        if (k % 2) pol = combine(pol, e);
        e = combine(e, e);
    }
    
    ll res = 0;
    rep(i,0,n) res = (res + pol[i + 1] * S[i]) % mod;
    return res;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    ll n;
    cin >> n;
    cout << linearRec({0, 0, 0, 0, 0, 1}, {1, 1, 1, 1, 1, 1}, n+5);
    return 0;
}
"
Throwing Dice,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

const ll mod = 1e9+7;

typedef vector<ll> Poly;
ll linearRec(Poly S, Poly tr, ll k) {
    int n = sz(tr);
    
    auto combine = [&](Poly a, Poly b) {
        Poly res(n * 2 + 1);
        rep(i,0,n+1) rep(j,0,n+1)
        res[i + j] = (res[i + j] + a[i] * b[j]) % mod;
        for (int i = 2 * n; i > n; --i) rep(j,0,n)
            res[i - 1 - j] = (res[i - 1 - j] + res[i] * tr[j]) % mod;
        res.resize(n + 1);
        return res;
    };
    
    Poly pol(n + 1), e(pol);
    pol[0] = e[1] = 1;
    
    for (++k; k; k /= 2) {
        if (k % 2) pol = combine(pol, e);
        e = combine(e, e);
    }
    
    ll res = 0;
    rep(i,0,n) res = (res + pol[i + 1] * S[i]) % mod;
    return res;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    ll n;
    cin >> n;
    cout << linearRec({0, 0, 0, 0, 0, 1}, {1, 1, 1, 1, 1, 1}, n+5);
    return 0;
}
"
Throwing Dice,Java,"// https://cses.fi/problemset/task/1096
// Throwing Dice
// practice with rainboy
import java.io.*;

public class CSES1096 {
    static final int MD = 1000000007;
    static void mult(int[][] aa, int[][] bb, int[][] cc) {
        for (int i = 0; i < 6; i++)
            for (int j = 0; j < 6; j++) {
                long c = 0;
                for (int k = 0; k < 6; k++)
                    c = (c + (long) aa[i][k] * bb[k][j]) % MD;
                cc[i][j] = (int) c;
            }
    }
    static void power(int[][] aa, int[][] pp, int[][] tt, long n) {
        if (n == 0) {
            for (int i = 0; i < 6; i++) {
                for (int j = 0; j < 6; j++)
                    pp[i][j] = 0;
                pp[i][i] = 1;
            }
            return;
        }
        if (n % 2 == 0) {
            power(aa, tt, pp, n / 2);
            mult(tt, tt, pp);
        } else {
            power(aa, pp, tt, n / 2);
            mult(pp, pp, tt);
            mult(tt, aa, pp);
        }
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        long n = Long.parseLong(br.readLine());
        int[][] aa = new int[6][6];
        aa[0][1] = aa[1][2] = aa[2][3] = aa[3][4] = aa[4][5] = 1;
        aa[5][0] = aa[5][1] = aa[5][2] = aa[5][3] = aa[5][4] = aa[5][5] = 1;
        int[][] pp = new int[6][6];
        int[][] tt = new int[6][6];
        power(aa, pp, tt, n);
        System.out.println(pp[5][5]);
    }
}
"
Throwing Dice,C++,"/*
 https://cses.fi/problemset/task/1096
 Throwing Dice
 practice with Dukkha
 */
#include <stdio.h>

#define MD    1000000007

void mult(int aa[][6], int bb[][6], int cc[][6]) {
    int i, j, k;
    
    for (i = 0; i < 6; i++)
        for (j = 0; j < 6; j++) {
            int c = 0;
            
            for (k = 0; k < 6; k++)
                c = (c + (long long) aa[i][k] * bb[k][j]) % MD;
            cc[i][j] = c;
        }
}

void power(int aa[][6], int pp[][6], int tt[][6], long long n) {
    int i, j;
    
    if (n == 0) {
        for (i = 0; i < 6; i++)
            for (j = 0; j < 6; j++)
                pp[i][j] = i == j;
        return;
    }
    if (n % 2 == 0) {
        power(aa, tt, pp, n / 2);
        mult(tt, tt, pp);
    } else {
        power(aa, pp, tt, n / 2);
        mult(pp, pp, tt);
        mult(tt, aa, pp);
    }
}

int main() {
    static int aa[6][6], pp[6][6], tt[6][6];
    long long n;
    
    scanf(""%lld"", &n);
    aa[0][1] = aa[1][2] = aa[2][3] = aa[3][4] = aa[4][5] = 1;
    aa[5][0] = aa[5][1] = aa[5][2] = aa[5][3] = aa[5][4] = aa[5][5] = 1;
    power(aa, pp, tt, n);
    printf(""%d\n"", pp[5][5]);
    return 0;
}
"
Distinct Values Queries,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;


template <class T, int ...Ns> struct BIT {
    T val = 0;
    void upd(T v) { val += v; }
    T query() { return val; }
};

template <class T, int N, int... Ns> struct BIT<T, N, Ns...> {
    BIT<T,Ns...> bit[N + 1];
    template<typename... Args> void upd(int pos, Args... args) {
        for (; pos <= N; pos += (pos&-pos)) bit[pos].upd(args...);
    }
    template<typename... Args> T sum(int r, Args... args) {
        T res = 0; for (; r; r -= (r&-r)) res += bit[r].query(args...);
        return res;
    }
    template<typename... Args> T query(int l, int r, Args... args) {
        return sum(r,args...)-sum(l-1,args...);
    }
}; // BIT<int,10,10> gives a 2D BIT


BIT<int,MX> B;
int n,q,ans[MX];
vpi query[MX];
vi x;
map<int,int> fst;

int main() {
    setIO(); re(n,q); x.resz(n); re(x);
    F0R(i,q) {
        int a,b; re(a,b);
        query[a].pb({b,i});
    }
    FORd(i,1,n+1) {
        int z = x[i-1];
        if (fst.count(z)) B.upd(fst[z],-1);
        fst[z] = i; B.upd(i,1);
        trav(t,query[i]) ans[t.s] = B.sum(t.f);
    }
    F0R(i,q) ps(ans[i]);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Distinct Values Queries,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr int B=400;
struct Q {
    int L, R, id;
    bool operator<(const Q &o) const {
        return pii{L/B, R}<pii{o.L/B, o.R};
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, nq;
    cin >> n >> nq;
    map<int, vi> f;
    rep(i, 0, n) {
        int a;
        cin >> a;
        f[a].push_back(i);
    }
    vi x(n);
    int k=0;
    trav(p, f) {
        trav(i, p.second) x[i]=k;
        k++;
    }
    vi cnt(k);
    vector<Q> q(nq);
    rep(i, 0, nq) {
        cin >> q[i].L >> q[i].R;
        q[i].L--, q[i].R--;
        q[i].id=i;
    }
    sort(all(q));
    int L=0, R=-1, dc=0;
    vi qans(nq);
    auto add=[&](int i) { if (++cnt[i]==1) dc++; };
    auto rem=[&](int i) { if (--cnt[i]==0) dc--; };
    trav(cq, q) {
        while (L<cq.L) rem(x[L++]);
        while (L>cq.L) add(x[--L]);
        while (R<cq.R) add(x[++R]);
        while (R>cq.R) rem(x[R--]);
        qans[cq.id]=dc;
    }
    trav(i, qans) cout << i << '\n';
    return 0;
}
"
Distinct Values Queries,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr int B=450;
struct Q {
    int L, R, cmp, id;
    bool operator<(const Q &o) const {
        return cmp<o.cmp;
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, nq;
    cin >> n >> nq;
    map<int, vi> f;
    rep(i, 0, n) {
        int a;
        cin >> a;
        f[a].push_back(i);
    }
    vi x(n);
    int k=0;
    trav(p, f) {
        trav(i, p.second) x[i]=k;
        k++;
    }
    vi cnt(k);
    vector<Q> q(nq);
    rep(i, 0, nq) {
        cin >> q[i].L >> q[i].R;
        q[i].L--, q[i].R--;
        q[i].cmp=(q[i].L/B)*n+q[i].R;
        q[i].id=i;
    }
    sort(all(q));
    int L=0, R=-1, dc=0;
    vi qans(nq);
    auto add=[&](int i) { if (++cnt[i]==1) dc++; };
    auto rem=[&](int i) { if (--cnt[i]==0) dc--; };
    trav(cq, q) {
        while (L<cq.L) rem(x[L++]);
        while (L>cq.L) add(x[--L]);
        while (R<cq.R) add(x[++R]);
        while (R>cq.R) rem(x[R--]);
        qans[cq.id]=dc;
    }
    trav(i, qans) cout << i << '\n';
    return 0;
}
"
Distinct Values Queries,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr int B=450;
struct Q {
    int L, R, cmp, id;
    bool operator<(const Q &o) const {
        return cmp<o.cmp;
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, nq;
    cin >> n >> nq;
    map<int, vi> f;
    rep(i, 0, n) {
        int a;
        cin >> a;
        f[a].push_back(i);
    }
    vi x(n);
    int k=0;
    trav(p, f) {
        trav(i, p.second) x[i]=k;
        k++;
    }
    vi cnt(k);
    vector<Q> q(nq);
    rep(i, 0, nq) {
        cin >> q[i].L >> q[i].R;
        q[i].L--, q[i].R--;
        q[i].cmp=(q[i].L/B)*n+q[i].R;
        q[i].id=i;
    }
    sort(all(q));
    int L=0, R=-1, dc=0;
    vi qans(nq);
    trav(cq, q) {
        while (L<cq.L) if (--cnt[x[L++]]==0) dc--;
        while (L>cq.L) if (++cnt[x[--L]]==1) dc++;
        while (R<cq.R) if (++cnt[x[++R]]==1) dc++;
        while (R>cq.R) if (--cnt[x[R--]]==0) dc--;
        qans[cq.id]=dc;
    }
    trav(i, qans) cout << i << '\n';
    return 0;
}
"
Distinct Values Queries,Java,"// https://cses.fi/problemset/task/1734
// Distinct Values Queries
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1734 {
    static int[] tt;
    static void update(int i, int n, int x) {
        while (i < n) {
            tt[i] += x;
            i |= i + 1;
        }
    }
    static int query(int i) {
        int x = 0;
        while (i >= 0) {
            x += tt[i];
            i &= i + 1;
            i--;
        }
        return x;
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int q = sc.nextInt();
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = sc.nextInt();
        int[] ll = new int[q];
        int[] rr = new int[q];
        for (int h = 0; h < q; h++) {
            ll[h] = sc.nextInt() - 1;
            rr[h] = sc.nextInt() - 1;
        }
        Integer[] ii = new Integer[Math.max(n, q)];
        for (int i = 0; i < n; i++)
            ii[i] = i;
        Arrays.sort(ii, 0, n, (i, j) -> aa[i] != aa[j] ? aa[i] - aa[j] : i - j);
        int[] pp = new int[n];
        for (int i = 0; i < n; i++)
            pp[ii[i]] = i == 0 || aa[ii[i - 1]] != aa[ii[i]] ? n : ii[i - 1];
        //for (int h = 0; h < q; h++) ii[h] = h;
        //Arrays.sort(ii, 0, q, (i, j) -> rr[i] - rr[j]);
        ArrayList[] bb = new ArrayList[n];
        for (int i = 0; i < n; i++)
            bb[i] = new ArrayList<Integer>();
        for (int h = 0; h < q; h++)
            bb[rr[h]].add(h);
        q = 0;
        for (int i = 0; i < n; i++) {
            ArrayList<Integer> bi = bb[i];
            for (int h : bi)
                ii[q++] = h;
        }
        tt = new int[n];
        int[] dd = new int[q];
        for (int h = 0, r = 0; h < q; ) {
            int h_, r_;
            r_ = rr[ii[h]];
            while (r <= r_) {
                update(pp[r], n, -1);
                update(r, n, 1);
                r++;
            }
            while (h < q && rr[h_ = ii[h]] == r_) {
                dd[h_] = query(rr[h_]) - query(ll[h_] - 1);
                h++;
            }
        }
        for (int h = 0; h < q; h++)
            pw.println(dd[h]);
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Distinct Values Queries,C++,"/*
 https://cses.fi/problemset/task/1734
 Distinct Values Queries
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    200000
#define Q    200000

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

int aa[N];

int compare_a(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return aa[i] != aa[j] ? aa[i] - aa[j] : i - j;
}

int ll[Q], rr[Q];

int compare_r(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return rr[i] - rr[j];
}

int tt[N];

void update(int i, int n, int x) {
    while (i < n) {
        tt[i] += x;
        i |= i + 1;
    }
}

int query(int i) {
    int sum = 0;
    
    while (i >= 0) {
        sum += tt[i];
        i &= i + 1;
        i--;
    }
    return sum;
}

int main() {
    static int ii[N], pp[N], dd[Q];
    int n, q, h, h_, i, j, r, r_, tmp;
    
    init_rand();
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++) {
        scanf(""%d"", &aa[i]);
        ii[i] = i;
    }
    for (j = 0; j < n; j++) {
        i = rand_(j + 1);
        tmp = ii[i], ii[i] = ii[j], ii[j] = tmp;
    }
    qsort(ii, n, sizeof *ii, compare_a);
    for (i = 0; i < n; i++)
        pp[ii[i]] = i == 0 || aa[ii[i - 1]] != aa[ii[i]] ? n : ii[i - 1];
    for (h = 0; h < q; h++) {
        scanf(""%d%d"", &ll[h], &rr[h]), ll[h]--, rr[h]--;
        ii[h] = h;
    }
    for (j = 0; j < q; j++) {
        i = rand_(j + 1);
        tmp = ii[i], ii[i] = ii[j], ii[j] = tmp;
    }
    qsort(ii, q, sizeof *ii, compare_r);
    for (h = 0, r = 0; h < q; ) {
        r_ = rr[ii[h]];
        while (r <= r_) {
            update(pp[r], n, -1);
            update(r, n, 1);
            r++;
        }
        while (h < q && rr[h_ = ii[h]] == r_) {
            dd[h_] = query(rr[h_]) - query(ll[h_] - 1);
            h++;
        }
    }
    for (h = 0; h < q; h++)
        printf(""%d\n"", dd[h]);
    return 0;
}
"
Distinct Values Queries,C++,"/*
 https://cses.fi/problemset/task/1734
 Distinct Values Queries
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    200000
#define Q    200000

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

int aa[N];

int compare_a(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return aa[i] != aa[j] ? aa[i] - aa[j] : i - j;
}

int ll[Q], rr[Q];

int compare_r(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return rr[i] - rr[j];
}

int tt[N];

void update(int i, int n, int x) {
    while (i < n) {
        tt[i] += x;
        i |= i + 1;
    }
}

int query(int i) {
    int sum = 0;
    
    while (i >= 0) {
        sum += tt[i];
        i &= i + 1;
        i--;
    }
    return sum;
}

struct L {
    struct L *next;
    int h;
} bb[N];

void link(int i, int h) {
    static struct L l91[Q], *l = l91;
    
    l->h = h;
    l->next = bb[i].next; bb[i].next = l++;
}

int main() {
    static int ii[N], pp[N], dd[Q];
    int n, q, h, h_, i, j, r, r_, tmp;
    
    init_rand();
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++) {
        scanf(""%d"", &aa[i]);
        ii[i] = i;
    }
    for (j = 0; j < n; j++) {
        i = rand_(j + 1);
        tmp = ii[i], ii[i] = ii[j], ii[j] = tmp;
    }
    qsort(ii, n, sizeof *ii, compare_a);
    for (i = 0; i < n; i++)
        pp[ii[i]] = i == 0 || aa[ii[i - 1]] != aa[ii[i]] ? n : ii[i - 1];
    for (h = 0; h < q; h++) {
        scanf(""%d%d"", &ll[h], &rr[h]), ll[h]--, rr[h]--;
        ii[h] = h;
    }
    for (h = 0; h < q; h++)
        link(rr[h], h);
    q = 0;
    for (i = 0; i < n; i++) {
        struct L *l;
        
        for (l = bb[i].next; l; l = l->next)
            ii[q++] = l->h;
    }
    for (h = 0, r = 0; h < q; ) {
        r_ = rr[ii[h]];
        while (r <= r_) {
            update(pp[r], n, -1);
            update(r, n, 1);
            r++;
        }
        while (h < q && rr[h_ = ii[h]] == r_) {
            dd[h_] = query(rr[h_]) - query(ll[h_] - 1);
            h++;
        }
    }
    for (h = 0; h < q; h++)
        printf(""%d\n"", dd[h]);
    return 0;
}
"
Forest Queries,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<class T, int SZ> struct PrefixSums {
    T sum[SZ][SZ];
    PrefixSums () { memset(sum,0,sizeof sum); }
    void init() {
        FOR(i,1,SZ) FOR(j,1,SZ)
        sum[i][j] += sum[i][j-1]
        +sum[i-1][j]-sum[i-1][j-1];
    }
    T get(int X1, int X2, int Y1, int Y2) {
        return sum[X2][Y2]-sum[X1-1][Y2]
        -sum[X2][Y1-1]+sum[X1-1][Y1-1];
    }
};

PrefixSums<int,1001> P;

int n,q;

int main() {
    setIO(); re(n,q);
    F0R(i,n) {
        string s; re(s);
        F0R(j,n) P.sum[i+1][j+1] = s[j] == '*';
    }
    P.init();
    F0R(i,q) {
        int y1,x1,y2,x2; re(y1,x1,y2,x2);
        ps(P.get(y1,y2,x1,x2));
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Forest Queries,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

/**
 * Date: 2014-11-28
 * Author: Johan Sannemo
 * License: CC0
 * Source: Folklore
 * Status: Tested on Kattis
 * Description: Calculate submatrix sums quickly, given upper-left and lower-right corners (half-open).
 * Usage:
 * SubMatrix<int> m(matrix);
 * m.sum(0, 0, 2, 2); // top left 4 elements
 * Time: O(N^2 + Q)
 */
template<class T>
struct SubMatrix {
    vector<vector<T>> p;
    SubMatrix(vector<vector<T>>& v) {
        int R = sz(v), C = sz(v[0]);
        p.assign(R+1, vector<T>(C+1));
        rep(r,0,R) rep(c,0,C)
        p[r+1][c+1] = v[r][c] + p[r][c+1] + p[r+1][c] - p[r][c];
    }
    T sum(int u, int l, int d, int r) {
        return p[d][r] - p[d][l] - p[u][r] + p[u][l];
    }
};


int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    vector<vi> x(n,  vi(n));
    rep(i, 0, n) {
        string s;
        cin >> s;
        rep(j, 0, n) x[i][j]=(s[j]=='*');
    }
    SubMatrix<int> f(x);
    while (q--) {
        int r1, c1, r2, c2;
        cin >> r1 >> c1 >> r2 >> c2;
        cout << f.sum(r1-1, c1-1, r2, c2) << '\n';
    }
    return 0;
}
"
Forest Queries,Java,"// https://cses.fi/problemset/task/1652
// Forest Queries
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1652 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int q = Integer.parseInt(st.nextToken());
        char[][] cc = new char[n][n];
        for (int i = 0; i < n; i++)
            br.readLine().getChars(0, n, cc[i], 0);
        int[][] aa = new int[n + 1][n + 1];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                if (cc[i][j] == '*')
                    aa[i + 1][j + 1]++;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                aa[i][j] += aa[i][j - 1];
        for (int j = 1; j <= n; j++)
            for (int i = 1; i <= n; i++)
                aa[i][j] += aa[i - 1][j];
        while (q-- > 0) {
            st = new StringTokenizer(br.readLine());
            int il = Integer.parseInt(st.nextToken());
            int jl = Integer.parseInt(st.nextToken());
            int ir = Integer.parseInt(st.nextToken());
            int jr = Integer.parseInt(st.nextToken());
            pw.println(aa[ir][jr] - aa[il - 1][jr] - aa[ir][jl - 1] + aa[il - 1][jl - 1]);
        }
        pw.close();
    }
}
"
Forest Queries,C++,"/*
 https://cses.fi/problemset/task/1652
 Forest Queries
 practice with Dukkha
 */
#include <stdio.h>

#define N    1000

int main() {
    static int aa[N + 1][N + 1];
    int n, q, i, j;
    
    scanf(""%d%d"", &n, &q);
    for (i = 1; i <= n; i++) {
        static char s[N + 2];
        
        scanf(""%s"", s + 1);
        for (j = 1; j <= n; j++)
            aa[i][j] = s[j] == '*';
    }
    for (i = 1; i <= n; i++)
        for (j = 1; j <= n; j++)
            aa[i][j] += aa[i - 1][j];
    for (i = 1; i <= n; i++)
        for (j = 1; j <= n; j++)
            aa[i][j] += aa[i][j - 1];
    while (q--) {
        int i1, j1, i2, j2;
        
        scanf(""%d%d%d%d"", &i1, &j1, &i2, &j2), i1--, j1--;
        printf(""%d\n"", aa[i2][j2] - aa[i1][j2] - aa[i2][j1] + aa[i1][j1]);
    }
    return 0;
}
"
Forest Queries II,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template <class T, int ...Ns> struct BIT {
    T val = 0;
    void upd(T v) { val += v; }
    T query() { return val; }
};

template <class T, int N, int... Ns> struct BIT<T, N, Ns...> {
    BIT<T,Ns...> bit[N + 1];
    template<typename... Args> void upd(int pos, Args... args) {
        for (; pos <= N; pos += (pos&-pos)) bit[pos].upd(args...);
    }
    template<typename... Args> T sum(int r, Args... args) {
        T res = 0; for (; r; r -= (r&-r)) res += bit[r].query(args...);
        return res;
    }
    template<typename... Args> T query(int l, int r, Args... args) {
        return sum(r,args...)-sum(l-1,args...);
    }
}; // BIT<int,10,10> gives a 2D BIT

BIT<int,1000,1000> B;
int n,q;

int main() {
    setIO(); re(n,q);
    F0R(i,n) {
        string s; re(s);
        F0R(j,n) if (s[j] == '*') B.upd(i+1,j+1,1);
    }
    F0R(i,q) {
        int t; re(t);
        if (t == 1) {
            int y,x; re(y,x);
            if (B.query(y,y,x,x)) B.upd(y,x,-1);
            else B.upd(y,x,1);
        } else {
            int y1,x1,y2,x2; re(y1,x1,y2,x2);
            ps(B.query(y1,y2,x1,x2));
        }
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Forest Queries II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr int N=1024;
int ft[N][N];

void update(int i, int j, int d) {
    for(; i<N; i+=i&-i)
        for(int k=j; k<N; k+=k&-k)
            ft[i][k]+=d;
}

int query(int i, int j) {
    int ans=0;
    for(; i; i-=i&-i)
        for(int k=j; k; k-=k&-k)
            ans+=ft[i][k];
    return ans;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    vector<string> s(n);
    rep(i, 0, n) {
        cin >> s[i];
        rep(j, 0, n) if (s[i][j]=='*')
            update(i+1, j+1, 1);
    }
    while (q--) {
        int type;
        cin >> type;
        if (type==1) {
            int i, j;
            cin >> i >> j;
            if(s[i-1][j-1]=='*')
                update(i, j, -1), s[i-1][j-1]='.';
            else
                update(i, j, +1), s[i-1][j-1]='*';
        }
        else {
            int i1, j1, i2, j2;
            cin >> i1 >> j1 >> i2 >> j2;
            int ans=query(i2, j2)+query(i1-1, j1-1);
            ans-=query(i2, j1-1)+query(i1-1, j2);
            cout << ans << '\n';
        }
    }
    return 0;
}
"
Forest Queries II,Java,"// https://cses.fi/problemset/task/1739
// Forest Queries II
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1739 {
    static int[][] tt;
    static void update(int i, int j_, int n, int x) {
        while (i < n) {
            int j = j_;
            while (j < n) {
                tt[i][j] += x;
                j |= j + 1;
            }
            i |= i + 1;
        }
    }
    static int query(int i, int j_) {
        int x = 0;
        while (i >= 0) {
            int j = j_;
            while (j >= 0) {
                x += tt[i][j];
                j &= j + 1;
                j--;
            }
            i &= i + 1;
            i--;
        }
        return x;
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int q = sc.nextInt();
        char[][] cc = new char[n][n];
        for (int i = 0; i < n; i++)
            sc.next().getChars(0, n, cc[i], 0);
        int[][] aa = new int[n + 1][n + 1];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                if (cc[i][j] == '*') {
                    aa[i + 1][j + 1] = 1;
                    cc[i][j] = 1;
                } else
                    cc[i][j] = 0;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                aa[i][j] += aa[i][j - 1];
        for (int j = 1; j <= n; j++)
            for (int i = 1; i <= n; i++)
                aa[i][j] += aa[i - 1][j];
        tt = new int[n][n];
        while (q-- > 0) {
            int t = sc.nextInt();
            if (t == 1) {
                int i = sc.nextInt() - 1;
                int j = sc.nextInt() - 1;
                update(i, j, n, (cc[i][j] ^= 1) == 1 ? 1 : -1);
            } else {
                int il = sc.nextInt();
                int jl = sc.nextInt();
                int ir = sc.nextInt();
                int jr = sc.nextInt();
                int a = aa[ir][jr] - aa[il - 1][jr] - aa[ir][jl - 1] + aa[il - 1][jl - 1];
                il--; jl--; ir--; jr--;
                a += query(ir, jr) - query(il - 1, jr) - query(ir, jl - 1) + query(il - 1, jl - 1);
                pw.println(a);
            }
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        String next() throws IOException {
            StringBuilder sb = new StringBuilder();
            for (byte b = skip(); b > 32; b = getc())
                sb.append((char) b);
            return sb.toString();
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Forest Queries II,C++,"/*
 https://cses.fi/problemset/task/1739
 Forest Queries II
 practice with Dukkha
 */
#include <stdio.h>

#define N    1000

int tt[N][N];

void update(int i, int j_, int n, int x) {
    while (i < n) {
        int j = j_;
        
        while (j < n) {
            tt[i][j] += x;
            j |= j + 1;
        }
        i |= i + 1;
    }
}

int query(int i, int j_) {
    int sum = 0;
    
    while (i >= 0) {
        int j = j_;
        
        while (j >= 0) {
            sum += tt[i][j];
            j &= j + 1;
            j--;
        }
        i &= i + 1;
        i--;
    }
    return sum;
}

int main() {
    static char cc[N][N];
    static int aa[N + 1][N + 1];
    int n, q, i, j, i1, j1, i2, j2, a;
    
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++)
        scanf(""%s"", cc[i]);
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            aa[i + 1][j + 1] = cc[i][j] = cc[i][j] == '*';
    for (i = 1; i <= n; i++)
        for (j = 1; j <= n; j++)
            aa[i][j] += aa[i][j - 1];
    for (i = 1; i <= n; i++)
        for (j = 1; j <= n; j++)
            aa[i][j] += aa[i - 1][j];
    while (q--) {
        int t;
        
        scanf(""%d"", &t);
        if (t == 1) {
            scanf(""%d%d"", &i, &j), i--, j--;
            update(i, j, n, (cc[i][j] ^= 1) ? 1 : -1);
        } else {
            scanf(""%d%d%d%d"", &i1, &j1, &i2, &j2), i1--, j1--;
            a = aa[i2][j2] - aa[i1][j2] - aa[i2][j1] + aa[i1][j1];
            i1--, j1--, i2--, j2--;
            a += query(i2, j2) - query(i1, j2) - query(i2, j1) + query(i1, j1);
            printf(""%d\n"", a);
        }
    }
    return 0;
}
"
Hotel Queries,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

template<class T, int SZ> struct Seg {
    T seg[2*SZ], MN = 0;
    
    Seg() {
        memset(seg,0,sizeof seg);
    }
    
    T comb(T a, T b) { return max(a,b); } // easily change this to min or max
    
    void upd(int p, T value) {  // set value at position p
        for (seg[p += SZ] = value; p > 1; p >>= 1){
            //be careful here: some updates are noncommutative!
            if (p < (p^1)){
                seg[p>>1] = comb(seg[p],seg[p^1]);
            }
            else{
                seg[p>>1] = comb(seg[p^1], seg[p]);
            }
        }
    }
    
    void build() {
        F0Rd(i,SZ) seg[i] = comb(seg[2*i],seg[2*i+1]);
    }
    
    T query(int l, int r) {  // sum on interval [l, r]
        T res = MN; r++;
        for (l += SZ, r += SZ; l < r; l >>= 1, r >>= 1) {
            if (l&1) res = comb(res,seg[l++]);
            if (r&1) res = comb(res,seg[--r]);
        }
        return res;
    }
    
    int get(int x) {
        if (seg[1] < x) return 0;
        int ind = 1, lo = 0, hi = SZ-1;
        while (lo < hi) {
            int mid = (lo+hi)/2;
            if (seg[2*ind] >= x) {
                hi = mid;
                ind *= 2;
            } else {
                lo = mid+1;
                ind = 2*ind+1;
            }
        }
        return lo;
    }
};

Seg<int,1<<18> S;
int n,m;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m;
    F0R(i,n) {
        int x; cin >> x;
        S.upd(i+1,x);
    }
    F0R(i,m) {
        int x; cin >> x;
        int X = S.get(x);
        if (X == 0) cout << ""0 "";
        else {
            S.upd(X,S.query(X,X)-x);
            cout << X << "" "";
        }
    }
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Hotel Queries,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

struct Tree {
    typedef int T;
    static constexpr T unit = INT_MIN;
    T f(T a, T b) { return max(a, b); } // (any associative fn)
    vector<T> s; int n;
    Tree(int n = 0, T def = unit) : s(2*n, def), n(n) {}
    void update(int pos, T val) {
        for (s[pos += n] += val; pos /= 2;)
            s[pos] = f(s[pos * 2], s[pos * 2 + 1]);
    }
    T query(int b, int e) { // query [b, e)
        T ra = unit, rb = unit;
        for (b += n, e += n; b < e; b /= 2, e /= 2) {
            if (b % 2) ra = f(ra, s[b++]);
            if (e % 2) rb = f(s[--e], rb);
        }
        return f(ra, rb);
    }
    int lower_bound(T val) {
        int pos=1;
        while (pos<n) pos=2*pos+(s[2*pos]<val);
        return pos-n;
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int inf=1e9;
    int n, m;
    cin >> n >> m;
    int N=1;
    while (N<=n) N*=2;
    Tree t(N, 0);
    rep(i, 0, n) {
        int a;
        cin >> a;
        t.update(i, a);
    }
    t.update(n, inf);
    while (m--) {
        int a;
        cin >> a;
        int i=t.lower_bound(a);
        if (i==n) cout << ""0\n"";
        else {
            cout << i+1 << '\n';
            t.update(i, -a);
        }
    }
    return 0;
}
"
Hotel Queries,Java,"// https://cses.fi/problemset/task/1143
// Hotels
import java.io.*;
import java.util.*;

public class CSES1143 {
    static int[] tr, hh;
    static void build(int k, int l, int r) {
        if (r - l == 1)
            tr[k] = hh[l];
        else {
            int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
            build(k1, l, m);
            build(k2, m, r);
            tr[k] = Math.max(tr[k1], tr[k2]);
        }
    }
    static int update(int k, int l, int r, int x) {
        if (r - l == 1) {
            tr[k] -= x;
            return l;
        }
        int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        int i = tr[k1] >= x ? update(k1, l, m, x) : update(k2, m, r, x);
        tr[k] = Math.max(tr[k1], tr[k2]);
        return i;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        int n_ = 1;
        while (n_ < n)
            n_ *= 2;
        tr = new int[n_ * 2];
        hh = new int[n];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++)
            hh[i] = Integer.parseInt(st.nextToken());
        build(0, 0, n);
        st = new StringTokenizer(br.readLine());
        StringBuilder sb = new StringBuilder();
        while (m-- > 0) {
            int x = Integer.parseInt(st.nextToken());
            int i = tr[0] >= x ? update(0, 0, n, x) + 1 : 0;
            sb.append(i + "" "");
        }
        System.out.println(sb);
    }
}
"
Hotel Queries,C++,"/*
 https://cses.fi/problemset/task/1143
 Hotels
 */
#include <stdio.h>

#define N    200000
#define N_    (1 << 18)    /* pow2(ceil(log2(N))) */

int tr[N_ * 2], hh[N];

void build(int k, int l, int r) {
    if (r - l == 1)
        tr[k] = hh[l];
    else {
        int    m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        
        build(k1, l, m);
        build(k2, m, r);
        tr[k] = tr[k1] > tr[k2] ? tr[k1] : tr[k2];
    }
}

int update(int k, int l, int r, int x) {
    int    m, k1, k2, i;
    
    if (r - l == 1) {
        tr[k] -= x;
        return l;
    }
    m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
    i = tr[k1] >= x ? update(k1, l, m, x) : update(k2, m, r, x);
    tr[k] = tr[k1] > tr[k2] ? tr[k1] : tr[k2];
    return i;
}

int main() {
    int n, m, i;
    
    scanf(""%d%d"", &n, &m);
    for (i = 0; i < n; i++)
        scanf(""%d"", &hh[i]);
    build(0, 0, n);
    while (m--) {
        int x, i;
        
        scanf(""%d"", &x);
        i = tr[0] >= x ? update(0, 0, n, x) + 1 : 0;
        printf(""%d "", i);
    }
    printf(""\n"");
    return 0;
}
"
List Removals,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n;
rope<int> x;

int main() {
    setIO(); re(n);
    F0R(i,n) {
        int t; re(t);
        x.pb(t);
    }
    F0R(i,n) {
        int p; re(p);
        pr(x[p-1],' ');
        x.erase(x.mutable_begin()+p-1);
        // exit(0);
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
List Removals,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

#include <bits/extc++.h>
using namespace __gnu_pbds;

template<class T>
using Tree = tree<T, null_type, less<T>, rb_tree_tag,
tree_order_statistics_node_update>;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    Tree<pii> t;
    rep(i, 0, n) {
        int a;
        cin >> a;
        t.insert({i, a});
    }
    rep(i, 0, n) {
        int a;
        cin >> a;
        auto p=t.find_by_order(a-1);
        cout << p->second << "" \n""[i==n-1];
        t.erase(p);
    }
    return 0;
}
"
List Removals,Java,"// https://cses.fi/problemset/task/1749
// List Removals
// practice with rainboy
import java.io.*;

public class CSES1749 {
    static int[] tr;
    static void build(int k, int l, int r) {
        if (r - l == 1) {
            tr[k] = 1;
            return;
        }
        int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        build(k1, l, m);
        build(k2, m, r);
        tr[k] = tr[k1] + tr[k2];
    }
    static int query(int k, int l, int r, int x) {
        tr[k]--;
        if (r - l == 1)
            return r;
        int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        return tr[k1] >= x ? query(k1, l, m, x) : query(k2, m, r, x - tr[k1]);
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = sc.nextInt();
        int n_ = 1;
        while (n_ < n)
            n_ *= 2;
        tr = new int[n_ * 2];
        build(0, 0, n);
        for (int h = 0; h < n; h++) {
            int x = sc.nextInt();
            int i = query(0, 0, n, x) - 1;
            pw.print(aa[i] + "" "");
        }
        pw.println();
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
List Removals,C++,"/*
 https://cses.fi/problemset/task/1749
 List Removals
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define N_    (1 << 18)    /* N_ = pow2(ceil(log2(N))) */

int tr[N_ * 2];

void build(int k, int l, int r) {
    tr[k] = r - l;
    if (r - l > 1) {
        int m = (l + r) / 2;
        
        build(k * 2 + 1, l, m);
        build(k * 2 + 2, m, r);
    }
}

int query(int k, int l, int r, int x) {
    int m, k1, k2;
    
    tr[k]--;
    if (r - l == 1)
        return r;
    m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
    return tr[k1] >= x ? query(k1, l, m, x) : query(k2, m, r, x - tr[k1]);
}

int main() {
    static int aa[N];
    int n, h, i, x;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    build(0, 0, n);
    for (h = 0; h < n; h++) {
        scanf(""%d"", &x);
        i = query(0, 0, n, x) - 1;
        printf(""%d "", aa[i]);
    }
    printf(""\n"");
    return 0;
}
"
Polynomial Queries,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;


template <class T, int ...Ns> struct BIT {
    T val = 0;
    void upd(T v) { val += v; }
    T query() { return val; }
};

template <class T, int N, int... Ns> struct BIT<T, N, Ns...> {
    BIT<T,Ns...> bit[N + 1];
    template<typename... Args> void upd(int pos, Args... args) {
        for (; pos <= N; pos += (pos&-pos)) bit[pos].upd(args...);
    }
    template<typename... Args> T sum(int r, Args... args) {
        T res = 0; for (; r; r -= (r&-r)) res += bit[r].query(args...);
        return res;
    }
    template<typename... Args> T query(int l, int r, Args... args) {
        return sum(r,args...)-sum(l-1,args...);
    }
}; // BIT<int,10,10> gives a 2D BIT

BIT<ll,MX> B[3];
int n,q;

void upd(int r, pl x) {
    B[2].upd(1,x.f); B[2].upd(r+1,-x.f); B[0].upd(r+1,x.f*r*(r+1)/2);
    B[1].upd(1,x.s); B[1].upd(r+1,-x.s); B[0].upd(r+1,x.s*r);
    // ps(""HA"",r,x);
}

void upd(int l, int r, pl x) {
    upd(r,x), upd(l-1,{-x.f,-x.s});
}

ll query(int r) {
    // ps(""OOPS"",B[0].sum(r),B[1].sum(r),B[2].sum(r));
    return B[0].sum(r)+B[1].sum(r)*r+B[2].sum(r)*r*(r+1)/2;
}

int main() {
    setIO(); re(n,q);
    FOR(i,1,n+1) {
        int x; re(x);
        upd(i,i,{0,x});
        // ps(query(5));
    }
    F0R(i,q) {
        int t,a,b; re(t,a,b);
        if (t == 1) upd(a,b,{1,1-a});
        else ps(query(b)-query(a-1));
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Polynomial Queries,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

struct Node {
    typedef ll T;
    static constexpr T unit = 0;
    static constexpr T none = 1e18;
    T f(T a, T b) { return a+b; }
    T fset(T a) {
        return type? 1LL*(hi-lo)*(hi-1+lo)/2*a : (hi-lo)*a;
    }
    T fadd(T a) {
        return val+(type? 1LL*(hi-lo)*(hi-1+lo)/2*a : (hi-lo)*a);
    }
    Node *l = 0, *r = 0;
    int lo, hi, type;
    T mset = none, madd = unit, val = unit;
    Node(int lo, int hi, int type)
    :lo(lo), hi(hi), type(type) {}
    Node(vector<T>& v, int lo, int hi, int type)
    : lo(lo), hi(hi), type(type) {
        if (lo + 1 < hi) {
            int mid = lo + (hi - lo)/2;
            l = new Node(v, lo, mid, type);
            r = new Node(v, mid, hi, type);
            val = f(l->val, r->val);
        }
        else val = fset(v[lo]);
    }
    T query(int L, int R) {
        if (R <= lo || hi <= L) return unit;
        if (L <= lo && hi <= R) return val;
        push();
        return f(l->query(L, R), r->query(L, R));
    }
    void set(int L, int R, T x) {
        if (R <= lo || hi <= L) return;
        if (L <= lo && hi <= R)
            mset = x, madd = unit, val = fset(x);
        else {
            push(), l->set(L, R, x), r->set(L, R, x);
            val = f(l->val, r->val);
        }
    }
    void add(int L, int R, T x) {
        if (R <= lo || hi <= L) return;
        if (L <= lo && hi <= R) {
            if (mset != none) mset = f(mset, x);
            else madd = f(madd, x);
            val = fadd(x);
        }
        else {
            push(), l->add(L, R, x), r->add(L, R, x);
            val = f(l->val, r->val);
        }
    }
    void push() {
        if (!l) {
            int mid = lo + (hi - lo)/2;
            l = new Node(lo, mid, type); r = new Node(mid, hi, type);
        }
        if (mset != none)
            l->set(lo,hi,mset), r->set(lo,hi,mset), mset = none;
        else if (madd!=unit)
            l->add(lo,hi,madd), r->add(lo,hi,madd), madd = unit;
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    vector<ll> v0(n+1), v1(n+1);
    rep(i, 1, n+1) cin >> v0[i];
    Node* tr0 = new Node(v0, 0, n+1, 0);
    Node* tr1 = new Node(v1, 0, n+1, 1);
    while (q--)  {
        int type, L, R;
        cin >> type >> L >> R;
        if (type==1) {
            tr0->add(L, R+1, -L+1);
            tr1->add(L, R+1, 1);
        }
        else
            cout << tr0->query(L, R+1) + tr1->query(L, R+1) << '\n';
    }
    return 0;
}
"
Polynomial Queries,Java,"// https://cses.fi/problemset/task/1736
// Polynomial Queries
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1736 {
    static int[] xx;
    static long[] tr, aa, bb;
    static void build(int k, int l, int r) {
        if (r - l == 1) {
            tr[k] = xx[l];
            return;
        }
        int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        build(k1, l, m);
        build(k2, m, r);
        tr[k] = tr[k1] + tr[k2];
    }
    static long sum(long a, long b, int n) {
        return n * (b * 2 + (n - 1) * a) / 2;
    }
    static void update(int k, int l, int r, int ql, int qr, long a, long b) {
        if (qr <= l || r <= ql)
            return;
        if (ql <= l && r <= qr) {
            long b_ = b + (l - ql) * a;
            tr[k] += sum(a, b_, r - l);
            aa[k] += a;
            bb[k] += b_;
            return;
        }
        int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        if (aa[k] != 0 || bb[k] != 0) {
            update(k1, l, m, l, m, aa[k], bb[k]);
            update(k2, m, r, m, r, aa[k], bb[k] + (m - l) * aa[k]);
            aa[k] = bb[k] = 0;
        }
        update(k1, l, m, ql, qr, a, b);
        update(k2, m, r, ql, qr, a, b);
        tr[k] = tr[k1] + tr[k2];
    }
    static long query(int k, int l, int r, int ql, int qr) {
        if (qr <= l || r <= ql)
            return 0;
        if (ql <= l && r <= qr)
            return tr[k];
        int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        if (aa[k] != 0 || bb[k] != 0) {
            update(k1, l, m, l, m, aa[k], bb[k]);
            update(k2, m, r, m, r, aa[k], bb[k] + (m - l) * aa[k]);
            aa[k] = bb[k] = 0;
        }
        return query(k1, l, m, ql, qr) + query(k2, m, r, ql, qr);
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int q = sc.nextInt();
        xx = new int[n];
        for (int i = 0; i < n; i++)
            xx[i] = sc.nextInt();
        int n_ = 1;
        while (n_ <= n)
            n_ *= 2;
        tr = new long[n_ * 2];
        aa = new long[n_ * 2];
        bb = new long[n_ * 2];
        build(0, 0, n);
        while (q-- > 0) {
            int t = sc.nextInt();
            int l = sc.nextInt() - 1;
            int r = sc.nextInt();
            if (t == 1)
                update(0, 0, n, l, r, 1, 1);
            else
                pw.println(query(0, 0, n, l, r));
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Polynomial Queries,C++,"/*
 https://cses.fi/problemset/task/1736
 Polynomial Queries
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define N_    (1 << 18)    /* N_ = pow2(ceil(log2(N))) */

int xx[N];
long long tr[N_ * 2], aa[N_ * 2], bb[N_ * 2];

void build(int k, int l, int r) {
    int m, k1, k2;
    
    if (r - l == 1) {
        tr[k] = xx[l];
        return;
    }
    m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
    build(k1, l, m);
    build(k2, m, r);
    tr[k] = tr[k1] + tr[k2];
}

long long sum(long long a, long long b, int n) {
    return n * (b * 2 + (n - 1) * a) / 2;
}

void update(int k, int l, int r, int ql, int qr, long long a, long long b) {
    int m, k1, k2;
    
    if (qr <= l || r <= ql)
        return;
    if (ql <= l && r <= qr) {
        long long b_ = b + (l - ql) * a;
        
        tr[k] += sum(a, b_, r - l);
        aa[k] += a;
        bb[k] += b_;
        return;
    }
    m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
    if (aa[k] || bb[k]) {
        update(k1, l, m, l, m, aa[k], bb[k]);
        update(k2, m, r, m, r, aa[k], bb[k] + (m - l) * aa[k]);
        aa[k] = bb[k] = 0;
    }
    update(k1, l, m, ql, qr, a, b);
    update(k2, m, r, ql, qr, a, b);
    tr[k] = tr[k1] + tr[k2];
}

long long query(int k, int l, int r, int ql, int qr) {
    int m, k1, k2;
    
    if (qr <= l || r <= ql)
        return 0;
    if (ql <= l && r <= qr)
        return tr[k];
    m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
    if (aa[k] || bb[k]) {
        update(k1, l, m, l, m, aa[k], bb[k]);
        update(k2, m, r, m, r, aa[k], bb[k] + (m - l) * aa[k]);
        aa[k] = bb[k] = 0;
    }
    return query(k1, l, m, ql, qr) + query(k2, m, r, ql, qr);
}

int main() {
    int n, q, i;
    
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++)
        scanf(""%d"", &xx[i]);
    build(0, 0, n);
    while (q--) {
        int t, l, r;
        
        scanf(""%d%d%d"", &t, &l, &r), l--;
        if (t == 1)
            update(0, 0, n, l, r, 1, 1);
        else
            printf(""%lld\n"", query(0, 0, n, l, r));
    }
    return 0;
}
"
Range Minimum Queries I,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<class T, int SZ> struct Seg { // SZ should be power of 2
    T seg[2*SZ], ID = MOD;
    
    Seg() { memset(seg,0,sizeof seg); }
    T comb(T a, T b) { return min(a,b); }
    // easily change this to min or max
    // comb(ID,b) must equal b
    
    void build() { F0Rd(i,SZ) seg[i] = comb(seg[2*i],seg[2*i+1]); }
    
    void upd(int p, T value) {  // set value at position p
        for (seg[p += SZ] = value; p > 1; p >>= 1)
            seg[p>>1] = comb(seg[(p|1)^1],seg[p|1]);
        // make sure non-commutative operations work
    }
    
    T query(int l, int r) {  // sum on interval [l, r]
        T res1 = ID, res2 = ID; r++;
        for (l += SZ, r += SZ; l < r; l >>= 1, r >>= 1) {
            if (l&1) res1 = comb(res1,seg[l++]);
            if (r&1) res2 = comb(seg[--r],res2);
        }
        return comb(res1,res2);
    }
};

Seg<ll,1<<18> S;

int n,q;

int main() {
    setIO(); re(n,q);
    FOR(i,1,n+1) {
        int x; re(x);
        S.upd(i,x);
    }
    F0R(i,q) {
        int t=2,a,b; re(a,b);
        if (t == 1) {
            S.upd(a,b);
        } else {
            ps(S.query(a,b));
        }
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Range Minimum Queries I,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

template<class T>
struct RMQ {
    vector<vector<T>> jmp;
    
    RMQ(const vector<T>& V) {
        int N = sz(V), on = 1, depth = 1;
        while (on < N) on *= 2, depth++;
        jmp.assign(depth, V);
        rep(i,0,depth-1) rep(j,0,N)
        jmp[i+1][j] = min(jmp[i][j],
                          jmp[i][min(N - 1, j + (1 << i))]);
    }
    
    T query(int a, int b) {
        assert(a < b); // or return inf if a == b
        int dep = 31 - __builtin_clz(b - a);
        return min(jmp[dep][a], jmp[dep][b - (1 << dep)]);
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    vi x(n);
    rep(i, 0, n) cin >> x[i];
    RMQ<int> rmq(x);
    rep(i, 0, q) {
        int a, b;
        cin >> a >> b;
        cout << rmq.query(a-1, b) << '\n';
    }
    return 0;
}
"
Range Minimum Queries I,Java,"// https://cses.fi/problemset/task/1647
// Range Minimum Queries I
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1647 {
    static final int INF = 0x3f3f3f3f;
    static int[] tr, aa;
    static void build(int k, int l, int r) {
        if (r - l == 1) {
            tr[k] = aa[l];
            return;
        }
        int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        build(k1, l, m);
        build(k2, m, r);
        tr[k] = Math.min(tr[k1], tr[k2]);
    }
    static int query(int k, int l, int r, int ql, int qr) {
        if (qr <= l || r <= ql)
            return INF;
        if (ql <= l && r <= qr)
            return tr[k];
        int m = (l + r) / 2;
        int a1 = query(k * 2 + 1, l, m, ql, qr);
        int a2 = query(k * 2 + 2, m, r, ql, qr);
        return Math.min(a1, a2);
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int q = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = Integer.parseInt(st.nextToken());
        int n_ = 1;
        while (n_ < n)
            n_ *= 2;
        tr = new int[n_ * 2];
        build(0, 0, n);
        while (q-- > 0) {
            st = new StringTokenizer(br.readLine());
            int l = Integer.parseInt(st.nextToken()) - 1;
            int r = Integer.parseInt(st.nextToken());
            pw.println(query(0, 0, n, l, r));
        }
        pw.close();
    }
}
"
Range Minimum Queries I,C++,"/*
 https://cses.fi/problemset/task/1647
 Range Minimum Queries I
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define N_    (1 << 18)    /* N_ = pow2(ceil(log2(N))) */
#define INF    0x3f3f3f3f

int tt[N_ * 2];

void build(int *aa, int k, int l, int r) {
    int m, k1, k2;
    
    if (r - l == 1) {
        tt[k] = aa[l];
        return;
    }
    m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
    build(aa, k1, l, m);
    build(aa, k2, m, r);
    tt[k] = tt[k1] < tt[k2] ? tt[k1] : tt[k2];
}

int query(int k, int l, int r, int ql, int qr) {
    int m, q1, q2;
    
    if (qr <= l || r <= ql)
        return INF;
    if (ql <= l && r <= qr)
        return tt[k];
    m = (l + r) / 2;
    q1 = query(k * 2 + 1, l, m, ql, qr);
    q2 = query(k * 2 + 2, m, r, ql, qr);
    return q1 < q2 ? q1 : q2;
}

int main() {
    static int aa[N];
    int n, q, i, j;
    
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    build(aa, 0, 0, n);
    while (q--) {
        scanf(""%d%d"", &i, &j), i--;
        printf(""%d\n"", query(0, 0, n, i, j));
    }
    return 0;
}
"
Range Minimum Queries II,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<class T, int SZ> struct Seg { // SZ should be power of 2
    T seg[2*SZ], ID = MOD;
    
    Seg() { memset(seg,0,sizeof seg); }
    T comb(T a, T b) { return min(a,b); }
    // easily change this to min or max
    // comb(ID,b) must equal b
    
    void build() { F0Rd(i,SZ) seg[i] = comb(seg[2*i],seg[2*i+1]); }
    
    void upd(int p, T value) {  // set value at position p
        for (seg[p += SZ] = value; p > 1; p >>= 1)
            seg[p>>1] = comb(seg[(p|1)^1],seg[p|1]);
        // make sure non-commutative operations work
    }
    
    T query(int l, int r) {  // sum on interval [l, r]
        T res1 = ID, res2 = ID; r++;
        for (l += SZ, r += SZ; l < r; l >>= 1, r >>= 1) {
            if (l&1) res1 = comb(res1,seg[l++]);
            if (r&1) res2 = comb(seg[--r],res2);
        }
        return comb(res1,res2);
    }
};

Seg<ll,1<<18> S;

int n,q;

int main() {
    setIO(); re(n,q);
    FOR(i,1,n+1) {
        int x; re(x);
        S.upd(i,x);
    }
    F0R(i,q) {
        int t,a,b; re(t,a,b);
        if (t == 1) {
            S.upd(a,b);
        } else {
            ps(S.query(a,b));
        }
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Range Minimum Queries II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

struct Tree {
    typedef int T;
    static constexpr T unit = INT_MAX;
    T f(T a, T b) { return min(a, b); } // (any associative fn)
    vector<T> s; int n;
    Tree(int n = 0, T def = unit) : s(2*n, def), n(n) {}
    void update(int pos, T val) {
        for (s[pos += n] = val; pos /= 2;)
            s[pos] = f(s[pos * 2], s[pos * 2 + 1]);
    }
    T query(int b, int e) { // query [b, e)
        T ra = unit, rb = unit;
        for (b += n, e += n; b < e; b /= 2, e /= 2) {
            if (b % 2) ra = f(ra, s[b++]);
            if (e % 2) rb = f(s[--e], rb);
        }
        return f(ra, rb);
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    Tree t(n+1);
    rep(i, 1, n+1) {
        int a;
        cin >> a;
        t.update(i, a);
    }
    while (q--) {
        int type, a, b;
        cin >> type >> a >> b;
        if (type==1) t.update(a, b);
        else cout << t.query(a, b+1) << '\n';
    }
    return 0;
}
"
Range Minimum Queries II,Java,"// https://cses.fi/problemset/task/1649
// Range Minimum Queries II
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1649 {
    static final int INF = 0x3f3f3f3f;
    static int[] tr, aa;
    static void build(int k, int l, int r) {
        if (r - l == 1) {
            tr[k] = aa[l];
            return;
        }
        int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        build(k1, l, m);
        build(k2, m, r);
        tr[k] = Math.min(tr[k1], tr[k2]);
    }
    static void update(int k, int l, int r, int i, int x) {
        if (r - l == 1) {
            tr[k] = x;
            return;
        }
        int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        if (i < m)
            update(k1, l, m, i, x);
        else
            update(k2, m, r, i, x);
        tr[k] = Math.min(tr[k1], tr[k2]);
    }
    static int query(int k, int l, int r, int ql, int qr) {
        if (qr <= l || r <= ql)
            return INF;
        if (ql <= l && r <= qr)
            return tr[k];
        int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        int a1 = query(k1, l, m, ql, qr);
        int a2 = query(k2, m, r, ql, qr);
        return Math.min(a1, a2);
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int q = sc.nextInt();
        aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = sc.nextInt();
        int n_ = 1;
        while (n_ < n)
            n_ *= 2;
        tr = new int[n_ * 2];
        build(0, 0, n);
        while (q-- > 0) {
            int t = sc.nextInt();
            if (t == 1) {
                int i = sc.nextInt() - 1;
                int x = sc.nextInt();
                update(0, 0, n, i, x);
            } else {
                int l = sc.nextInt() - 1;
                int r = sc.nextInt();
                pw.println(query(0, 0, n, l, r));
            }
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Range Minimum Queries II,C++,"/*
 https://cses.fi/problemset/task/1649
 Range Minimum Queries II
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define N_    (1 << 18)    /* N_ = pow2(ceil(log2(N))) */
#define INF    0x3f3f3f3f

int tt[N_ * 2], aa[N];

void build(int k, int l, int r) {
    int m, k1, k2;
    
    if (r - l == 1) {
        tt[k] = aa[l];
        return;
    }
    m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
    build(k1, l, m);
    build(k2, m, r);
    tt[k] = tt[k1] < tt[k2] ? tt[k1] : tt[k2];
}

void update(int k, int l, int r, int i, int x) {
    int m, k1, k2;
    
    if (r - l == 1) {
        tt[k] = x;
        return;
    }
    m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
    if (i < m)
        update(k1, l, m, i, x);
    else
        update(k2, m, r, i, x);
    tt[k] = tt[k1] < tt[k2] ? tt[k1] : tt[k2];
}

int query(int k, int l, int r, int ql, int qr) {
    int m, q1, q2;
    
    if (qr <= l || r <= ql)
        return INF;
    if (ql <= l && r <= qr)
        return tt[k];
    m = (l + r) / 2;
    q1 = query(k * 2 + 1, l, m, ql, qr);
    q2 = query(k * 2 + 2, m, r, ql, qr);
    return q1 < q2 ? q1 : q2;
}

int main() {
    int n, q, i, j, a;
    
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    build(0, 0, n);
    while (q--) {
        int    t;
        
        scanf(""%d"", &t);
        if (t == 1) {
            scanf(""%d%d"", &i, &a), i--;
            update(0, 0, n, i, a);
        } else {
            scanf(""%d%d"", &i, &j), i--;
            printf(""%d\n"", query(0, 0, n, i, j));
        }
    }
    return 0;
}
"
Range Queries and Copies,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<class T, int SZ> struct pseg {
    static const int LIMIT = 10000000; // adjust
    int l[LIMIT], r[LIMIT], nex = 0;
    T val[LIMIT], lazy[LIMIT];
    
    //// HELPER
    int copy(int cur) {
        int x = nex++;
        val[x] = val[cur], l[x] = l[cur], r[x] = r[cur]; // lazy[x] = lazy[cur];
        return x;
    }
    T comb(T a, T b) { return a+b; }
    void pull(int x) { val[x] = comb(val[l[x]],val[r[x]]); }
    /*void push(int cur, int L, int R) {
     if (!lazy[cur]) return;
     if (L != R) {
     l[cur] = copy(l[cur]);
     val[l[cur]] += lazy[cur];
     lazy[l[cur]] += lazy[cur];
     
     r[cur] = copy(r[cur]);
     val[r[cur]] += lazy[cur];
     lazy[r[cur]] += lazy[cur];
     }
     lazy[cur] = 0;
     }*/
    
    //// MAIN FUNCTIONS
    T query(int cur, int lo, int hi, int L, int R) {
        if (lo <= L && R <= hi) return val[cur];
        if (R < lo || hi < L) return 0;
        int M = (L+R)/2;
        return comb(query(l[cur],lo,hi,L,M), query(r[cur],lo,hi,M+1,R));
    }
    int upd(int cur, int pos, T v, int L, int R) {
        if (R < pos || pos < L) return cur;
        
        int x = copy(cur);
        if (pos <= L && R <= pos) { val[x] = v; return x; }
        
        int M = (L+R)/2;
        l[x] = upd(l[x],pos,v,L,M), r[x] = upd(r[x],pos,v,M+1,R);
        pull(x); return x;
    }
    int build(vector<T>& arr, int L, int R) {
        int cur = nex++;
        if (L == R) {
            if (L < sz(arr)) val[cur] = arr[L];
            return cur;
        }
        
        int M = (L+R)/2;
        l[cur] = build(arr,L,M), r[cur] = build(arr,M+1,R);
        pull(cur); return cur;
    }
    
    //// PUBLIC
    vi loc;
    //void upd(int lo, int hi, T v) { loc.pb(upd(loc.back(),lo,hi,v,0,SZ-1)); }
    //T query(int ti, int lo, int hi) { return query(loc[ti],lo,hi,0,SZ-1); }
    void build(vector<T>& arr) { loc.pb(build(arr,0,SZ-1)); }
};

pseg<ll,MX> P;
int n,q;
vl t;

int main() {
    setIO(); re(n,q); t.resz(n); re(t);
    // ps (t);
    
    P.build(t);
    // ps(P.query(P.loc[0],0,MX-1,0,MX-1)); exit(0);
    F0R(i,q) {
        int t; re(t);
        if (t == 1) {
            int k,a,x; re(k,a,x); k--,a--;
            P.loc[k] = P.upd(P.loc[k],a,x,0,MX-1);
        } else if (t == 2) {
            int k,a,b; re(k,a,b); k--,a--,b--;
            ps(P.query(P.loc[k],a,b,0,MX-1));
        } else {
            int k; re(k); k--;
            P.loc.pb(P.loc[k]);
        }
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Range Queries and Copies,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

struct Node {
    int l, r;
    ll val;
    Node(int l, int r, ll val)
    : l(l), r(r), val(val) {}
};
vector<Node> T;
vi root;

int build(int L, int R, vi &x) {
    if (R-L==1) {
        T.push_back(Node(0, 0, x[L]));
        return sz(T)-1;
    }
    int M=(L+R)/2;
    int ll=build(L, M, x);
    int rr=build(M, R, x);
    T.push_back(Node(ll, rr, T[ll].val+T[rr].val));
    return sz(T)-1;
}

int update(int i, int L, int R, int w, int val) {
    if(R-L==1) {
        T.push_back(Node(0, 0, val));
        return sz(T)-1;
    }
    int M=(L+R)/2;
    int ll=T[i].l, rr=T[i].r;
    if (w<M) ll=update(T[i].l, L, M, w, val);
    else rr=update(T[i].r, M, R, w, val);
    T.push_back(Node(ll, rr, T[ll].val+T[rr].val));
    return sz(T)-1;
}

ll query(int i, int L, int R, int lo, int hi) {
    if (lo<=L && hi>=R)
        return T[i].val;
    if (lo>=R || hi<=L)
        return 0;
    int M=(L+R)/2;
    return query(T[i].l, L, M, lo, hi)
    +query(T[i].r, M, R, lo, hi);
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    vi x(n);
    rep(i, 0, n) cin >> x[i];
    root.push_back(build(0, n, x));
    while (q--) {
        int type, k;
        cin >> type >> k;
        k--;
        if (type==1) {
            int a, b;
            cin >> a >> b;
            root[k]=update(root[k], 0, n, a-1, b);
        }
        else if (type==2) {
            int a, b;
            cin >> a >> b;
            cout << query(root[k], 0, n, a-1, b) << '\n';
        }
        else if (type==3) {
            root.push_back(root[k]);
        }
    }
    return 0;
}
"
Range Queries and Copies,Java,"// https://cses.fi/problemset/task/1737
// Range Queries and Copies
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1737 {
    static class T {
        T l, r;
        long x;
    }
    static int[] aa;
    static T build(int l, int r) {
        T t = new T();
        if (r - l == 1)
            t.x = aa[l];
        else {
            int m = (l + r) / 2;
            t.l = build(l, m);
            t.r = build(m, r);
            t.x = t.l.x + t.r.x;
        }
        return t;
    }
    static T update(T t, int l, int r, int i, int x) {
        T t_ = new T();
        if (r - l == 1)
            t_.x = x;
        else {
            int m = (l + r) / 2;
            if (i < m) {
                t_.l = update(t.l, l, m, i, x);
                t_.r = t.r;
            } else {
                t_.l = t.l;
                t_.r = update(t.r, m, r, i, x);
            }
            t_.x = t_.l.x + t_.r.x;
        }
        return t_;
    }
    static long query(T t, int l, int r, int ql, int qr) {
        if (qr <= l || r <= ql || t == null)
            return 0;
        if (ql <= l && r <= qr)
            return t.x;
        int m = (l + r) / 2;
        return query(t.l, l, m, ql, qr) + query(t.r, m, r, ql, qr);
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int q = sc.nextInt();
        aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = sc.nextInt();
        T[] tt = new T[q];
        int k = 0;
        tt[k++] = build(0, n);
        while (q-- > 0) {
            int t = sc.nextInt();
            int h = sc.nextInt() - 1;
            if (t == 1) {
                int i = sc.nextInt() - 1;
                int x = sc.nextInt();
                tt[h] = update(tt[h], 0, n, i, x);
            } else if (t == 3) {
                tt[k++] = tt[h];
            } else {
                int l = sc.nextInt() - 1;
                int r = sc.nextInt();
                pw.println(query(tt[h], 0, n, l, r));
            }
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Range Queries and Copies,C++,"/*
 https://cses.fi/problemset/task/1737
 Range Queries and Copies
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define Q    200000
#define LN    18    /* LN = ceil(log2(N)) */

struct T {
    struct T *l, *r;
    long long x;
} *tt[Q];

struct T *new_T() {
    static struct T t91[N * 2 + Q * (LN + 1)], *t = t91;
    
    return t++;
}

int aa[N];

struct T *build(int l, int r) {
    struct T *t = new_T();
    
    if (r - l == 1)
        t->x = aa[l];
    else {
        int m = (l + r) / 2;
        
        t->l = build(l, m);
        t->r = build(m, r);
        t->x = t->l->x + t->r->x;
    }
    return t;
}

struct T *update(struct T *t, int l, int r, int i, int x) {
    struct T *t_ = new_T();
    
    if (r - l == 1)
        t_->x = x;
    else {
        int m = (l + r) / 2;
        
        if (i < m) {
            t_->l = update(t->l, l, m, i, x);
            t_->r = t->r;
        } else {
            t_->l = t->l;
            t_->r = update(t->r, m, r, i, x);
        }
        t_->x = t_->l->x + t_->r->x;
    }
    return t_;
}

long long query(struct T *t, int l, int r, int ql, int qr) {
    int m;
    
    if (qr <= l || r <= ql || t == NULL)
        return 0;
    if (ql <= l && r <= qr)
        return t->x;
    m = (l + r) / 2;
    return query(t->l, l, m, ql, qr) + query(t->r, m, r, ql, qr);
}

int main() {
    int n, q, h, i, k, t, l, r, x;
    
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    k = 0;
    tt[k++] = build(0, n);
    while (q--) {
        scanf(""%d%d"", &t, &h), h--;
        if (t == 1) {
            scanf(""%d%d"", &i, &x), i--;
            tt[h] = update(tt[h], 0, n, i, x);
        } else if (t == 3) {
            tt[k++] = tt[h];
        } else {
            scanf(""%d%d"", &l, &r), l--;
            printf(""%lld\n"", query(tt[h], 0, n, l, r));
        }
    }
    return 0;
}
"
Range Sum Queries I,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<class T, int SZ> struct Seg { // SZ should be power of 2
    T seg[2*SZ], ID = 0;
    
    Seg() { memset(seg,0,sizeof seg); }
    T comb(T a, T b) { return a+b; }
    // easily change this to min or max
    // comb(ID,b) must equal b
    
    void build() { F0Rd(i,SZ) seg[i] = comb(seg[2*i],seg[2*i+1]); }
    
    void upd(int p, T value) {  // set value at position p
        for (seg[p += SZ] = value; p > 1; p >>= 1)
            seg[p>>1] = comb(seg[(p|1)^1],seg[p|1]);
        // make sure non-commutative operations work
    }
    
    T query(int l, int r) {  // sum on interval [l, r]
        T res1 = ID, res2 = ID; r++;
        for (l += SZ, r += SZ; l < r; l >>= 1, r >>= 1) {
            if (l&1) res1 = comb(res1,seg[l++]);
            if (r&1) res2 = comb(seg[--r],res2);
        }
        return comb(res1,res2);
    }
};

Seg<ll,1<<18> S;

int n,q;

int main() {
    setIO(); re(n,q);
    FOR(i,1,n+1) {
        int x; re(x);
        S.upd(i,x);
    }
    F0R(i,q) {
        int t=2,a,b; re(a,b);
        if (t == 1) {
            // S.upd(a,b);
        } else {
            ps(S.query(a,b));
        }
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Range Sum Queries I,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    vector<ll> x(n+1);
    rep(i, 1, n+1) {
        cin >> x[i];
        x[i]+=x[i-1];
    }
    while (q--) {
        int a, b;
        cin >> a >> b;
        cout << x[b]-x[a-1] << '\n';
    }
    return 0;
}
"
Range Sum Queries I,Java,"// https://cses.fi/problemset/task/1646
// Range Sum Queries I
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1646 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int q = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        long[] aa = new long[n];
        long a = 0;
        for (int i = 0; i < n; i++)
            aa[i] = a += Integer.parseInt(st.nextToken());
        while (q-- > 0) {
            st = new StringTokenizer(br.readLine());
            int l = Integer.parseInt(st.nextToken()) - 1;
            int r = Integer.parseInt(st.nextToken()) - 1;
            pw.println(aa[r] - (l == 0 ? 0 : aa[l - 1]));
        }
        pw.close();
    }
}
"
Range Sum Queries I,C++,"/*
 https://cses.fi/problemset/task/1646
 Range Sum Queries I
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000

int main() {
    static long long aa[N];
    int n, q, i, j;
    
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++)
        scanf(""%lld"", &aa[i]);
    for (i = 1; i < n; i++)
        aa[i] += aa[i - 1];
    while (q--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        printf(""%lld\n"", aa[j] - (i == 0 ? 0 : aa[i - 1]));
    }
    return 0;
}
"
Range Sum Queries II,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<class T, int SZ> struct Seg { // SZ should be power of 2
    T seg[2*SZ], ID = 0;
    
    Seg() { memset(seg,0,sizeof seg); }
    T comb(T a, T b) { return a+b; }
    // easily change this to min or max
    // comb(ID,b) must equal b
    
    void build() { F0Rd(i,SZ) seg[i] = comb(seg[2*i],seg[2*i+1]); }
    
    void upd(int p, T value) {  // set value at position p
        for (seg[p += SZ] = value; p > 1; p >>= 1)
            seg[p>>1] = comb(seg[(p|1)^1],seg[p|1]);
        // make sure non-commutative operations work
    }
    
    T query(int l, int r) {  // sum on interval [l, r]
        T res1 = ID, res2 = ID; r++;
        for (l += SZ, r += SZ; l < r; l >>= 1, r >>= 1) {
            if (l&1) res1 = comb(res1,seg[l++]);
            if (r&1) res2 = comb(seg[--r],res2);
        }
        return comb(res1,res2);
    }
};

Seg<ll,1<<18> S;

int n,q;

int main() {
    setIO(); re(n,q);
    FOR(i,1,n+1) {
        int x; re(x);
        S.upd(i,x);
    }
    F0R(i,q) {
        int t,a,b; re(t,a,b);
        if (t == 1) {
            S.upd(a,b);
        } else {
            ps(S.query(a,b));
        }
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Range Sum Queries II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

struct Tree {
    typedef ll T;
    static constexpr T unit = 0;
    T f(T a, T b) { return a+b; } // (any associative fn)
    vector<T> s; int n;
    Tree(int n = 0, T def = unit) : s(2*n, def), n(n) {}
    void update(int pos, T val) {
        for (s[pos += n] = val; pos /= 2;)
            s[pos] = f(s[pos * 2], s[pos * 2 + 1]);
    }
    T query(int b, int e) { // query [b, e)
        T ra = unit, rb = unit;
        for (b += n, e += n; b < e; b /= 2, e /= 2) {
            if (b % 2) ra = f(ra, s[b++]);
            if (e % 2) rb = f(s[--e], rb);
        }
        return f(ra, rb);
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    Tree t(n+1);
    rep(i, 1, n+1) {
        int a;
        cin >> a;
        t.update(i, a);
    }
    while (q--) {
        int type, a, b;
        cin >> type >> a >> b;
        if (type==1) t.update(a, b);
        else cout << t.query(a, b+1) << '\n';
    }
    return 0;
}
"
Range Sum Queries II,Java,"// https://cses.fi/problemset/task/1648
// Range Sum Queries II
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1648 {
    static long[] tt;
    static void update(int i, int n, int x) {
        while (i < n) {
            tt[i] += x;
            i |= i + 1;
        }
    }
    static long query(int i) {
        long x = 0;
        while (i >= 0) {
            x += tt[i];
            i &= i + 1;
            i--;
        }
        return x;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int q = Integer.parseInt(st.nextToken());
        int[] aa = new int[n];
        tt = new long[n];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            aa[i] = Integer.parseInt(st.nextToken());
            update(i, n, aa[i]);
        }
        while (q-- > 0) {
            st = new StringTokenizer(br.readLine());
            int t = Integer.parseInt(st.nextToken());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            if (t == 1) {
                int i = a - 1;
                update(i, n, b - aa[i]);
                aa[i] = b;
            } else
                pw.println(query(b - 1) - query(a - 2));
        }
        pw.close();
    }
}
"
Range Sum Queries II,Java,"// https://cses.fi/problemset/task/1648
// Range Sum Queries II
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1648 {
    static long[] tt;
    static void update(int i, int n, int x) {
        while (i < n) {
            tt[i] += x;
            i |= i + 1;
        }
    }
    static long query(int i) {
        long x = 0;
        while (i >= 0) {
            x += tt[i];
            i &= i + 1;
            i--;
        }
        return x;
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int q = sc.nextInt();
        int[] aa = new int[n];
        tt = new long[n];
        for (int i = 0; i < n; i++) {
            aa[i] = sc.nextInt();
            update(i, n, aa[i]);
        }
        while (q-- > 0) {
            int t = sc.nextInt();
            int a = sc.nextInt();
            int b = sc.nextInt();
            if (t == 1) {
                int i = a - 1;
                update(i, n, b - aa[i]);
                aa[i] = b;
            } else
                pw.println(query(b - 1) - query(a - 2));
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Range Sum Queries II,C++,"/*
 https://cses.fi/problemset/task/1648
 Range Sum Queries II
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000

long long tt[N];

void update(int i, int n, int a) {
    while (i < n) {
        tt[i] += a;
        i |= i + 1;
    }
}

long long query(int i) {
    long long sum = 0;
    
    while (i >= 0) {
        sum += tt[i];
        i &= i + 1;
        i--;
    }
    return sum;
}

int main() {
    static int aa[N];
    int n, q, i, j, a;
    
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++) {
        scanf(""%d"", &aa[i]);
        update(i, n, aa[i]);
    }
    while (q--) {
        int t;
        
        scanf(""%d"", &t);
        if (t == 1) {
            scanf(""%d%d"", &i, &a), i--;
            update(i, n, a - aa[i]);
            aa[i] = a;
        } else {
            scanf(""%d%d"", &i, &j), i--, j--;
            printf(""%lld\n"", query(j) - query(i - 1));
        }
    }
    return 0;
}
"
Range Update Queries,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<class T, int SZ> struct Seg { // SZ should be power of 2
    T seg[2*SZ], ID = 0;
    
    Seg() { memset(seg,0,sizeof seg); }
    T comb(T a, T b) { return a+b; }
    // easily change this to min or max
    // comb(ID,b) must equal b
    
    void build() { F0Rd(i,SZ) seg[i] = comb(seg[2*i],seg[2*i+1]); }
    
    void upd(int p, T value) {  // set value at position p
        for (seg[p += SZ] += value; p > 1; p >>= 1)
            seg[p>>1] = comb(seg[(p|1)^1],seg[p|1]);
        // make sure non-commutative operations work
    }
    
    T query(int l, int r) {  // sum on interval [l, r]
        T res1 = ID, res2 = ID; r++;
        for (l += SZ, r += SZ; l < r; l >>= 1, r >>= 1) {
            if (l&1) res1 = comb(res1,seg[l++]);
            if (r&1) res2 = comb(seg[--r],res2);
        }
        return comb(res1,res2);
    }
};

Seg<ll,1<<18> S;

int n,q,a[MX];

int main() {
    setIO(); re(n,q);
    FOR(i,1,n+1) re(a[i]);
    F0R(i,q) {
        int t; re(t);
        if (t == 1) {
            int a,b,u; re(a,b,u);
            S.upd(a,u); S.upd(b+1,-u);
        } else {
            int k; re(k);
            ps(a[k]+S.query(1,k));
        }
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Range Update Queries,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

struct FT {
    vector<ll> s;
    FT(int n) : s(n) {}
    void update(int pos, ll dif) { // a[pos] += dif
        for (; pos < sz(s); pos |= pos + 1) s[pos] += dif;
    }
    ll query(int pos) { // sum of values in [0, pos)
        ll res = 0;
        for (; pos > 0; pos &= pos - 1) res += s[pos-1];
        return res;
    }
    int lower_bound(ll sum) {// min pos st sum of [0, pos] >= sum
        // Returns n if no sum is >= sum, or -1 if empty sum is.
        if (sum <= 0) return -1;
        int pos = 0;
        for (int pw = 1 << 25; pw; pw >>= 1) {
            if (pos + pw <= sz(s) && s[pos + pw-1] < sum)
                pos += pw, sum -= s[pos-1];
        }
        return pos;
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    vi x(n+1);
    rep(i, 1, n+1) cin >> x[i];
    FT t(n+1);
    rep(i, 1, n+1) t.update(i, x[i]-x[i-1]);
    while (q--) {
        int type;
        cin >> type;
        if (type==1) {
            int a, b, c;
            cin >> a >> b >> c;
            t.update(a, c);
            t.update(b+1, -c);
        }
        else {
            int k;
            cin >> k;
            cout << t.query(k+1) << '\n';
        }
    }
    return 0;
}
"
Range Update Queries,Java,"// https://cses.fi/problemset/task/1651
// Range Update Queries
// practice with rainboy
import java.io.*;

public class CSES1651 {
    static long[] tt;
    static void update(int i, int n, int a) {
        while (i < n) {
            tt[i] += a;
            i |= i + 1;
        }
    }
    static long query(int i) {
        long a = 0;
        while (i >= 0) {
            a += tt[i];
            i &= i + 1;
            i--;
        }
        return a;
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int q = sc.nextInt();
        tt = new long[n];
        for (int i = 0; i < n; i++) {
            int a = sc.nextInt();
            update(i, n, a);
            update(i + 1, n, -a);
        }
        while (q-- > 0) {
            int t = sc.nextInt();
            if (t == 1) {
                int l = sc.nextInt() - 1;
                int r = sc.nextInt() - 1;
                int a = sc.nextInt();
                update(l, n, a);
                update(r + 1, n, -a);
            } else {
                int i = sc.nextInt() - 1;
                pw.println(query(i));
            }
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Range Update Queries,C++,"/*
 https://cses.fi/problemset/task/1651
 Range Update Queries
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000

long long tt[N];

void update(int i, int n, int x) {
    while (i < n) {
        tt[i] += x;
        i |= i + 1;
    }
}

long long query(int i) {
    long long sum = 0;
    
    while (i >= 0) {
        sum += tt[i];
        i &= i + 1;
        i--;
    }
    return sum;
}

int main() {
    int n, q, i, j, x;
    
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++) {
        scanf(""%d"", &x);
        update(i, n, x);
        update(i + 1, n, -x);
    }
    while (q--) {
        int t;
        
        scanf(""%d%d"", &t, &i), i--;
        if (t == 1) {
            scanf(""%d%d"", &j, &x);
            update(i, n, x);
            update(j, n, -x);
        } else
            printf(""%lld\n"", query(i));
    }
    return 0;
}
"
Range Updates and Sums,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<class T, int SZ> struct LazySegTree {
    T sum[2*SZ];
    pl lazy[2*SZ]; // set SZ to a power of 2
    
    LazySegTree() {
        memset (sum,0,sizeof sum);
        FOR(i,1,2*SZ) lazy[i] = {1,0};
    }
    
    void push(int ind, int L, int R) {
        sum[ind] = lazy[ind].f*sum[ind]+(R-L+1)*lazy[ind].s;
        if (L != R) {
            if (!lazy[ind].f) lazy[2*ind] = {0,0};
            lazy[2*ind].s += lazy[ind].s;
            if (!lazy[ind].f) lazy[2*ind+1] = {0,0};
            lazy[2*ind+1].s += lazy[ind].s;
        }
        lazy[ind] = {1,0};
    }
    
    void pull(int ind) {
        sum[ind] = sum[2*ind]+sum[2*ind+1];
    }
    
    void build() {
        F0Rd(i,SZ) pull(i);
    }
    
    T qsum(int lo, int hi, int ind = 1, int L = 0, int R = SZ-1) {
        push(ind,L,R);
        if (lo > R || L > hi) return 0;
        if (lo <= L && R <= hi) return sum[ind];
        
        int M = (L+R)/2;
        return qsum(lo,hi,2*ind,L,M) + qsum(lo,hi,2*ind+1,M+1,R);
    }
    
    void upd(int lo, int hi, pl inc, int ind = 1, int L = 0, int R = SZ-1) {
        push(ind,L,R);
        if (hi < L || R < lo) return;
        if (lo <= L && R <= hi) {
            lazy[ind] = inc;
            push(ind,L,R);
            return;
        }
        
        int M = (L+R)/2;
        upd(lo,hi,inc,2*ind,L,M); upd(lo,hi,inc,2*ind+1,M+1,R);
        pull(ind);
    }
};

LazySegTree<ll,1<<18> L;
int n,q;

int main() {
    setIO(); re(n,q);
    
    FOR(i,1,n+1) {
        int t; re(t);
        L.upd(i,i,{0,t});
    }
    F0R(i,q) {
        int t; re(t);
        if (t == 1) {
            int a,b,x; re(a,b,x);
            L.upd(a,b,{1,x});
        } else if (t == 2) {
            int a,b,x; re(a,b,x);
            L.upd(a,b,{0,x});
        } else {
            int a,b; re(a,b);
            ps(L.qsum(a,b));
        }
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Range Updates and Sums,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

struct Node {
    typedef ll T;
    static constexpr T unit = 0;
    static constexpr T none = 1e18;
    T f(T a, T b) { return a+b; }
    T fset(T a) { return 1LL*(hi-lo)*a; }
    T fadd(T a) { return val+1LL*(hi-lo)*a; }
    Node *l = 0, *r = 0;
    int lo, hi;
    T mset = none, madd = unit, val = unit;
    Node(int lo, int hi) :lo(lo), hi(hi) {}
    Node(vector<T>& v, int lo, int hi) : lo(lo), hi(hi) {
        if (lo + 1 < hi) {
            int mid = lo + (hi - lo)/2;
            l = new Node(v, lo, mid);
            r = new Node(v, mid, hi);
            val = f(l->val, r->val);
        }
        else val = fset(v[lo]);
    }
    T query(int L, int R) {
        if (R <= lo || hi <= L) return unit;
        if (L <= lo && hi <= R) return val;
        push();
        return f(l->query(L, R), r->query(L, R));
    }
    void set(int L, int R, T x) {
        if (R <= lo || hi <= L) return;
        if (L <= lo && hi <= R)
            mset = x, madd = unit, val = fset(x);
        else {
            push(), l->set(L, R, x), r->set(L, R, x);
            val = f(l->val, r->val);
        }
    }
    void add(int L, int R, T x) {
        if (R <= lo || hi <= L) return;
        if (L <= lo && hi <= R) {
            if (mset != none) mset = f(mset, x);
            else madd = f(madd, x);
            val = fadd(x);
        }
        else {
            push(), l->add(L, R, x), r->add(L, R, x);
            val = f(l->val, r->val);
        }
    }
    void push() {
        if (!l) {
            int mid = lo + (hi - lo)/2;
            l = new Node(lo, mid); r = new Node(mid, hi);
        }
        if (mset != none)
            l->set(lo,hi,mset), r->set(lo,hi,mset), mset = none;
        else if (madd!=unit)
            l->add(lo,hi,madd), r->add(lo,hi,madd), madd = unit;
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    vector<ll> v(n+1);
    rep(i, 1, n+1) cin >> v[i];
    Node* tr = new Node(v, 0, n+1);
    while (q--)  {
        int type;
        cin >> type;
        if (type==1) {
            int L, R, x;
            cin >> L >> R >> x;
            tr->add(L, R+1, x);
        }
        else if (type==2) {
            int L, R, x;
            cin >> L >> R >> x;
            tr->set(L, R+1, x);
        }
        else {
            int L, R;
            cin >> L >> R;
            cout << tr->query(L, R+1) << '\n';
        }
    }
    return 0;
}
"
Range Updates and Sums,Java,"// https://cses.fi/problemset/task/1735
// Range Updates and Sums
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1735 {
    static int[] aa;
    static long[] tr, inc, set;
    static void build(int k, int l, int r) {
        if (r - l == 1) {
            tr[k] = aa[l];
            return;
        }
        int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        build(k1, l, m);
        build(k2, m, r);
        tr[k] = tr[k1] + tr[k2];
    }
    static void push(int k, int l, int r) {
        int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        if (set[k] != 0) {
            update(k1, l, m, l, m, 2, set[k]);
            update(k2, m, r, m, r, 2, set[k]);
            set[k] = 0;
        } else if (inc[k] != 0) {
            update(k1, l, m, l, m, 1, inc[k]);
            update(k2, m, r, m, r, 1, inc[k]);
            inc[k] = 0;
        }
    }
    static void update(int k, int l, int r, int ql, int qr, int t, long x) {
        if (qr <= l || r <= ql)
            return;
        if (ql <= l && r <= qr) {
            if (t == 1) {
                tr[k] += (r - l) * x;
                if (set[k] == 0)
                    inc[k] += x;
                else
                    set[k] += x;
            } else {
                tr[k] = (r - l) * x;
                set[k] = x;
                inc[k] = 0;
            }
            return;
        }
        push(k, l, r);
        int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        update(k1, l, m, ql, qr, t, x);
        update(k2, m, r, ql, qr, t, x);
        tr[k] = tr[k1] + tr[k2];
    }
    static long query(int k, int l, int r, int ql, int qr) {
        if (qr <= l || r <= ql)
            return 0;
        if (ql <= l && r <= qr)
            return tr[k];
        push(k, l, r);
        int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        return query(k1, l, m, ql, qr) + query(k2, m, r, ql, qr);
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int q = sc.nextInt();
        aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = sc.nextInt();
        int n_ = 1;
        while (n_ < n)
            n_ *= 2;
        tr = new long[n_ * 2];
        inc = new long[n_ * 2];
        set = new long[n_ * 2];
        build(0, 0, n);
        while (q-- > 0) {
            int t = sc.nextInt();
            int l = sc.nextInt() - 1;
            int r = sc.nextInt();
            if (t != 3) {
                int x = sc.nextInt();
                update(0, 0, n, l, r, t, x);
            } else
                pw.println(query(0, 0, n, l, r));
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Range Updates and Sums,C++,"/*
 https://cses.fi/problemset/task/1735
 Range Updates and Sums
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define N_    (1 << 18)    /* N_ = pow2(ceil(log2(N))) */

int aa[N];
long long tr[N_ * 2], inc[N_ * 2], set[N_ * 2];

void build(int k, int l, int r) {
    int m, k1, k2;
    
    if (r - l == 1) {
        tr[k] = aa[l];
        return;
    }
    m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
    build(k1, l, m);
    build(k2, m, r);
    tr[k] = tr[k1] + tr[k2];
}

void update(int k, int l, int r, int ql, int qr, int t, long long x);

void push(int k, int l, int r) {
    int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
    
    if (set[k]) {
        update(k1, l, m, l, m, 2, set[k]);
        update(k2, m, r, m, r, 2, set[k]);
        set[k] = 0;
    } else if (inc[k]) {
        update(k1, l, m, l, m, 1, inc[k]);
        update(k2, m, r, m, r, 1, inc[k]);
        inc[k] = 0;
    }
}

void update(int k, int l, int r, int ql, int qr, int t, long long x) {
    int m, k1, k2;
    
    if (qr <= l || r <= ql)
        return;
    if (ql <= l && r <= qr) {
        if (t == 1) {
            tr[k] += (r - l) * x;
            if (set[k] == 0)
                inc[k] += x;
            else
                set[k] += x;
        } else {
            tr[k] = (r - l) * x;
            set[k] = x;
            inc[k] = 0;
        }
        return;
    }
    push(k, l, r);
    m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
    update(k1, l, m, ql, qr, t, x);
    update(k2, m, r, ql, qr, t, x);
    tr[k] = tr[k1] + tr[k2];
}

long long query(int k, int l, int r, int ql, int qr) {
    int m, k1, k2;
    
    if (qr <= l || r <= ql)
        return 0;
    if (ql <= l && r <= qr)
        return tr[k];
    push(k, l, r);
    m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
    return query(k1, l, m, ql, qr) + query(k2, m, r, ql, qr);
}

int main() {
    int n, q, i;
    
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    build(0, 0, n);
    while (q--) {
        int t, l, r, x;
        
        scanf(""%d%d%d"", &t, &l, &r), l--;
        if (t != 3) {
            scanf(""%d"", &x);
            update(0, 0, n, l, r, t, x);
        } else
            printf(""%lld\n"", query(0, 0, n, l, r));
    }
    return 0;
}
"
Range Xor Queries,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<class T, int SZ> struct Seg { // SZ should be power of 2
    T seg[2*SZ], ID = MOD;
    
    Seg() { memset(seg,0,sizeof seg); }
    T comb(T a, T b) { return a^b; }
    // easily change this to min or max
    // comb(ID,b) must equal b
    
    void build() { F0Rd(i,SZ) seg[i] = comb(seg[2*i],seg[2*i+1]); }
    
    void upd(int p, T value) {  // set value at position p
        for (seg[p += SZ] = value; p > 1; p >>= 1)
            seg[p>>1] = comb(seg[(p|1)^1],seg[p|1]);
        // make sure non-commutative operations work
    }
    
    T query(int l, int r) {  // sum on interval [l, r]
        T res1 = ID, res2 = ID; r++;
        for (l += SZ, r += SZ; l < r; l >>= 1, r >>= 1) {
            if (l&1) res1 = comb(res1,seg[l++]);
            if (r&1) res2 = comb(seg[--r],res2);
        }
        return comb(res1,res2);
    }
};

Seg<ll,1<<18> S;

int n,q;

int main() {
    setIO(); re(n,q);
    FOR(i,1,n+1) {
        int x; re(x);
        S.upd(i,x);
    }
    F0R(i,q) {
        int t=2,a,b; re(a,b);
        if (t == 1) {
            S.upd(a,b);
        } else {
            ps(S.query(a,b));
        }
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Range Xor Queries,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    vector<ll> x(n+1);
    rep(i, 1, n+1) {
        cin >> x[i];
        x[i]^=x[i-1];
    }
    while (q--) {
        int a, b;
        cin >> a >> b;
        cout << (x[b]^x[a-1]) << '\n';
    }
    return 0;
}
"
Range Xor Queries,Java,"// https://cses.fi/problemset/task/1650
// Range Xor Queries
// practice with rainboy
import java.io.*;

public class CSES1650 {
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int q = sc.nextInt();
        int[] aa = new int[n + 1];
        int a = 0;
        for (int i = 1; i <= n; i++)
            aa[i] = a ^= sc.nextInt();
        while (q-- > 0) {
            int l = sc.nextInt();
            int r = sc.nextInt();
            pw.println(aa[r] ^ aa[l - 1]);
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Range Xor Queries,C++,"/*
 https://cses.fi/problemset/task/1650
 Range Xor Queries
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000

int main() {
    static int aa[N];
    int n, q, i, j;
    
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    for (i = 1; i < n; i++)
        aa[i] ^= aa[i - 1];
    while (q--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        printf(""%d\n"", aa[j] ^ (i == 0 ? 0 : aa[i - 1]));
    }
    return 0;
}
"
Salary Queries,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int n,q, a[200001];
Tree<pii> o;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> q;
    FOR(i,1,n+1) {
        cin >> a[i];
        o.insert({a[i],i});
    }
    F0R(i,q) {
        char c; cin >> c;
        if (c == '!') {
            int x,y; cin >> x >> y;
            o.erase({a[x],x});
            a[x] = y;
            o.insert({a[x],x});
        } else {
            int x,y; cin >> x >> y;
            cout << o.order_of_key({y,MOD})-o.order_of_key({x-1,MOD}) << ""\n"";
        }
    }
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Salary Queries,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

#include <bits/extc++.h>
using namespace __gnu_pbds;

template<class T>
using Tree = tree<T, null_type, less<T>, rb_tree_tag,
tree_order_statistics_node_update>;

void example() {
    Tree<int> t, t2; t.insert(8);
    auto it = t.insert(10).first;
    assert(it == t.lower_bound(9));
    assert(t.order_of_key(10) == 1);
    assert(t.order_of_key(11) == 2);
    assert(*t.find_by_order(0) == 8);
    t.join(t2); // assuming T < T2 or T > T2, merge t2 into t
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    vi x(n+1);
    Tree<pii> t;
    rep(i, 1, n+1) {
        cin >> x[i];
        t.insert({x[i], i});
    }
    rep(i, 0, q) {
        char ch;
        int a, b;
        cin >> ch >> a >> b;
        if (ch=='!') {
            t.erase({x[a], a});
            x[a]=b;
            t.insert({x[a], a});
        }
        else {
            int L=t.order_of_key({a, 0});
            int R=t.order_of_key({b+1, 0});
            cout << R-L << '\n';
        }
    }
    return 0;
}
"
Salary Queries,C++,"// https://cses.fi/problemset/task/1144
// Salaries
// practice with rainboy
#include <algorithm>
#include <iostream>

using namespace std;

const int N = 200000, Q = N;

int pp[N + Q * 2], ii[N + Q * 2];
char cc[N];
int aa[N], bb[N];

int tt[N + Q * 2];

void update(int i, int n, int x) {
    while (i < n) {
        tt[i] += x;
        i |= i + 1;
    }
}

int query(int i) {
    int x = 0;
    while (i >= 0) {
        x += tt[i];
        i &= i + 1;
        i--;
    }
    return x;
}

int main() {
    int n, q;
    scanf(""%d%d"", &n, &q);
    for (int i = 0; i < n; i++)
        scanf(""%d"", &pp[i]);
    int k = n;
    for (int i = 0; i < q; i++) {
        char s[2];
        int a, b;
        scanf(""%s%d%d"", s, &a, &b);
        cc[i] = s[0];
        if (cc[i] == '?') {
            pp[aa[i] = k++] = a - 1;
            pp[bb[i] = k++] = b;
        } else {
            aa[i] = a - 1;
            pp[bb[i] = k++] = b;
        }
    }
    for (int h = 0; h < k; h++)
        ii[h] = h;
    sort(ii, ii + k, [] (int i, int j) { return pp[i] < pp[j]; });
    int p = 0;
    for (int h = 0; h < k; h++)
        pp[ii[h]] = h + 1 == k || pp[ii[h]] != pp[ii[h + 1]] ? p++ : p;
    for (int i = 0; i < n; i++)
        update(pp[i], p, 1);
    for (int i = 0; i < q; i++)
        if (cc[i] == '?')
            printf(""%d\n"", query(pp[bb[i]]) - query(pp[aa[i]]));
        else {
            update(pp[aa[i]], p, -1);
            update(pp[bb[i]], p, 1);
            pp[aa[i]] = pp[bb[i]];
        }
}
"
Salary Queries,C++,"/*
 https://cses.fi/problemset/task/1144
 Salaries
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>

#define N    200000
#define Q    200000
#define K    (N + Q * 2)

char cc[Q];
int aa[Q], bb[Q];
int pp[K], ii[K], tt[K];

int compare(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return pp[i] - pp[j];
}

void update(int i, int n, int x) {
    while (i < n) {
        tt[i] += x;
        i |= i + 1;
    }
}

int query(int i) {
    int x = 0;
    
    while (i >= 0) {
        x += tt[i];
        i &= i + 1;
        i--;
    }
    return x;
}

int main() {
    int n, q, k, h, i, p;
    
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++)
        scanf(""%d"", &pp[i]);
    k = n;
    for (i = 0; i < q; i++) {
        static char s[2];
        int a, b;
        
        scanf(""%s%d%d"", s, &a, &b);
        if ((cc[i] = s[0]) == '?') {
            pp[aa[i] = k++] = a - 1;
            pp[bb[i] = k++] = b;
        } else {
            aa[i] = a - 1;
            pp[bb[i] = k++] = b;
        }
    }
    for (h = 0; h < k; h++)
        ii[h] = h;
    qsort(ii, k, sizeof *ii, compare);
    p = 0;
    for (h = 0; h < k; h++)
        pp[ii[h]] = h + 1 == k || pp[ii[h]] != pp[ii[h + 1]] ? p++ : p;
    for (i = 0; i < n; i++)
        update(pp[i], p, 1);
    for (i = 0; i < q; i++)
        if (cc[i] == '?')
            printf(""%d\n"", query(pp[bb[i]]) - query(pp[aa[i]]));
        else {
            update(pp[aa[i]], p, -1);
            update(pp[bb[i]], p, 1);
            pp[aa[i]] = pp[bb[i]];
        }
    return 0;
}
"
Subarray Sum Queries,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
typedef pair<ll,ll> pll;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

class node {
public:
    ll mxSum = 0, mnSum = 0, sum = 0, ans = 0;
    node(ll _sum) {
        sum = _sum;
        mxSum = ans = max(sum,0LL);
        mnSum = min(sum,0LL);
    }
    node() {
        node(0);
    }
};

template<class T, int SZ> struct Seg {
    T seg[2*SZ], MN = node(0);
    
    Seg() {
        F0R(i,2*SZ) seg[i] = node();
    }
    
    T comb(T a, T b) {
        node c = node(0);
        c.mxSum = max(a.mxSum,a.sum+b.mxSum);
        c.mnSum = min(a.mnSum,a.sum+b.mnSum);
        c.sum = a.sum+b.sum;
        c.ans = max(max(a.ans,b.ans),a.sum-a.mnSum+b.mxSum);
        return c;
    }
    
    void upd(int p, T value) {  // set value at position p
        for (seg[p += SZ] = node(value); p > 1; p >>= 1)
            seg[p>>1] = comb(seg[(p|1)^1],seg[p|1]);
        
        
    }
    
    void build() {
        F0Rd(i,SZ) seg[i] = comb(seg[2*i],seg[2*i+1]);
    }
    
    T query(int l, int r) {  // sum on interval [l, r]
        T res1 = MN, res2 = MN; r++;
        for (l += SZ, r += SZ; l < r; l >>= 1, r >>= 1) {
            if (l&1) res1 = comb(res1,seg[l++]);
            if (r&1) res2 = comb(seg[--r],res2);
        }
        return comb(res1,res2);
    }
};

Seg<node,1<<18> S;
int n,m;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m;
    F0R(i,n) {
        int x; cin >> x;
        S.upd(i,x);
    }
    F0R(i,m) {
        int k,x; cin >> k >> x;
        S.upd(k-1,x);
        cout << S.seg[1].ans << ""\n"";
    }
}
"
Subarray Sum Queries,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr ll inf=1e10;
struct Node {
    ll l, r, m, s;
    Node(ll l, ll r, ll m, ll s)
    : l(l), r(r), m(m), s(s) {}
    Node(ll s) : l(s), r(s), m(s), s(s) {};
};
Node unit(-inf);

template<class T>
struct Tree {
    T f(T a, T b) {
        ll L=max(a.l, a.s+b.l);
        ll R=max(b.r, b.s+a.r);
        ll M=max(max(a.m, b.m), a.r+b.l);
        return Node(L, R, M, a.s+b.s);
    }
    vector<T> s; int n;
    Tree(int n = 0, T def = unit) : s(2*n, def), n(n) {}
    void update(int pos, T val) {
        for (s[pos += n] = val; pos /= 2;)
            s[pos] = f(s[pos * 2], s[pos * 2 + 1]);
    }
    T query(int b, int e) { // query [b, e)
        T ra = unit, rb = unit;
        for (b += n, e += n; b < e; b /= 2, e /= 2) {
            if (b % 2) ra = f(ra, s[b++]);
            if (e % 2) rb = f(s[--e], rb);
        }
        return f(ra, rb);
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    Tree<Node> t(n);
    rep(i, 0, n) {
        ll a;
        cin >> a;
        t.update(i, a);
    }
    rep(i, 0, q) {
        ll a, b;
        cin >> a >> b;
        t.update(a-1, Node(b));
        cout << t.query(0, n).m << '\n';
    }
    return 0;
}
"
Subarray Sum Queries,C++,"// https://cses.fi/problemset/task/1190
// Array Updates
// practice with rainboy
#include <iostream>

using namespace std;

const int N = 200000, M = 1 << 18;

int xx[N];
long long tt[M * 2], pp[M * 2], qq[M * 2], ss[M * 2];

void init(int k, int x) {
    ss[k] = x;
    tt[k] = pp[k] = qq[k] = max(x, 0);
}

void pull(int k, int k1, int k2) {
    ss[k] = ss[k1] + ss[k2];
    pp[k] = max(pp[k1], ss[k1] + pp[k2]);
    qq[k] = max(qq[k2], ss[k2] + qq[k1]);
    tt[k] = max(max(tt[k1], tt[k2]), qq[k1] + pp[k2]);
}

void build(int k, int l, int r) {
    if (r - l == 1)
        init(k, xx[l]);
    else {
        int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        build(k1, l, m);
        build(k2, m, r);
        pull(k, k1, k2);
    }
}

void update(int k, int l, int r, int i, int x) {
    if (r - l == 1)
        init(k, x);
    else {
        int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        if (i < m)
            update(k1, l, m, i, x);
        else
            update(k2, m, r, i, x);
        pull(k, k1, k2);
    }
}

int main() {
    int n, m;
    scanf(""%d%d"", &n, &m);
    for (int i = 0; i < n; i++)
        scanf(""%d"", &xx[i]);
    build(0, 0, n);
    while (m--) {
        int i, x;
        scanf(""%d%d"", &i, &x);
        i--;
        update(0, 0, n, i, x);
        printf(""%lld\n"", tt[0]);
    }
    return 0;
}
"
Subarray Sum Queries,C++,"/*
 https://cses.fi/problemset/task/1190
 Array Updates
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define M    (1 << 18)    /* M = pow2(ceil(log2(N))) */

long long max(long long a, long long b) { return a > b ? a : b; }

long long tt[M * 2], pp[M * 2], qq[M * 2], ss[M * 2];
int xx[N];

void init(int k, int x) {
    ss[k] = x;
    tt[k] = pp[k] = qq[k] = max(x, 0);
}

void pull(int k, int k1, int k2) {
    ss[k] = ss[k1] + ss[k2];
    pp[k] = max(pp[k1], ss[k1] + pp[k2]);
    qq[k] = max(qq[k2], ss[k2] + qq[k1]);
    tt[k] = max(max(tt[k1], tt[k2]), qq[k1] + pp[k2]);
}

void build(int k, int l, int r) {
    if (r - l == 1)
        init(k, xx[l]);
    else {
        int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        
        build(k1, l, m);
        build(k2, m, r);
        pull(k, k1, k2);
    }
}

void update(int k, int l, int r, int i, int x) {
    if (r - l == 1)
        init(k, x);
    else {
        int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
        
        if (i < m)
            update(k1, l, m, i, x);
        else
            update(k2, m, r, i, x);
        pull(k, k1, k2);
    }
}

int main() {
    int n, m, i;
    
    scanf(""%d%d"", &n, &m);
    for (i = 0; i < n; i++)
        scanf(""%d"", &xx[i]);
    build(0, 0, n);
    while (m--) {
        int i, x;
        
        scanf(""%d%d"", &i, &x), i--;
        update(0, 0, n, i, x);
        printf(""%lld\n"", tt[0]);
    }
    return 0;
}
"
Apartments,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

deque<int> posi;
vi todo, b;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    int n,m,k; cin >> n >> m >> k;
    F0R(i,n) {
        int x; cin >> x;
        todo.pb(x);
    }
    sort(todo.rbegin(),todo.rend());
    b.resize(m);
    F0R(i,m) cin >> b[i];
    sort(all(b));
    
    int ans = 0;
    for (int i: b) {
        while (sz(todo) && todo.back() <= i+k) {
            posi.pb(todo.back());
            todo.pop_back();
        }
        while (sz(posi) && posi.front()+k < i) posi.pop_front();
        if (sz(posi)) {
            ans ++;
            posi.pop_front();
        }
    }
    cout << ans;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Apartments,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m, k;
    cin >> n >> m >> k;
    vi a(n), b(m);
    rep(i, 0, n) cin >> a[i];
    rep(i, 0, m) cin >> b[i];
    sort(all(a));
    sort(all(b));
    int ans=0;
    for(int i=0, j=0; i<n && j<m; ) {
        if (abs(a[i]-b[j])<=k)
            ans++, i++, j++;
        else if(a[i]-k>b[j]) j++;
        else i++;
    }
    cout << ans << '\n';
    return 0;
}
"
Apartments,Java,"// https://cses.fi/problemset/task/1084
// Apartments
import java.io.*;
import java.util.*;

public class CSES1084 {
    static Random rand = new Random();
    static void shuffle(int[] aa, int n) {
        for (int i = 1; i < n; i++) {
            int j = rand.nextInt(i + 1);
            int tmp = aa[i]; aa[i] = aa[j]; aa[j] = tmp;
        }
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        int[] bb = new int[m];
        for (int j = 0; j < m; j++)
            bb[j] = Integer.parseInt(st.nextToken());
        shuffle(aa, n);
        Arrays.sort(aa);
        shuffle(bb, m);
        Arrays.sort(bb);
        int cnt = 0;
        for (int i = 0, j = 0; i < n && j < m; )
            if (aa[i] >= bb[j] - k && aa[i] <= bb[j] + k) {
                cnt++;
                i++;
                j++;
            } else if (aa[i] < bb[j] - k)
                i++;
            else
                j++;
        System.out.println(cnt);
    }
}
"
Apartments,C++,"/*
 https://cses.fi/problemset/task/1084
 Apartments
 */
#include <stdio.h>
#include <stdlib.h>

#define N    200000
#define M    200000

int compare(const void *a, const void *b) {
    int ia = *(int *) a;
    int ib = *(int *) b;
    
    return ia - ib;
}

int main() {
    static int aa[N], bb[M];
    int n, m, k, i, j, cnt;
    
    scanf(""%d%d%d"", &n, &m, &k);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    for (j = 0; j < m; j++)
        scanf(""%d"", &bb[j]);
    qsort(aa, n, sizeof *aa, compare);
    qsort(bb, m, sizeof *bb, compare);
    cnt = 0;
    for (i = 0, j = 0; i < n && j < m; i++) {
        while (j < m && bb[j] < aa[i] - k)
            j++;
        if (j < m && bb[j] <= aa[i] + k)
            j++, cnt++;
    }
    printf(""%d\n"", cnt);
    return 0;
}
"
Array Division,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int n,k,a[500000];

bool ok(ll mid) {
    int num = 0, cur = 0;
    while (num < k && cur < n) {
        ll sum = 0;
        while (cur < n && sum+a[cur] <= mid) sum += a[cur++];
        num ++;
    }
    return cur == n;
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> k;
    F0R(i,n) cin >> a[i];
    ll lo = 0, hi = 1e18;
    while (lo < hi) {
        ll mid = (lo+hi)/2;
        if (ok(mid)) hi = mid;
        else lo = mid+1;
    }
    cout << lo;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Array Division,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, k;
    cin >> n >> k;
    vi x(n);
    rep(i, 0, n) cin >> x[i];
    ll L=*max_element(all(x)), R=L*n;
    while (L<R) {
        ll M=(L+R)/2;
        ll cnt=1, s=0;
        rep(i, 0, n) {
            s+=x[i];
            if (s>M) cnt++, s=x[i];
        }
        if (cnt>k) L=M+1;
        else R=M;
    }
    cout << L << '\n';
    return 0;
}
"
Array Division,Java,"// https://cses.fi/problemset/task/1085
// Array Division
import java.io.*;
import java.util.*;

public class CSES1085 {
    static int count(int[] aa, int n, long x) {
        long a = 0;
        int k = 0;
        for (int i = 0; i < n; i++) {
            if (a + aa[i] > x) {
                a = 0;
                k++;
            }
            a += aa[i];
        }
        return k + 1;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        int[] aa = new int[n];
        int max = 0;
        long sum = 0;
        for (int i = 0; i < n; i++) {
            aa[i] = Integer.parseInt(st.nextToken());
            max = Math.max(max, aa[i]);
            sum += aa[i];
        }
        long lower = max - 1, upper = sum;
        while (upper - lower > 1) {
            long x = (lower + upper) / 2;
            if (count(aa, n, x) <= k)
                upper = x;
            else
                lower = x;
        }
        System.out.println(upper);
    }
}
"
Array Division,C++,"/*
 https://cses.fi/problemset/task/1085
 Array Division
 */
#include <stdio.h>

#define N    200000

int count(int *aa, int n, long long x) {
    long long a;
    int i, k;
    
    a = 0;
    k = 0;
    for (i = 0; i < n; i++) {
        if (a + aa[i] > x) {
            a = 0;
            k++;
        }
        a += aa[i];
    }
    return k + 1;
}

int main() {
    static int aa[N];
    int n, k, i, max;
    long long sum, lower, upper, x;
    
    scanf(""%d%d"", &n, &k);
    max = 0, sum = 0;
    for (i = 0; i < n; i++) {
        scanf(""%d"", &aa[i]);
        sum += aa[i];
        if (max < aa[i])
            max = aa[i];
    }
    lower = max - 1, upper = sum;
    while (upper - lower > 1) {
        x = (lower + upper) / 2;
        if (count(aa, n, x) <= k)
            upper = x;
        else
            lower = x;
    }
    printf(""%lld\n"", upper);
    return 0;
}
"
Concert Tickets,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int n,m;
multiset<int> z;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m;
    F0R(i,n) {
        int t; cin >> t;
        z.insert(t);
    }
    F0R(i,m) {
        int x; cin >> x;
        auto it = z.ub(x);
        if (it == z.begin()) cout << ""-1\n"";
        else {
            cout << *prev(it) << ""\n"";
            z.erase(prev(it));
        }
    }
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Concert Tickets,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    multiset<int> h;
    while (n--) {
        int a;
        cin >> a;
        h.insert(a);
    }
    while (m--) {
        int a;
        cin >> a;
        auto p=h.lower_bound(a+1);
        if (p==h.begin()) cout << ""-1\n"";
        else {
            --p;
            cout << *p << '\n';
            h.erase(p);
        }
    }
    return 0;
}
"
Concert Tickets,C++,"// https://cses.fi/problemset/task/1091/
// Concert Tickets
#include <iostream>
#include <map>

using namespace std;

int main() {
    int n, m;
    scanf(""%d%d"", &n, &m);
    map<int, int> mp;
    for (int i = 0; i < n; i++) {
        int a;
        scanf(""%d"", &a);
        mp[a]++;
    }
    while (m--) {
        int a;
        scanf(""%d"", &a);
        auto it = mp.upper_bound(a);
        if (it == mp.begin())
            printf(""-1\n"");
        else {
            it--;
            printf(""%d\n"", it->first);
            if (--it->second == 0)
                mp.erase(it);
        }
    }
    return 0;
}
"
Concert Tickets,C++,"/*
 https://cses.fi/problemset/task/1091
 Concert Tickets
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define N    200000

int compare(const void *a, const void *b) {
    int ia = *(int *) a;
    int ib = *(int *) b;
    
    return ia - ib;
}

int dsu[N], ll[N];

int find(int i) {
    return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));
}

void join(int i, int j) {
    i = find(i);
    j = find(j);
    if (i == j)
        return;
    if (dsu[i] > dsu[j]) {
        dsu[i] = j;
        ll[j] = ll[i];
    } else {
        if (dsu[i] == dsu[j])
            dsu[i]--;
        dsu[j] = i;
    }
}

int main() {
    static int aa[N];
    static char removed[N];
    int n, m, i;
    
    scanf(""%d%d"", &n, &m);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    qsort(aa, n, sizeof *aa, compare);
    for (i = 0; i < n; i++)
        ll[i] = i;
    memset(dsu, -1, sizeof dsu);
    while (m--) {
        int a, lower, upper;
        
        scanf(""%d"", &a);
        lower = -1, upper = n;
        while (upper - lower > 1) {
            i = (lower + upper) / 2;
            if (aa[i] <= a)
                lower = i;
            else
                upper = i;
        }
        if (lower == -1) {
            printf(""-1\n"");
            continue;
        }
        i = lower;
        if (i == -1) {
            printf(""-1\n"");
            continue;
        }
        if (removed[i])
            i = ll[find(i)] - 1;
        if (i == -1) {
            printf(""-1\n"");
            continue;
        }
        printf(""%d\n"", aa[i]);
        removed[i] = 1;
        if (i - 1 >= 0 && removed[i - 1])
            join(i - 1, i);
        if (i + 1 < n && removed[i + 1])
            join(i, i + 1);
    }
    return 0;
}
"
Distinct Numbers,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n;

int main() {
    setIO(); re(n); set<int> x;
    F0R(i,n) {
        int t; re(t); x.insert(t);
    }
    ps(sz(x));
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Distinct Numbers,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    set<int> x;
    while (n--) {
        int a;
        cin >> a;
        x.insert(a);
    }
    cout << sz(x) << '\n';
    return 0;
}
"
Distinct Numbers,Java,"// https://cses.fi/problemset/task/1621
// Distinct Numbers
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1621 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        Integer[] aa = new Integer[n];
        for (int i = 0; i < n; i++)
            aa[i] = Integer.parseInt(st.nextToken());
        Arrays.sort(aa);
        int cnt = 1;
        for (int i = 1; i < n; i++)
            if ((int) aa[i] != aa[i - 1])
                cnt++;
        System.out.println(cnt);
    }
}
"
Distinct Numbers,C++,"/*
 https://cses.fi/problemset/task/1621
 Distinct Numbers
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    200000

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

int compare(const void *a, const void *b) {
    int ia = *(int *) a;
    int ib = *(int *) b;
    
    return ia - ib;
}

int main() {
    static int aa[N];
    int n, i, j, tmp, cnt;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    init_rand();
    for (j = 0; j < n; j++) {
        i = rand_(j + 1);
        tmp = aa[i], aa[i] = aa[j], aa[j] = tmp;
    }
    qsort(aa, n, sizeof *aa, compare);
    cnt = 1;
    for (i = 1; i < n; i++)
        if (aa[i - 1] != aa[i])
            cnt++;
    printf(""%d\n"", cnt);
    return 0;
}
"
Factory Machines,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,t;
vi k;

bool ok(ll mid) {
    ll tot = 0;
    trav(x,k) {
        tot += mid/x;
        if (tot >= t) return 1;
    }
    return 0;
}

int main() {
    setIO(); re(n,t); k.resz(n); re(k);
    ll lo = 0, hi = 1e18;
    while (lo < hi) {
        ll mid = (lo+hi)/2;
        if (ok(mid)) hi = mid;
        else lo = mid+1;
    }
    ps(lo);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Factory Machines,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    ll n, t;
    cin >> n >> t;
    vector<ll> k(n);
    rep(i, 0, n) cin >> k[i];
    ll L=1, R=k[0]*t;
    while (L<R) {
        ll M=(L+R)/2;
        ll s=0;
        rep(i, 0, n) s+=M/k[i];
        if (s<t) L=M+1;
        else R=M;
    }
    cout << L << '\n';
    return 0;
}
"
Factory Machines,Java,"// https://cses.fi/problemset/task/1620
// Factory Machines
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1620 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = Integer.parseInt(st.nextToken());
        long lower = 0, upper = (long) 2e18;
        while (upper - lower > 1) {
            long t = (lower + upper) / 2;
            long m = 0;
            for (int i = 0; i < n; i++)
                if ((m += t / aa[i]) >= k)
                    break;
            if (m >= k)
                upper = t;
            else
                lower = t;
        }
        System.out.println(upper);
    }
}
"
Factory Machines,C++,"/*
 https://cses.fi/problemset/task/1620
 Factory Machines
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000

int main() {
    static int aa[N];
    int n, k, i;
    long long lower, upper, t, cnt;
    
    scanf(""%d%d"", &n, &k);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    lower = 0, upper = 2e18;
    while (upper - lower > 1) {
        t = (lower + upper) / 2;
        cnt = 0;
        for (i = 0; i < n; i++)
            if ((cnt += t / aa[i]) >= k)
                break;
        if (cnt >= k)
            upper = t;
        else
            lower = t;
    }
    printf(""%lld\n"", upper);
    return 0;
}
"
Ferris Wheel,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int n,x,ans;
multiset<int> p;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> x;
    F0R(i,n) {
        int a; cin >> a;
        p.insert(a);
    }
    while (sz(p)) {
        auto it = prev(p.end());
        int t = *it;
        p.erase(it);
        auto it1 = p.ub(x-t);
        if (it1 != p.begin()) p.erase(prev(it1));
        ans ++;
    }
    cout << ans;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Ferris Wheel,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, x;
    cin >> n >> x;
    vi a(n);
    rep(i, 0, n) cin >> a[i];
    multiset<int> s(all(a));
    int ans=0;
    while (sz(s)) {
        ans++;
        int a=*begin(s);
        s.erase(begin(s));
        auto p=s.upper_bound(x-a);
        if(p!=begin(s))
            s.erase(--p);
    }
    cout << ans << '\n';
    return 0;
}
"
Ferris Wheel,Java,"// https://cses.fi/problemset/task/1090
// Ferris Wheel
import java.io.*;
import java.util.*;

public class CSES1090 {
    static Random rand = new Random();
    static void shuffle(int[] aa, int n) {
        for (int i = 1; i < n; i++) {
            int j = rand.nextInt(i + 1);
            int tmp = aa[i]; aa[i] = aa[j]; aa[j] = tmp;
        }
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int x = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = Integer.parseInt(st.nextToken());
        shuffle(aa, n);
        Arrays.sort(aa);
        int ans = n;
        for (int i = 0, j = n - 1; i < j; i++) {
            while (i < j && aa[i] + aa[j] > x)
                j--;
            if (i < j) {
                j--;
                ans--;
            }
        }
        System.out.println(ans);
    }
}
"
Ferris Wheel,C++,"/*
 https://cses.fi/problemset/task/1090
 Ferris Wheel
 */
#include <stdio.h>
#include <stdlib.h>

#define N    200000

int compare(const void *a, const void *b) {
    int ia = *(int *) a;
    int ib = *(int *) b;
    
    return ia - ib;
}

int main() {
    static int pp[N];
    int n, x, i, j, ans;
    
    scanf(""%d%d"", &n, &x);
    for (i = 0; i < n; i++)
        scanf(""%d"", &pp[i]);
    qsort(pp, n, sizeof *pp, compare);
    ans = n;
    for (i = 0, j = n - 1; i < j; i++) {
        while (j > i && pp[i] + pp[j] > x)
            j--;
        if (i < j)
            j--, ans--;
    }
    printf(""%d\n"", ans);
    return 0;
}
"
Maximum Subarray Sum,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n;
vi x;

int main() {
    setIO(); re(n); x.resz(n); re(x);
    ll ans = -INF, cur = 0, mn = 0;
    trav(t,x) {
        cur += t;
        ckmax(ans,cur-mn);
        ckmin(mn,cur);
    }
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Maximum Subarray Sum,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr ll inf=1e18;
    ll n, m=0, s=0, ans=-inf;
    cin >> n;
    while (n--) {
        ll x;
        cin >> x;
        s+=x;
        ans=max(ans, s-m);
        m=min(m, s);
    }
    cout << ans << '\n';
    return 0;
}
"
Maximum Subarray Sum,Java,"// https://cses.fi/problemset/task/1643
// Maximum Subarray Sum
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1643 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = Integer.parseInt(st.nextToken());
        long max = Long.MIN_VALUE, sum = 0;
        for (int i = 0; i < n; i++) {
            sum += aa[i];
            if (max < sum)
                max = sum;
            if (sum < 0)
                sum = 0;
        }
        System.out.println(max);
    }
}
"
Maximum Subarray Sum,C++,"/*
 https://cses.fi/problemset/task/1643
 Maximum Subarray Sum
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define INF    0x3f3f3f3f

int main() {
    static int xx[N];
    int n, i;
    long long max, sum;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++)
        scanf(""%d"", &xx[i]);
    max = -INF;
    sum = 0;
    for (i = 0; i < n; i++)
        if (max < (sum = (sum > 0 ? sum : 0) + xx[i]))
            max = sum;
    printf(""%lld\n"", max);
    return 0;
}
"
Maximum Subarray Sum II,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<class T> struct MinDeque {
    int lo = 0, hi = -1;
    deque<pair<T,int>> d;
    
    void ins(T x) { // add to back
        while (sz(d) && d.back().f >= x) d.pop_back();
        d.pb({x,++hi});
    }
    
    void del() { // delete from front
        if (d.front().s == lo++) d.pop_front();
    }
    
    T get() {
        return sz(d) ? d.front().f : INF; // change based on T
    }
};

MinDeque<ll> M;
int n,a,b;

int main() {
    setIO(); re(n,a,b);
    vl v = {0};
    F0R(i,n) {
        int x; re(x);
        v.pb(v.back()+x);
    }
    ll ans = -INF;
    F0R(i,n+1) {
        if (i >= a) {
            M.ins(v[i-a]);
            if (i > b) M.del();
            ckmax(ans,v[i]-M.get());
        }
    }
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Maximum Subarray Sum II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr ll inf=1e18;

struct Tree {
    typedef ll T;
    static constexpr T unit = inf;
    T f(T a, T b) { return min(a, b); }
    vector<T> s; int n;
    Tree(int n = 0, T def = unit) : s(2*n, def), n(n) {}
    void update(int pos, T val) {
        for (s[pos += n] = val; pos /= 2;)
            s[pos] = f(s[pos * 2], s[pos * 2 + 1]);
    }
    T query(int b, int e) { // query [b, e)
        T ra = unit, rb = unit;
        for (b += n, e += n; b < e; b /= 2, e /= 2) {
            if (b % 2) ra = f(ra, s[b++]);
            if (e % 2) rb = f(s[--e], rb);
        }
        return f(ra, rb);
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, a, b;
    cin >> n >> a >> b;
    vector<ll> x(n+1);
    Tree t(n+1);
    t.update(0, 0);
    rep(i, 1, n+1) {
        cin >> x[i];
        x[i]+=x[i-1];
        t.update(i, x[i]);
    }
    ll ans=-inf;
    rep(i, 1, n+1) {
        int L=max(i-b, 0);
        int R=max(i-a+1, 0);
        ans=max(ans, x[i]-t.query(L, R));
    }
    cout << ans << '\n';
    return 0;
}
"
Maximum Subarray Sum II,Java,"// https://cses.fi/problemset/task/1644
// Maximum Subarray Sum II
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1644 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int a = Integer.parseInt(st.nextToken());
        int b = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        long[] xx = new long[n + 1];
        long x = 0;
        for (int i = 1; i <= n; i++)
            xx[i] = x += Integer.parseInt(st.nextToken());
        int[] qq = new int[n];
        int head = 0, cnt = 0;
        x = (long) -3e14;
        for (int i = a; i <= n; i++) {
            while (cnt > 0 && xx[qq[head + cnt - 1]] >= xx[i - a])
                cnt--;
            qq[head + cnt++] = i - a;
            x = Math.max(x, xx[i] - xx[qq[head]]);
            if (qq[head] == i - b) {
                head++; cnt--;
            }
        }
        System.out.println(x);
    }
}
"
Maximum Subarray Sum II,C++,"/*
 https://cses.fi/problemset/task/1644
 Maximum Subarray Sum II
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000

int main() {
    static long long xx[N + 1];
    static int qq[N];
    int n, a, b, i, head, cnt;
    long long x, x_;
    
    scanf(""%d%d%d"", &n, &a, &b);
    x = 0;
    for (i = 1; i <= n; i++)
        scanf(""%lld"", &xx[i]), xx[i] = x += xx[i];
    head = cnt = 0;
    x = -3e14;
    for (i = a; i <= n; i++) {
        while (cnt && xx[qq[head + cnt - 1]] >= xx[i - a])
            cnt--;
        qq[head + cnt++] = i - a;
        if (x < (x_ = xx[i] - xx[qq[head]]))
            x = x_;
        if (qq[head] == i - b)
            head++, cnt--;
    }
    printf(""%lld\n"", x);
    return 0;
}
"
Movie Festival,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n;

int main() {
    setIO(); re(n);
    vpi v; int ans = 0, cur = 0;
    F0R(i,n) {
        int a,b; re(a,b);
        v.pb({b,a});
    }
    sort(all(v));
    trav(t,v) if (t.s >= cur) {
        ans ++;
        cur = t.f;
    }
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Movie Festival,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vector<pii> e(n);
    rep(i, 0, n) cin >> e[i].second >> e[i].first;
    sort(all(e));
    int ans=0, cur=0;
    trav(p, e) if (p.second>=cur)
        ans++, cur=p.first;
    cout << ans << '\n';
    return 0;
}
"
Movie Festival,Java,"// https://cses.fi/problemset/task/1629
// Movie Festival
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1629 {
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        int[] aa = new int[n];
        int[] bb = new int[n];
        Integer[] ii = new Integer[n];
        for (int i = 0; i < n; i++) {
            aa[i] = sc.nextInt();
            bb[i] = sc.nextInt();
            ii[i] = i;
        }
        Arrays.sort(ii, (i, j) -> bb[i] - bb[j]);
        int b = 0, k = 0;
        for (int i = 0; i < n; i++) {
            int i_ = ii[i];
            if (b <= aa[i_]) {
                b = bb[i_];
                k++;
            }
        }
        System.out.println(k);
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb); //if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Movie Festival,Java,"// https://cses.fi/problemset/task/1629
// Movie Festival
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1629 {
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        int[] aa = new int[n];
        int[] bb = new int[n];
        Integer[] ii = new Integer[n];
        for (int i = 0; i < n; i++) {
            aa[i] = sc.nextInt();
            bb[i] = sc.nextInt();
            ii[i] = i;
        }
        Arrays.sort(ii, (i, j) -> bb[i] - bb[j]);
        int b = 0, k = 0;
        for (int i = 0; i < n; i++) {
            int i_ = ii[i];
            if (b <= aa[i_]) {
                b = bb[i_];
                k++;
            }
        }
        System.out.println(k);
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Movie Festival,C++,"/*
 https://cses.fi/problemset/task/1619
 Movie Festival
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    200000

int aa[N], bb[N];

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

int compare(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return bb[i] - bb[j];
}

int main() {
    static int ii[N];
    int n, i, j, tmp, t, k;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++) {
        scanf(""%d%d"", &aa[i], &bb[i]);
        ii[i] = i;
    }
    for (j = 0; j < n; j++) {
        i = rand_(j + 1);
        tmp = ii[i], ii[i] = ii[j], ii[j] = tmp;
    }
    qsort(ii, n, sizeof *ii, compare);
    t = 0, k = 0;
    for (i = 0; i < n; i++)
        if (t <= aa[ii[i]])
            t = bb[ii[i]], k++;
    printf(""%d\n"", k);
    return 0;
}
"
Movie Festival II,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,k;
vpi v;
multiset<int> m;

int main() {
    setIO();  re(n,k); v.resz(n);
    F0R(i,n) {
        re(v[i]);
        swap(v[i].f,v[i].s);
    }
    sort(all(v));
    F0R(i,k) m.insert(0);
    int ans = 0;
    trav(t,v) {
        auto it = m.ub(t.s);
        if (it == m.begin()) continue;
        m.erase(prev(it)); m.insert(t.f); ans ++;
    }
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Movie Festival II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, k;
    cin >> n >> k;
    vector<pii> e(n);
    rep(i, 0, n) cin >> e[i].first >> e[i].second;
    sort(all(e));
    multiset<int> q;
    int ans=0;
    trav(p, e) {
        while (!q.empty() && *begin(q)<=p.first)
            q.erase(begin(q));
        if (sz(q)<k)
            ans++, q.insert(p.second);
        else if (*q.rbegin()>p.second) {
            q.erase(--end(q));
            q.insert(p.second);
        }
    }
    cout << ans << '\n';
    return 0;
}
"
Movie Festival II,Java,"// https://cses.fi/problemset/task/1632
// Movie Festival II
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1632 {
    static Random rand = new Random();
    static class V {
        V l, r;
        int key, cnt, x;
        V(int key) {
            this.key = key;
            x = rand.nextInt();
        }
    }
    static V v_, l_, r_;
    static void split(V v, int key) {
        if (v == null) {
            v_ = l_ = r_ = null;
        } else if (v.key < key) {
            split(v.r, key);
            v.r = l_; l_ = v;
        } else if (v.key > key) {
            split(v.l, key);
            v.l = r_; r_ = v;
        } else {
            v_ = v;
            l_ = v.l;
            r_ = v.r;
            v.l = v.r = null;
        }
    }
    static V merge(V l, V r) {
        if (l == null)
            return r;
        if (r == null)
            return l;
        if (l.x <= r.x) {
            l.r = merge(l.r, r);
            return l;
        } else {
            r.l = merge(l, r.l);
            return r;
        }
    }
    static V last(V v) {
        if (v != null)
            while (v.r != null)
                v = v.r;
        return v;
    }
    static void tr_add(int key) {
        split(v_, key);
        if (v_ == null)
            v_ = new V(key);
        v_.cnt++;
        v_ = merge(merge(l_, v_), r_);
    }
    static void tr_remove(int key) {
        split(v_, key);
        if (--v_.cnt == 0)
            v_ = null;
        v_ = merge(merge(l_, v_), r_);
    }
    static V tr_floor(int key) {
        split(v_, key);
        V v = v_ != null ? v_ : last(l_);
        v_ = merge(merge(l_, v_), r_);
        return v;
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int[] aa = new int[n];
        int[] bb = new int[n];
        Integer[] ii = new Integer[n];
        for (int i = 0; i < n; i++) {
            aa[i] = sc.nextInt();
            bb[i] = sc.nextInt();
            ii[i] = i;
        }
        while (k-- > 0)
            tr_add(0);
        Arrays.sort(ii, (i, j) -> bb[i] - bb[j]);
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            V v = tr_floor(aa[ii[i]]);
            if (v != null) {
                tr_remove(v.key);
                tr_add(bb[ii[i]]);
                cnt++;
            }
        }
        System.out.println(cnt);
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb); //if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Movie Festival II,Java,"// https://cses.fi/problemset/task/1632
// Movie Festival II
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1632 {
    static Random rand = new Random();
    static class V {
        V l, r;
        int key, cnt, x;
        V(int key) {
            this.key = key;
            x = rand.nextInt();
        }
    }
    static V v_, l_, r_;
    static void split(V v, int key) {
        if (v == null) {
            v_ = l_ = r_ = null;
        } else if (v.key < key) {
            split(v.r, key);
            v.r = l_; l_ = v;
        } else if (v.key > key) {
            split(v.l, key);
            v.l = r_; r_ = v;
        } else {
            v_ = v;
            l_ = v.l;
            r_ = v.r;
            v.l = v.r = null;
        }
    }
    static V merge(V l, V r) {
        if (l == null)
            return r;
        if (r == null)
            return l;
        if (l.x <= r.x) {
            l.r = merge(l.r, r);
            return l;
        } else {
            r.l = merge(l, r.l);
            return r;
        }
    }
    static V last(V v) {
        if (v != null)
            while (v.r != null)
                v = v.r;
        return v;
    }
    static void tr_add(int key) {
        split(v_, key);
        if (v_ == null)
            v_ = new V(key);
        v_.cnt++;
        v_ = merge(merge(l_, v_), r_);
    }
    static void tr_remove(int key) {
        split(v_, key);
        if (--v_.cnt == 0)
            v_ = null;
        v_ = merge(merge(l_, v_), r_);
    }
    static V tr_floor(int key) {
        split(v_, key);
        V v = v_ != null ? v_ : last(l_);
        v_ = merge(merge(l_, v_), r_);
        return v;
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int[] aa = new int[n];
        int[] bb = new int[n];
        Integer[] ii = new Integer[n];
        for (int i = 0; i < n; i++) {
            aa[i] = sc.nextInt();
            bb[i] = sc.nextInt();
            ii[i] = i;
        }
        while (k-- > 0)
            tr_add(0);
        Arrays.sort(ii, (i, j) -> bb[i] - bb[j]);
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            V v = tr_floor(aa[ii[i]]);
            if (v != null) {
                tr_remove(v.key);
                tr_add(bb[ii[i]]);
                cnt++;
            }
        }
        System.out.println(cnt);
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Movie Festival II,C++,"/*
 https://cses.fi/problemset/task/1632
 Movie Festival II
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    200000
#define MD    1000000007

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

struct V {
    struct V *l, *r;
    int key, cnt, x;
} *v_, *l_, *r_;

struct V *new_V(int key) {
    struct V *v = (struct V *) calloc(1, sizeof *v);
    
    v->key = key;
    v->x = rand_(MD);
    return v;
}

void split(struct V *v, int key) {
    if (v == NULL)
        v_ = l_ = r_ = NULL;
    else if (v->key < key) {
        split(v->r, key);
        v->r = l_; l_ = v;
    } else if (v->key > key) {
        split(v->l, key);
        v->l = r_; r_ = v;
    } else {
        v_ = v;
        l_ = v->l;
        r_ = v->r;
        v->l = v->r = NULL;
    }
}

struct V *merge(struct V *l, struct V *r) {
    if (l == NULL)
        return r;
    if (r == NULL)
        return l;
    if (l->x <= r->x) {
        l->r = merge(l->r, r);
        return l;
    } else {
        r->l = merge(l, r->l);
        return r;
    }
}

struct V *last(struct V *v) {
    if (v)
        while (v->r)
            v = v->r;
    return v;
}

void tr_add(int key) {
    split(v_, key);
    if (v_ == NULL)
        v_ = new_V(key);
    v_->cnt++;
    v_ = merge(l_, merge(v_, r_));
}

void tr_remove(int key) {
    split(v_, key);
    if (--v_->cnt == 0)
        free(v_), v_ = NULL;
    v_ = merge(l_, merge(v_, r_));
}

struct V *tr_floor(int key) {
    struct V *v;
    
    split(v_, key);
    v = v_ ? v_ : last(l_);
    v_ = merge(l_, merge(v_, r_));
    return v;
}

int aa[N], bb[N];

int compare(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return bb[i] - bb[j];
}

int main() {
    static int ii[N];
    int n, k, i, j, tmp, cnt;
    
    scanf(""%d%d"", &n, &k);
    for (i = 0; i < n; i++) {
        scanf(""%d%d"", &aa[i], &bb[i]);
        ii[i] = i;
    }
    init_rand();
    for (j = 0; j < n; j++) {
        i = rand_(j + 1);
        tmp = ii[i], ii[i] = ii[j], ii[j] = tmp;
    }
    qsort(ii, n, sizeof *ii, compare);
    while (k--)
        tr_add(0);
    cnt = 0;
    for (i = 0; i < n; i++) {
        struct V *v = tr_floor(aa[ii[i]]);
        
        if (v) {
            tr_remove(v->key);
            tr_add(bb[ii[i]]);
            cnt++;
        }
    }
    printf(""%d\n"", cnt);
    return 0;
}
"
Nearest Smaller Values,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n;

int main() {
    setIO(); re(n);
    vpi v; v.pb({0,0});
    FOR(i,1,n+1) {
        int x; re(x);
        while (sz(v) && v.back().f >= x) v.pop_back();
        pr(v.back().s,' ');
        v.pb({x,i});
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Nearest Smaller Values,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >>n;
    vector<pii> s{{0, 0}};
    rep(i, 1, n+1) {
        int a;
        cin >> a;
        while (s.back().first>=a)
            s.pop_back();
        cout << s.back().second << "" \n""[i==n];
        s.push_back({a, i});
    }
    return 0;
}
"
Nearest Smaller Values,Java,"// https://cses.fi/problemset/task/1645
// Nearest Smaller Values
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1645 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] aa = new int[n + 1];
        for (int i = 1; i <= n; i++)
            aa[i] = Integer.parseInt(st.nextToken());
        int[] stack = new int[n + 1];
        int cnt = 0;
        stack[cnt++] = 0;
        for (int i = 1; i <= n; i++) {
            int h = 0;
            while (aa[h = stack[cnt - 1]] >= aa[i])
                cnt--;
            pw.print(h + "" "");
            stack[cnt++] = i;
        }
        pw.println();
        pw.close();
    }
}
"
Nearest Smaller Values,Java,"// https://cses.fi/problemset/task/1645
// Nearest Smaller Values
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1645 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] aa = new int[n + 1];
        aa[0] = 0x80000000;
        for (int i = 1; i <= n; i++)
            aa[i] = Integer.parseInt(st.nextToken());
        int[] stack = new int[n + 1];
        int cnt = 0;
        stack[cnt++] = 0;
        for (int i = 1; i <= n; i++) {
            int h = 0;
            while (aa[h = stack[cnt - 1]] >= aa[i])
                cnt--;
            pw.print(h + "" "");
            stack[cnt++] = i;
        }
        pw.println();
        pw.close();
    }
}
"
Nearest Smaller Values,C++,"/*
 https://cses.fi/problemset/task/1645
 Nearest Smaller Values
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000

int main() {
    static int aa[N + 1], stack[N + 1];
    int n, h, i, cnt;
    
    scanf(""%d"", &n);
    for (i = 1; i <= n; i++)
        scanf(""%d"", &aa[i]);
    cnt = 0;
    stack[cnt++] = 0;
    for (i = 1; i <= n; i++) {
        while (aa[h = stack[cnt - 1]] >= aa[i])
            cnt--;
        printf(""%d "", h);
        stack[cnt++] = i;
    }
    printf(""\n"");
    return 0;
}
"
Nearest Smaller Values,C++,"/*
 https://cses.fi/problemset/task/1645
 Nearest Smaller Values
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000

int main() {
    static int aa[N + 1], stack[N + 1];
    int n, h, i, cnt;
    
    scanf(""%d"", &n);
    for (i = 1; i <= n; i++)
        scanf(""%d"", &aa[i]);
    aa[0] = 1 << 31;
    cnt = 0;
    stack[cnt++] = 0;
    for (i = 1; i <= n; i++) {
        while (aa[h = stack[cnt - 1]] >= aa[i])
            cnt--;
        printf(""%d "", h);
        stack[cnt++] = i;
    }
    printf(""\n"");
    return 0;
}
"
Playlist,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int n;
set<int> s;
int a[200000], ans;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    int r = -1;
    cin >> n; F0R(i,n) cin >> a[i];
    F0R(i,n) {
        while (r < n-1 && !s.count(a[r+1])) s.insert(a[++r]);
        ans = max(ans,r-i+1);
        s.erase(a[i]);
    }
    cout << ans;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Playlist,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, b=0, ans=0;
    cin >> n;
    map<int, int> last;
    rep(i, 1, n+1) {
        int a;
        cin >> a;
        b=max(b, last[a]);
        ans=max(ans, i-b);
        last[a]=i;
    }
    cout << ans << '\n';
    return 0;
}
"
Playlist,Java,"// https://cses.fi/problemset/task/1141
// Playlist
import java.io.*;
import java.util.*;

public class CSES1141 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = Integer.parseInt(st.nextToken());
        Integer[] ii = new Integer[n];
        for (int i = 0; i < n; i++)
            ii[i] = i;
        Arrays.sort(ii, (i, j) -> aa[i] - aa[j] != 0 ? aa[i] - aa[j] : i - j);
        int[] pp = new int[n];
        Arrays.fill(pp, -1);
        for (int i = 1; i < n; i++)
            if (aa[ii[i]] == aa[ii[i - 1]])
                pp[ii[i]] = ii[i - 1];
        int p = -1, ans = 0;
        for (int i = 0; i < n; i++) {
            if (pp[i] != -1)
                p = Math.max(p, pp[i]);
            ans = Math.max(ans, i - p);
        }
        System.out.println(ans);
    }
}
"
Playlist,C++,"/*
 https://cses.fi/problemset/task/1141
 Playlist
 */
#include <stdio.h>
#include <stdlib.h>

#define N    200000

int aa[N];

int compare(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return aa[i] != aa[j] ? aa[i] - aa[j] : i - j;
}

int main() {
    static int ii[N], pp[N];
    int n, i, p, ans;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++) {
        scanf(""%d"", &aa[i]);
        ii[i] = i;
    }
    qsort(ii, n, sizeof *ii, compare);
    for (i = 0; i < n; i++)
        pp[ii[i]] = aa[ii[i - 1]] == aa[ii[i]] ? ii[i - 1] : -1;
    p = -1;
    ans = 0;
    for (i = 0; i < n; i++) {
        if (p < pp[i])
            p = pp[i];
        if (ans < i - p)
            ans = i - p;
    }
    printf(""%d\n"", ans);
    return 0;
}
"
Reading Books,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n;

int main() {
    setIO(); re(n);
    vi v(n); re(v); sort(all(v));
    ll ans = 2*v.back(), sum = 0; trav(t,v) sum += t;
    ps(max(ans,sum));
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Reading Books,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vector<ll> t(n);
    rep(i, 0, n) cin >> t[i];
    ll s=accumulate(all(t), 0LL);
    ll m=*max_element(all(t));
    cout << max(s, 2*m) << '\n';
    return 0;
}
"
Reading Books,Java,"// https://cses.fi/problemset/task/1631
// Reading Books
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1631 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        long sum = 0, max = 0;
        for (int i = 0; i < n; i++) {
            int a = Integer.parseInt(st.nextToken());
            if (max < a)
                max = a;
            sum += a;
        }
        System.out.println(Math.max(max + max, sum));
    }
}
"
Reading Books,C++,"/*
 https://cses.fi/problemset/task/1631
 Reading Books
 practice with Dukkha
 */
#include <stdio.h>

int main() {
    int n;
    long long sum, max;
    
    scanf(""%d"", &n);
    sum = max = 0;
    while (n--) {
        int t;
        
        scanf(""%d"", &t);
        sum += t;
        if (max < t)
            max = t;
    }
    printf(""%lld\n"", max <= sum - max ? sum : max * 2);
    return 0;
}
"
Restaurant Customers,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n;

int main() {
    setIO(); re(n);
    vpi v; int ans = 0, cur = 0;
    F0R(i,n) {
        int a,b; re(a,b);
        v.pb({a,1}), v.pb({b,-1});
    }
    sort(all(v));
    trav(t,v) {
        cur += t.s;
        ckmax(ans,cur);
    }
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Restaurant Customers,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    map<int, int> t;
    while (n--) {
        int a, b;
        cin >> a >> b;
        t[a]++, t[b]--;
    }
    int cur=0, ans=0;
    trav(p, t)
    cur+=p.second, ans=max(ans, cur);
    cout << ans << '\n';
    return 0;
}
"
Restaurant Customers,Java,"// https://cses.fi/problemset/task/1619
// Restaurant Customers
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1619 {
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        Integer[] aa = new Integer[n + n];
        for (int i = 0; i < n; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            aa[i * 2 + 0] = a * 2 + 0;
            aa[i * 2 + 1] = b * 2 + 1;
        }
        Arrays.sort(aa);
        int k = 0, k_ = 0;
        for (int i = 0; i < n + n; i++)
            if ((aa[i] & 1) == 0) {
                if (k_ < ++k)
                    k_ = k;
            } else
                k--;
        System.out.println(k_);
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Restaurant Customers,C++,"/*
 https://cses.fi/problemset/task/1619
 Restaurant Customers
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    200000

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

int compare(const void *a, const void *b) {
    int ia = *(int *) a;
    int ib = *(int *) b;
    
    return ia - ib;
}

int main() {
    static int aa[N * 2];
    int n, i, j, a, b, tmp, max, k;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++) {
        scanf(""%d%d"", &a, &b);
        aa[i * 2 + 0] = a * 2 + 0;
        aa[i * 2 + 1] = b * 2 + 1;
    }
    init_rand();
    for (j = 0; j < n * 2; j++) {
        i = rand_(j + 1);
        tmp = aa[i], aa[i] = aa[j], aa[j] = tmp;
    }
    qsort(aa, n * 2, sizeof *aa, compare);
    max = k = 0;
    for (i = 0; i < n * 2; i++)
        if (max < (k += aa[i] % 2 == 0 ? 1 : -1))
            max = k;
    printf(""%d\n"", max);
    return 0;
}
"
Room Allocation,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;
const int MX = 200001;

set<pii> progress;
set<int> avail;
int n, ans[MX];
vector<array<int,3>> v;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n; v.resize(n);
    FOR(i,1,n+1)  {
        cin >> v[i-1][0] >> v[i-1][1];
        v[i-1][2] = i;
    }
    sort(all(v));
    int nex = 0;
    for (auto a: v) {
        while (sz(progress) && progress.begin()->f < a[0]) {
            avail.insert(progress.begin()->s);
            progress.erase(progress.begin());
        }
        if (sz(avail) == 0) avail.insert(++nex);
        ans[a[2]] = *avail.begin();
        progress.insert({a[1],*avail.begin()});
        avail.erase(avail.begin());
    }
    cout << nex << ""\n"";
    FOR(i,1,n+1) cout << ans[i] << "" "";
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Room Allocation,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vector<pii> e;
    rep(i, 1, n+1) {
        int a, b;
        cin >> a >> b;
        e.push_back({a, i});
        e.push_back({b+1, -i});
    }
    sort(all(e));
    int ans=0;
    vi f, r(n+1);
    trav(p, e) {
        int i=p.second;
        if(i>0) {
            if (sz(f))
                r[i]=f.back(), f.pop_back();
            else r[i]=++ans;
        }
        else {
            f.push_back(r[-i]);
        }
    }
    cout << ans << '\n';
    rep(i, 1, n+1)
    cout << r[i] << "" \n""[i==n];
    return 0;
}
"
Room Allocation,C++,"// practice with rainboy
// https://cses.fi/problemset/task/1164
// Room Allocation
#include <algorithm>
#include <iostream>

using namespace std;

const int N = 200000;

int aa[N], bb[N];

struct V {
    int i, x;
} vv[N * 2];

int main() {
    int n;
    scanf(""%d"", &n);
    for (int i = 0; i < n; i++) {
        scanf(""%d%d"", &aa[i], &bb[i]);
        bb[i]++;
    }
    for (int i = 0; i < n; i++)
        for (int lr = 0; lr <= 1; lr++) {
            V &u = vv[i * 2 + lr];
            u.i = i;
            u.x = (lr == 0 ? aa : bb)[i] * 2 + 1 - lr;
        }
    sort(vv, vv + n * 2, [] (V &u, V &v) { return u.x < v.x; });
    int *stack = aa, *cc = bb;
    int cnt = 0, k = 0;
    for (int h = 0; h < n * 2; h++) {
        V &u = vv[h];
        if (u.x % 2 == 1)
            cc[u.i] = cnt == 0 ? ++k : stack[--cnt];
        else
            stack[cnt++] = cc[u.i];
    }
    printf(""%d\n"", k);
    for (int i = 0; i < n; i++)
        printf(""%d "", cc[i]);
    printf(""\n"");
}
"
Room Allocation,C++,"/*
 practice with Dukkha
 https://cses.fi/problemset/task/1164
 Room Allocation
 */
#include <stdio.h>
#include <stdlib.h>

#define N    200000

int aa[N], bb[N], cc[N], stack[N];

struct V {
    int i, lr, x;
} vv[N * 2];

int compare(const void *a, const void *b) {
    struct V *u = (struct V *) a;
    struct V *v = (struct V *) b;
    
    return u->x - v->x;
}

int main() {
    int n, h, i, lr, k, cnt;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++)
        scanf(""%d%d"", &aa[i], &bb[i]), bb[i]++;
    for (i = 0; i < n; i++)
        for (lr = 0; lr <= 1; lr++) {
            struct V *u = &vv[i * 2 + lr];
            
            u->i = i, u->lr = lr, u->x = (lr == 0 ? aa : bb)[i] * 2 + 1 - lr;
        }
    qsort(vv, n * 2, sizeof *vv, compare);
    cnt = 0, k = 0;
    for (h = 0; h < n * 2; h++) {
        struct V *u = &vv[h];
        
        if (u->lr == 0)
            cc[u->i] = cnt == 0 ? ++k : stack[--cnt];
        else
            stack[cnt++] = cc[u->i];
    }
    printf(""%d\n"", k);
    for (i = 0; i < n; i++)
        printf(""%d "", cc[i]);
    printf(""\n"");
    return 0;
}
"
Room Allocation,C++,"/*
 https://cses.fi/problemset/task/1164
 Room Allocation
 */
#include <stdio.h>
#include <stdlib.h>

#define N    200000

int aa[N], bb[N], *stack = aa, *cc = bb;

struct V {
    int i, x;
} vv[N * 2];

int compare(const void *a, const void *b) {
    struct V *u = (struct V *) a;
    struct V *v = (struct V *) b;
    
    return u->x - v->x;
}

int main() {
    int n, h, i, lr, k, cnt;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++)
        scanf(""%d%d"", &aa[i], &bb[i]), bb[i]++;
    for (i = 0; i < n; i++)
        for (lr = 0; lr <= 1; lr++) {
            struct V *u = &vv[i * 2 + lr];
            
            u->i = i, u->x = (lr == 0 ? aa : bb)[i] * 2 + 1 - lr;
        }
    qsort(vv, n * 2, sizeof *vv, compare);
    cnt = 0, k = 0;
    for (h = 0; h < n * 2; h++) {
        struct V *u = &vv[h];
        
        if (u->x % 2 == 1)
            cc[u->i] = cnt == 0 ? ++k : stack[--cnt];
        else
            stack[cnt++] = cc[u->i];
    }
    printf(""%d\n"", k);
    for (i = 0; i < n; i++)
        printf(""%d "", cc[i]);
    printf(""\n"");
    return 0;
}
"
Sliding Cost,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

typedef pair<ll,ll> pll;

const ll INF = 1e18;

Tree<pii> T;
int n,k, hei[200000];
array<ll,3> ans = {INF,INF,INF};

template<class T, int SZ> struct BIT {
    T bit[SZ+1];
    
    BIT() { memset(bit,0,sizeof bit); }
    
    void upd(int k, T val) { // add val to index k
        for( ;k <= SZ; k += (k&-k)) bit[k] = {bit[k].f+val.f,bit[k].s+val.s};
    }
    
    T query(int k) {
        T temp = {0,0};
        for (;k > 0;k -= (k&-k)) temp = {temp.f+bit[k].f,temp.s+bit[k].s};
        return temp;
    }
    T query(int l, int r) {
        T a = query(r);
        T b = query(l-1);
        return {a.f-b.f,a.s-b.s};
    } // range query [l,r]
};

BIT<pll,200001> B;
map<int,int> m;
vi rm;

int main() {
    ios_base::sync_with_stdio(0);cin.tie(0);
    cin >> n >> k;
    F0R(i,n) {
        cin >> hei[i];
        m[hei[i]] = 0;
    }
    for (auto& a: m) {
        rm.pb(a.f);
        a.s = sz(rm);
    }
    
    int hi = -1;
    F0R(i,n-k+1) {
        while (hi < i+k-1) {
            hi ++;
            T.insert({hei[hi],hi});
            B.upd(m[hei[hi]],{hei[hi],1});
        }
        int med = T.find_by_order(k/2)->f;
        
        pll p1 = B.query(1,m[med]-1), p2 = B.query(m[med]+1,200000);
        cout << p1.s*med-p1.f+p2.f-p2.s*med << "" "";
        
        T.erase({hei[i],i});
        B.upd(m[hei[i]],{-hei[i],-1});
    }
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Sliding Cost,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

multiset<int, greater<int>> L;
multiset<int, less<int>> R;
ll SL, SR;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, k;
    cin >> n >> k;
    vi x(n);
    rep(i, 0, n) {
        cin >> x[i];
        if (x[i]<=*begin(L) )
            L.insert(x[i]), SL+=x[i];
        else
            R.insert(x[i]), SR+=x[i];
        if (i>=k) {
            auto p=L.find(x[i-k]);
            if (p!=end(L))
                L.erase(p), SL-=x[i-k];
            else
                R.erase(R.find(x[i-k])), SR-=x[i-k];
        }
        while (sz(L)>sz(R)+1) {
            int b=*begin(L);
            R.insert(b), SR+=b;
            L.erase(begin(L)), SL-=b;
        }
        while(sz(L)<sz(R)) {
            int b=*begin(R);
            L.insert(b), SL+=b;
            R.erase(begin(R)), SR-=b;
        }
        if(i>=k-1) {
            ll m=*begin(L);
            cout << m*(sz(L)-sz(R))-SL+SR << "" \n""[i==n-1];
        }
    }
    return 0;
}
"
Sliding Cost,C++,"// https://cses.fi/problemset/task/1077
// Sliding Cost
#include <algorithm>
#include <iostream>

using namespace std;

const int N = 200000, M = 524288;
int aa[N], ii[N], bb[N], cnt[M];
long long sum[M];
int i_, x_;

void update(int k, int l, int r) {
    cnt[k] += x_;
    sum[k] += x_ * bb[i_];
    if (r - l > 1) {
        int m = (l + r) / 2;
        if (i_ < m)
            update(k * 2 + 1, l, m);
        else
            update(k * 2 + 2, m, r);
    }
}

long long s;
int query(int k, int l, int r, int x) {
    if (r - l == 1) {
        s += (long long) x * bb[l];
        return l;
    }
    int m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
    if (cnt[k1] >= x)
        return query(k1, l, m, x);
    else {
        s += sum[k1];
        return query(k2, m, r, x - cnt[k1]);
    }
}

int main() {
    int n, k;
    scanf(""%d%d"", &n, &k);
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &aa[i]);
        ii[i] = i;
    }
    sort(ii, ii + n, [] (int i, int j) { return aa[i] < aa[j]; });
    int n_ = 0;
    for (int i = 0; i < n; i++) {
        if (i == 0 || aa[ii[i - 1]] != aa[ii[i]])
            bb[n_++] = aa[ii[i]];
        aa[ii[i]] = n_ - 1;
    }
    int m = 1;
    while (m < n_)
        m *= 2;
    int h = (k + 1) / 2;
    for (int i = 0; i < n; i++) {
        i_ = aa[i]; x_ = 1;
        update(0, 0, m);
        if (i >= k) {
            i_ = aa[i - k]; x_ = -1;
            update(0, 0, m);
        }
        if (i >= k - 1) {
            s = 0;
            int j = query(0, 0, m, h);
            // (h * bb[j] - s) + (sum[0] - s - (k - h) * bb[j]);
            long long ans = sum[0] - s * 2 + k % 2 * bb[j];
            printf(""%lld "", ans);
        }
    }
    printf(""\n"");
}
"
Sliding Cost,C++,"/*
 https://cses.fi/problemset/task/1077
 Sliding Cost
 */
#include <stdio.h>
#include <stdlib.h>

#define N    200000
#define M    (1 << 18)    /* M = pow2(ceil(log2(N))) */

int aa[N], bb[N], cnt[M * 2];
long long sum[M * 2];

int compare(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return aa[i] - aa[j];
}

void update(int k, int l, int r, int i, int x) {
    cnt[k] += x;
    sum[k] += x * bb[i];
    if (r - l > 1) {
        int m = (l + r) / 2;
        
        if (i < m)
            update(k * 2 + 1, l, m, i, x);
        else
            update(k * 2 + 2, m, r, i, x);
    }
}

long long s;

int query(int k, int l, int r, int x) {
    int m, k1, k2;
    
    if (r - l == 1) {
        s += (long long) x * bb[l];
        return l;
    }
    m = (l + r) / 2, k1 = k * 2 + 1, k2 = k * 2 + 2;
    if (cnt[k1] >= x)
        return query(k1, l, m, x);
    else {
        s += sum[k1];
        return query(k2, m, r, x - cnt[k1]);
    }
}

int main() {
    static int ii[N];
    int n, m, k, h, i, j;
    long long ans;
    
    scanf(""%d%d"", &n, &k);
    for (i = 0; i < n; i++) {
        scanf(""%d"", &aa[i]);
        ii[i] = i;
    }
    qsort(ii, n, sizeof *ii, compare);
    m = 0;
    for (i = 0; i < n; i++) {
        if (i == 0 || aa[ii[i - 1]] != aa[ii[i]])
            bb[m++] = aa[ii[i]];
        aa[ii[i]] = m - 1;
    }
    h = (k + 1) / 2;
    for (i = 0; i < n; i++) {
        update(0, 0, m, aa[i], 1);
        if (i >= k)
            update(0, 0, m, aa[i - k], -1);
        if (i >= k - 1) {
            s = 0;
            j = query(0, 0, m, h);
            /* (h * bb[j] - s) + (sum[0] - s - (k - h) * bb[j]) */
            ans = sum[0] - s * 2 + (long long) (h * 2 - k) * bb[j];
            printf(""%lld "", ans);
        }
    }
    printf(""\n"");
    return 0;
}
"
Sliding Median,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

Tree<pii> T;
int n,k,a[200000];

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> k;
    F0R(i,n) cin >> a[i];
    F0R(i,k) T.insert({a[i],i});
    FOR(i,k,n+1) {
        cout << T.find_by_order((k-1)/2)->f << "" "";
        
        if (i != n) {
            T.erase({a[i-k],i-k});
            T.insert({a[i],i});
        }
    }
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Sliding Median,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

#include <bits/extc++.h>
using namespace __gnu_pbds;

template<class T>
using Tree = tree<T, null_type, less<T>, rb_tree_tag,
tree_order_statistics_node_update>;

void example() {
    Tree<int> t, t2; t.insert(8);
    auto it = t.insert(10).first;
    assert(it == t.lower_bound(9));
    assert(t.order_of_key(10) == 1);
    assert(t.order_of_key(11) == 2);
    assert(*t.find_by_order(0) == 8);
    t.join(t2); // assuming T < T2 or T > T2, merge t2 into t
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    
    int n, k;
    cin >> n >> k;
    vi x(n);
    rep(i, 0, n) cin >> x[i];
    Tree<pii> t;
    rep(i, 0, n) {
        t.insert({x[i], i});
        if (i>=k) t.erase({x[i-k], i-k});
        if (i>=k-1) cout << t.find_by_order((k-1)/2)->first << "" \n""[i==n-1];
    }
    return 0;
}
"
Sliding Median,C++,"/*
 https://cses.fi/problemset/task/1076/
 Sliding Median
 */
#include <stdio.h>
#include <stdlib.h>

#define N    200000
#define M    524288    /* 2^19 */

int aa[N], bb[N], ii[N];
int tr[M];

int compare(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return aa[i] - aa[j];
}

void update(int k, int l, int r, int i, int x) {
    tr[k] += x;
    if (r - l > 1) {
        int m = (l + r) / 2;
        
        if (i < m)
            update(k * 2 + 1, l, m, i, x);
        else
            update(k * 2 + 2, m, r, i, x);
    }
}

int query(int k, int l, int r, int n) {
    int m;
    
    if (r - l == 1)
        return l;
    m = (l + r) / 2;
    if (tr[k * 2 + 1] >= n)
        return query(k * 2 + 1, l, m, n);
    else
        return query(k * 2 + 2, m, r, n - tr[k * 2 + 1]);
}

int main() {
    int n, k, i, m;
    
    scanf(""%d%d"", &n, &k);
    for (i = 0; i < n; i++) {
        scanf(""%d"", &aa[i]);
        ii[i] = i;
    }
    qsort(ii, n, sizeof *ii, compare);
    for (i = 0, m = 0; i < n; i++) {
        if (i == 0 || aa[ii[i - 1]] != aa[ii[i]])
            bb[m++] = aa[ii[i]];
        aa[ii[i]] = m - 1;
    }
    for (i = 0; i < n; i++) {
        update(0, 0, m, aa[i], 1);
        if (i >= k)
            update(0, 0, m, aa[i - k], -1);
        if (i >= k - 1)
            printf(""%d "", bb[query(0, 0, m, (k + 1) / 2)]);
    }
    printf(""\n"");
    return 0;
}
"
Sliding Median,C++,"/*
 https://cses.fi/problemset/task/1076
 Sliding Median
 */
#include <iostream>
#include <map>

using namespace std;

const int N = 200000;

map<int, int> mp1, mp2;
int n1, n2;

void balance() {
    if (n1 < n2) {
        auto it = mp2.begin();
        if (--it->second == 0)
            mp2.erase(it);
        n2--;
        mp1[it->first]++, n1++;
    } else if (n1 > n2 + 1) {
        auto it = --mp1.end();
        if (--it->second == 0)
            mp1.erase(it);
        n1--;
        mp2[it->first]++, n2++;
    }
}

int main() {
    int n, k;
    scanf(""%d%d"", &n, &k);
    static int aa[N];
    for (int i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    for (int i = 0; i < n; i++) {
        int a = aa[i];
        if (mp1.lower_bound(a) != mp1.end())
            mp1[a]++, n1++;
        else
            mp2[a]++, n2++;
        balance();
        if (i >= k) {
            a = aa[i - k];
            if (mp1.lower_bound(a) != mp1.end()) {
                if (--mp1[a] == 0)
                    mp1.erase(a);
                n1--;
            } else {
                if (--mp2[a] == 0)
                    mp2.erase(a);
                n2--;
            }
            balance();
        }
        if (i >= k - 1)
            printf(""%d "", (--mp1.end())->first);
    }
    printf(""\n"");
    return 0;
}
"
Stick Lengths,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int n;
vi p;
ll ans = 0;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n; p.resize(n);
    F0R(i,n) cin >> p[i];
    sort(all(p));
    int x = p[sz(p)/2];
    F0R(i,sz(p)) ans += abs(p[i]-x);
    cout << ans;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Stick Lengths,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vi x(n);
    rep(i, 0, n) cin >> x[i];
    sort(all(x));
    ll ans=0;
    rep(i, 0, n) ans+=abs(x[i]-x[n/2]);
    cout << ans << '\n';
    return 0;
}
"
Stick Lengths,Java,"// https://cses.fi/problemset/task/1074
// Sticks
import java.io.*;
import java.util.*;

public class CSES1074 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = Integer.parseInt(st.nextToken());
        Arrays.sort(aa);
        int a = aa[n / 2];
        long ans = 0;
        for (int i = 0; i < n; i++)
            ans += Math.abs(aa[i] - a);
        System.out.println(ans);
    }
}
"
Stick Lengths,Java,"// https://cses.fi/problemset/task/1074
// Sticks
import java.io.*;
import java.util.*;

public class CSES1074 {
    static Random rand = new Random();
    static void shuffle(int[] aa, int n) {
        for (int i = 1; i < n; i++) {
            int j = rand.nextInt(i + 1);
            int tmp = aa[i]; aa[i] = aa[j]; aa[j] = tmp;
        }
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = Integer.parseInt(st.nextToken());
        shuffle(aa, n);
        Arrays.sort(aa);
        int a = aa[n / 2];
        long ans = 0;
        for (int i = 0; i < n; i++)
            ans += Math.abs(aa[i] - a);
        System.out.println(ans);
    }
}
"
Stick Lengths,C++,"/*
 https://cses.fi/problemset/task/1074
 Sticks
 */
#include <stdio.h>
#include <stdlib.h>

#define N    200000

int compare(const void *a, const void *b) {
    int ia = *(int *) a;
    int ib = *(int *) b;
    
    return ia - ib;
}

int main() {
    static int aa[N];
    int n, i, a;
    long long ans;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    qsort(aa, n, sizeof *aa, compare);
    a = aa[n / 2];
    ans = 0;
    for (i = 0; i < n; i++)
        ans += abs(aa[i] - a);
    printf(""%lld\n"", ans);
    return 0;
}
"
Subarray Divisibility,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,x;
map<ll,int> m;
ll ans = 0;

int main() {
    setIO(); re(n); vi v(n); re(v); m[0] ++;
    ll sum = 0;
    trav(t,v) {
        sum += t; sum = (sum%n+n)%n;
        if (m.count(sum)) ans += m[sum];
        m[sum] ++;
    }
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Subarray Divisibility,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vi h(n);
    ll s=0, ans=0;
    rep(i, 0, n) {
        h[s]++;
        ll a;
        cin >> a;
        s=(s+n+a%n)%n;
        ans+=h[s];
    }
    cout << ans << '\n';
    return 0;
}
"
Subarray Divisibility,Java,"// https://cses.fi/problemset/task/1662
// Subarray Divisibility
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1662 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int[] kk = new int[n];
        kk[0] = 1;
        st = new StringTokenizer(br.readLine());
        for (int i = 0, a = 0; i < n; i++) {
            a += Integer.parseInt(st.nextToken());
            a %= n;
            if (a < 0)
                a += n;
            kk[a]++;
        }
        long ans = 0;
        for (int a = 0; a < n; a++) {
            int k = kk[a];
            ans += (long) k * (k - 1) / 2;
        }
        System.out.println(ans);
    }
}
"
Subarray Divisibility,C++,"/*
 https://cses.fi/problemset/task/1662
 Subarray Divisibility
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000

int main() {
    static int kk[N];
    int n, i, a, a_;
    long long k, ans;
    
    scanf(""%d"", &n);
    a = 0;
    kk[a]++;
    for (i = 0; i < n; i++) {
        scanf(""%d"", &a_);
        if ((a = (a + a_) % n) < 0)
            a += n;
        kk[a]++;
    }
    ans = 0;
    for (a = 0; a < n; a++) {
        k = kk[a];
        ans += k * (k - 1) / 2;
    }
    printf(""%lld\n"", ans);
    return 0;
}
"
Subarray Sums I,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,x;

int main() {
    setIO(); re(n,x);
    int r = -1; vi v(n); re(v);
    ll sum = 0;
    int ans = 0;
    F0R(i,n) {
        while (r < n-1 && sum < x) sum += v[++r];
        ans += sum == x;
        sum -= v[i];
    }
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Subarray Sums I,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    ll n, x;
    cin >> n >> x;
    map<ll, ll> h;
    ll s=0, ans=0;
    while (n--) {
        h[s]++;
        ll a;
        cin >> a;
        s+=a;
        ans+=h[s-x];
    }
    cout << ans << '\n';
    return 0;
}
"
Subarray Sums I,Java,"// https://cses.fi/problemset/task/1660
// Subarray Sums I
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1660 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int x = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        int[] aa = new int[n];
        for (int i = 0; i < n; i++)
            aa[i] = Integer.parseInt(st.nextToken());
        int cnt = 0;
        for (int i = 0, j = 0, a = 0; i < n; i++) {
            while (j < n && a < x)
                a += aa[j++];
            if (a == x)
                cnt++;
            a -= aa[i];
        }
        System.out.println(cnt);
    }
}
"
Subarray Sums I,C++,"/*
 https://cses.fi/problemset/task/1660
 Subarray Sums I
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000

int main() {
    static int aa[N];
    int n, x, i, j, a, cnt;
    
    scanf(""%d%d"", &n, &x);
    for (i = 0; i < n; i++)
        scanf(""%d"", &aa[i]);
    a = 0;
    cnt = 0;
    for (i = 0, j = 0; j < n; j++) {
        a += aa[j];
        while (a > x)
            a -= aa[i++];
        if (a == x)
            cnt++;
    }
    printf(""%d\n"", cnt);
    return 0;
}
"
Subarray Sums II,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,x;
map<ll,int> m;
ll ans = 0;

int main() {
    setIO(); re(n,x); vi v(n); re(v); m[0] ++;
    ll sum = 0;
    trav(t,v) {
        sum += t;
        if (m.count(sum-x)) ans += m[sum-x];
        m[sum] ++;
    }
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Subarray Sums II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    ll n, x;
    cin >> n >> x;
    map<ll, ll> h;
    ll s=0, ans=0;
    while (n--) {
        h[s]++;
        ll a;
        cin >> a;
        s+=a;
        ans+=h[s-x];
    }
    cout << ans << '\n';
    return 0;
}
"
Subarray Sums II,Java,"// https://cses.fi/problemset/task/1661
// Subarray Sums II
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1661 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int x = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        long[] aa = new long[n + 1];
        Integer[] ii = new Integer[n + 1];
        aa[0] = 0;
        ii[0] = 0;
        for (int i = 1; i <= n; i++) {
            aa[i] = aa[i - 1] + Long.parseLong(st.nextToken());
            ii[i] = i;
        }
        Arrays.sort(ii, (i, j) -> (long) aa[i] == aa[j] ? i - j : aa[i] < aa[j] ? -1 : 1);
        long cnt = 0;
        for (int h = 0, i = 0, j = 0; h <= n; h++) {
            long a = aa[ii[h]] + x;
            while (i <= n && (aa[ii[i]] < a || aa[ii[i]] == a && ii[i] <= ii[h]))
                i++;
            while (j <= n && aa[ii[j]] <= a)
                j++;
            cnt += j - i;
        }
        System.out.println(cnt);
    }
}
"
Subarray Sums II,C++,"/*
 https://cses.fi/problemset/task/1661
 Subarray Sums II
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    200000

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

long long aa[N + 1];

int compare(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return aa[i] == aa[j] ? i - j : aa[i] < aa[j] ? -1 : 1;
}

int main() {
    static int ii[N + 1];
    int n, x, h, i, j, tmp;
    long long cnt;
    
    scanf(""%d%d"", &n, &x);
    for (i = 1; i <= n; i++) {
        scanf(""%lld"", &aa[i]);
        aa[i] += aa[i - 1];
        ii[i] = i;
    }
    init_rand();
    for (j = 0; j < n; j++) {
        ii[j] = j;
        i = rand_(j + 1);
        tmp = ii[i], ii[i] = ii[j], ii[j] = tmp;
    }
    qsort(ii, n + 1, sizeof *ii, compare);
    cnt = 0;
    for (h = 0, i = 0, j = 0; h <= n; h++) {
        long long a = aa[ii[h]] + x;
        
        while (i <= n && (aa[ii[i]] < a || (aa[ii[i]] == a && ii[i] <= ii[h])))
            i++;
        while (j <= n && aa[ii[j]] <= a)
            j++;
        cnt += j - i;
    }
    printf(""%lld\n"", cnt);
    return 0;
}
"
Sum of Four Values,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }
    
    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM =
        chrono::steady_clock::now()
        .time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};

int n,x;
unordered_map<int,pi,custom_hash> u;

int main() {
    setIO(); re(n,x); vi a(n); re(a);
    F0Rd(i,n) {
        F0R(j,i) if (u.count(x-a[i]-a[j])) {
            ps(j+1,i+1,u[x-a[i]-a[j]].f+1,u[x-a[i]-a[j]].s+1);
            exit(0);
        }
        FOR(j,i+1,n) u[a[i]+a[j]] = {i,j};
    }
    ps(""IMPOSSIBLE"");
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Sum of Four Values,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }
    
    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM =
        chrono::steady_clock::now()
        .time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};

int n,x;
gp_hash_table<int,pi,custom_hash> u;

int main() {
    setIO(); re(n,x); vi a(n); re(a);
    F0Rd(i,n) {
        F0R(j,i) if (u.find(x-a[i]-a[j]) != u.end()) {
            ps(j+1,i+1,u[x-a[i]-a[j]].f+1,u[x-a[i]-a[j]].s+1);
            exit(0);
        }
        FOR(j,i+1,n) u[a[i]+a[j]] = {i,j};
    }
    ps(""IMPOSSIBLE"");
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Sum of Four Values,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        // http://xorshift.di.unimi.it/splitmix64.c
        return x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9; // lol is this ok
        /*
         x += 0x9e3779b97f4a7c15;
         x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
         x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
         return x ^ (x >> 31);*/
    }
    
    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM =
        chrono::steady_clock::now()
        .time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};

int n,x;
gp_hash_table<int,pi,custom_hash> u;

int main() {
    setIO(); re(n,x); vi a(n); re(a);
    F0Rd(i,n) {
        F0R(j,i) if (u.find(x-a[i]-a[j]) != u.end()) {
            ps(j+1,i+1,u[x-a[i]-a[j]].f+1,u[x-a[i]-a[j]].s+1);
            exit(0);
        }
        FOR(j,i+1,n) u[a[i]+a[j]] = {i,j};
    }
    ps(""IMPOSSIBLE"");
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Sum of Four Values,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        return x;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }
    
    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM =
        chrono::steady_clock::now()
        .time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};

int n,x;
gp_hash_table<int,pi,custom_hash> u;

int main() {
    setIO(); re(n,x); vi a(n); re(a);
    F0Rd(i,n) {
        F0R(j,i) if (u.find(x-a[i]-a[j]) != u.end()) {
            ps(j+1,i+1,u[x-a[i]-a[j]].f+1,u[x-a[i]-a[j]].s+1);
            exit(0);
        }
        FOR(j,i+1,n) u[a[i]+a[j]] = {i,j};
    }
    ps(""IMPOSSIBLE"");
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Sum of Four Values,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x;
        return x ^ (x >> 31);
    }
    
    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM =
        chrono::steady_clock::now()
        .time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};

int n,x;
gp_hash_table<int,pi,custom_hash> u;

int main() {
    setIO(); re(n,x); vi a(n); re(a);
    F0Rd(i,n) {
        F0R(j,i) if (u.find(x-a[i]-a[j]) != u.end()) {
            ps(j+1,i+1,u[x-a[i]-a[j]].f+1,u[x-a[i]-a[j]].s+1);
            exit(0);
        }
        FOR(j,i+1,n) u[a[i]+a[j]] = {i,j};
    }
    ps(""IMPOSSIBLE"");
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Sum of Four Values,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, x;
    cin >> n >> x;
    vi a(n);
    rep(i, 0, n) cin >> a[i];
    map<int, pii> R;
    rep(i, 0, n) rep(j, i+1, n)
    R[a[i]+a[j]]={i, j};
    rep(i, 0, n) rep(j, i+1, n) {
        int y=x-a[i]-a[j];
        if (y>0 && R.count(y) && R[y].first>j) {
            cout << i+1 << "" "" << j+1 << "" "";
            cout << R[y].first+1 << "" "" << R[y].second+1 << '\n';
            return 0;
        }
    }
    cout << ""IMPOSSIBLE\n"";
    return 0;
}
"
Sum of Four Values,Java,"// https://cses.fi/problemset/task/1642
// Sum of Four Values
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1642 {
    static class V {
        int a, l, r;
        V(int a, int l, int r) {
            this.a = a; this.l = l; this.r = r;
        }
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        int x = sc.nextInt();
        int[] aa = new int[n];
        Integer[] ii = new Integer[n];
        for (int i = 0; i < n; i++) {
            aa[i] = sc.nextInt();
            ii[i] = i;
        }
        Arrays.sort(ii, (i, j) -> aa[i] - aa[j]);
        int m = n * (n - 1) / 2;
        V[] vv = new V[m];
        m = 0;
        for (int i = 0; i < n; i++)
            for (int j = i + 1; j < n; j++) {
                int i_ = ii[i], j_ = ii[j];
                vv[m++] = new V(aa[i_] + aa[j_], i, j);
            }
        Arrays.sort(vv, (u, v) -> u.a != v.a ? u.a - v.a : u.l - v.l);
        for (int i = 0, j = m - 1; i < j; i++) {
            long a = vv[i].a;
            while (i < j && a + vv[j].a > x)
                j--;
            if (i < j && a + vv[j].a == x && vv[i].r < vv[j].l) {
                int il = ii[vv[i].l] + 1;
                int ir = ii[vv[i].r] + 1;
                int jl = ii[vv[j].l] + 1;
                int jr = ii[vv[j].r] + 1;
                System.out.println(il + "" "" + ir + "" "" + jl + "" "" + jr);
                return;
            }
        }
        System.out.println(""IMPOSSIBLE"");
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb); //if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Sum of Four Values,Java,"// https://cses.fi/problemset/task/1642
// Sum of Four Values
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1642 {
    static class V {
        int a, l, r;
        V(int a, int l, int r) {
            this.a = a; this.l = l; this.r = r;
        }
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        int x = sc.nextInt();
        int[] aa = new int[n];
        Integer[] ii = new Integer[n];
        for (int i = 0; i < n; i++) {
            aa[i] = sc.nextInt();
            ii[i] = i;
        }
        Arrays.sort(ii, (i, j) -> aa[i] - aa[j]);
        int m = n * (n - 1) / 2;
        V[] vv = new V[m];
        m = 0;
        for (int i = 0; i < n; i++)
            for (int j = i + 1; j < n; j++) {
                int i_ = ii[i], j_ = ii[j];
                vv[m++] = new V(aa[i_] + aa[j_], i, j);
            }
        Arrays.sort(vv, (u, v) -> u.a != v.a ? u.a - v.a : u.l - v.l);
        for (int i = 0, j = m - 1; i < j; i++) {
            long a = vv[i].a;
            while (i < j && a + vv[j].a > x)
                j--;
            if (i < j && a + vv[j].a == x && vv[i].r < vv[j].l) {
                int il = ii[vv[i].l] + 1;
                int ir = ii[vv[i].r] + 1;
                int jl = ii[vv[j].l] + 1;
                int jr = ii[vv[j].r] + 1;
                System.out.println(il + "" "" + ir + "" "" + jl + "" "" + jr);
                return;
            }
        }
        System.out.println(""IMPOSSIBLE"");
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Sum of Four Values,C++,"/*
 https://cses.fi/problemset/task/1642
 Sum of Four Values
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    1000

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

int aa[N];

struct V {
    int a, l, r;
} vv[N * (N - 1) / 2];

int compare_a(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return aa[i] - aa[j];
}

int compare_al(const void *a, const void *b) {
    struct V *u = (struct V *) a;
    struct V *v = (struct V *) b;
    
    return u->a != v->a ? u->a - v->a : u->l - v->l;
}

int main() {
    static int ii[N];
    int n, x, i, j, m;
    struct V tmp;
    long long a;
    
    scanf(""%d%d"", &n, &x);
    for (i = 0; i < n; i++) {
        scanf(""%d"", &aa[i]);
        ii[i] = i;
    }
    qsort(ii, n, sizeof *ii, compare_a);
    m = 0;
    for (i = 0; i < n; i++)
        for (j = i + 1; j < n; j++) {
            struct V *v = &vv[m++];
            
            v->a = aa[ii[i]] + aa[ii[j]], v->l = i, v->r = j;
        }
    init_rand();
    for (j = 0; j < m; j++) {
        i = rand_(j + 1);
        tmp = vv[i], vv[i] = vv[j], vv[j] = tmp;
    }
    qsort(vv, m, sizeof *vv, compare_al);
    for (i = 0, j = m - 1; i < j; i++) {
        a = vv[i].a;
        while (i < j && a + vv[j].a > x)
            j--;
        if (i < j && a + vv[j].a == x && vv[i].r < vv[j].l) {
            int il = ii[vv[i].l] + 1, ir = ii[vv[i].r] + 1;
            int jl = ii[vv[j].l] + 1, jr = ii[vv[j].r] + 1;
            
            printf(""%d %d %d %d\n"", il, ir, jl, jr);
            return 0;
        }
    }
    printf(""IMPOSSIBLE\n"");
    return 0;
}
"
Sum of Three Values,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x;
        return x ^ (x >> 31);
    }
    
    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM =
        chrono::steady_clock::now()
        .time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};

int n,x;
gp_hash_table<int,int,custom_hash> u;

int main() {
    setIO(); re(n,x); vi a(n); re(a);
    F0Rd(i,n) {
        F0R(j,i) if (u.find(x-a[i]-a[j]) != u.end()) {
            ps(j+1,i+1,u[x-a[i]-a[j]]+1);
            exit(0);
        }
        u[a[i]] = i;
    }
    ps(""IMPOSSIBLE"");
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Sum of Three Values,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n,  x;
    cin >> n >> x;
    vector<pii> a(n);
    rep(i, 0, n) {
        cin >> a[i].first;
        a[i].second=i+1;
    }
    sort(all(a));
    rep(i, 0, n) {
        int L=0, R=n-1;
        int y=x-a[i].first;
        while(L<i && R>i) {
            int z=a[L].first+a[R].first;
            if (z==y) {
                cout << a[L].second << "" "" << a[i].second << "" ""
                << a[R].second << '\n';
                return 0;
            }
            if (z<y) L++;
            else R--;
        }
    }
    cout << ""IMPOSSIBLE\n"";
    return 0;
}
"
Sum of Three Values,Java,"// https://cses.fi/problemset/task/1641
// Sum of Three Values
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1641 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int x = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        int[] aa = new int[n];
        Integer[] ii = new Integer[n];
        for (int i = 0; i < n; i++) {
            aa[i] = Integer.parseInt(st.nextToken());
            ii[i] = i;
        }
        Arrays.sort(ii, (i, j) -> aa[i] - aa[j]);
        for (int k = 2; k < n; k++)
            for (int i = 0, j = k - 1; i < j; i++) {
                long a = 0, b = aa[ii[k]];
                while (i < j && (a = aa[ii[i]] + aa[ii[j]] + b) > x)
                    j--;
                if (i < j && a == x) {
                    System.out.println((ii[i] + 1) + "" "" + (ii[j] + 1) + "" "" + (ii[k] + 1));
                    return;
                }
            }
        System.out.println(""IMPOSSIBLE"");
    }
}
"
Sum of Three Values,C++,"/*
 https://cses.fi/problemset/task/1641
 Sum of Three Values
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>

#define N    5000

int aa[N];

int compare(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return aa[i] - aa[j];
}

int main() {
    static int ii[N];
    int n, x, i, j, k;
    long long a, b;
    
    scanf(""%d%d"", &n, &x);
    for (i = 0; i < n; i++) {
        scanf(""%d"", &aa[i]);
        ii[i] = i;
    }
    qsort(ii, n, sizeof *ii, compare);
    for (k = 2; k < n; k++)
        for (i = 0, j = k - 1; i < j; i++) {
            b = aa[ii[k]];
            while (i < j && (a = aa[ii[i]] + aa[ii[j]] + b) > x)
                j--;
            if (i < j && a == x) {
                printf(""%d %d %d\n"", ii[i] + 1, ii[j] + 1, ii[k] + 1);
                return 0;
            }
        }
    printf(""IMPOSSIBLE\n"");
    return 0;
}
"
Sum of Two Values,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,x;
map<int,int> m;

int main() {
    setIO(); re(n,x); vi a(n); re(a);
    F0R(i,n) {
        if (m.count(x-a[i])) {
            ps(m[x-a[i]]+1,i+1);
            exit(0);
        }
        m[a[i]] = i;
    }
    ps(""IMPOSSIBLE"");
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Sum of Two Values,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, x;
    cin >> n >> x;
    map<int, int> f;
    rep(i, 1, n+1) {
        int a;
        cin >> a;
        if (f.count(x-a)) {
            cout << f[x-a] << "" "" << i << '\n';
            return 0;
        }
        f[a]=i;
    }
    cout << ""IMPOSSIBLE\n"";
    return 0;
}
"
Sum of Two Values,Java,"// https://cses.fi/problemset/task/1640
// Sum of Two Values
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1640 {
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        int x = sc.nextInt();
        int[] aa = new int[n];
        Integer[] ii = new Integer[n];
        for (int i = 0; i < n; i++) {
            aa[i] = sc.nextInt();
            ii[i] = i;
        }
        Arrays.sort(ii, (i, j) -> aa[i] - aa[j]);
        for (int i = 0, j = n - 1; i < j; i++) {
            int a = 0;
            while (i < j && (a = aa[ii[i]] + aa[ii[j]]) > x)
                j--;
            if (i < j && a == x) {
                System.out.println((ii[i] + 1) + "" "" + (ii[j] + 1));
                return;
            }
        }
        System.out.println(""IMPOSSIBLE"");
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb); //if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        String next() throws IOException {
            StringBuilder sb = new StringBuilder();
            for (byte b = skip(); b > 32; b = getc())
                sb.append((char) b);
            return sb.toString();
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Sum of Two Values,Java,"// https://cses.fi/problemset/task/1640
// Sum of Two Values
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1640 {
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        int x = sc.nextInt();
        int[] aa = new int[n];
        Integer[] ii = new Integer[n];
        for (int i = 0; i < n; i++) {
            aa[i] = sc.nextInt();
            ii[i] = i;
        }
        Arrays.sort(ii, (i, j) -> aa[i] - aa[j]);
        for (int i = 0, j = n - 1; i < j; i++) {
            int a = 0;
            while (i < j && (a = aa[ii[i]] + aa[ii[j]]) > x)
                j--;
            if (i < j && a == x) {
                System.out.println((ii[i] + 1) + "" "" + (ii[j] + 1));
                return;
            }
        }
        System.out.println(""IMPOSSIBLE"");
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Sum of Two Values,C++,"/*
 https://cses.fi/problemset/task/1640
 Sum of Two Values
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    200000

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

int aa[N];

int compare(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return aa[i] - aa[j];
}

int main() {
    static int ii[N];
    int n, x, i, j, tmp, sum;
    
    scanf(""%d%d"", &n, &x);
    for (i = 0; i < n; i++) {
        scanf(""%d"", &aa[i]);
        ii[i] = i;
    }
    init_rand();
    for (j = 0; j < n; j++) {
        i = rand_(j + 1);
        tmp = ii[i], ii[i] = ii[j], ii[j] = tmp;
    }
    qsort(ii, n, sizeof *ii, compare);
    for (i = 0, j = n - 1; i < j; )
        if ((sum = aa[ii[i]] + aa[ii[j]]) == x) {
            printf(""%d %d\n"", ii[i] + 1, ii[j] + 1);
            return 0;
        } else if (sum < x)
            i++;
        else
            j--;
    printf(""IMPOSSIBLE\n"");
    return 0;
}
"
Tasks and Deadlines,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n;

int main() {
    setIO();  re(n);
    vpi v;
    F0R(i,n) {
        int a,d; re(a,d);
        v.pb({a,d});
    }
    sort(all(v));
    ll ans = 0, cur = 0;
    trav(t,v) {
        cur += t.f;
        ans += t.s-cur;
    }
    ps(ans);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Tasks and Deadlines,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vector<pii> e(n);
    rep(i, 0, n) cin >> e[i].first >> e[i].second;
    sort(all(e));
    ll s=0, ans=0;
    rep(i, 0, n) {
        s+=e[i].first;
        ans+=e[i].second-s;
    }
    cout << ans << '\n';
    return 0;
}
"
Tasks and Deadlines,Java,"// https://cses.fi/problemset/task/1630
// Tasks and Deadlines
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1630 {
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        Integer[] aa = new Integer[n];
        long d = 0;
        for (int i = 0; i < n; i++) {
            aa[i] = sc.nextInt();
            d += sc.nextInt();
        }
        Arrays.sort(aa);
        long a = 0, sum = 0;
        for (int i = 0; i < n; i++)
            sum += a += aa[i];
        System.out.println(d - sum);
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb); //if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Tasks and Deadlines,Java,"// https://cses.fi/problemset/task/1630
// Tasks and Deadlines
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1630 {
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        Integer[] aa = new Integer[n];
        long d = 0;
        for (int i = 0; i < n; i++) {
            aa[i] = sc.nextInt();
            d += sc.nextInt();
        }
        Arrays.sort(aa);
        long a = 0, sum = 0;
        for (int i = 0; i < n; i++)
            sum += a += aa[i];
        System.out.println(d - sum);
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Tasks and Deadlines,C++,"/*
 https://cses.fi/problemset/task/1630
 Tasks and Deadlines
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N    200000

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int rand_(int n) {
    return (rand() * 45677LL + rand()) % n;
}

int compare(const void *a, const void *b) {
    int ia = *(int *) a;
    int ib = *(int *) b;
    
    return ia - ib;
}

int main() {
    static int aa[N];
    int n, i, j, tmp;
    long long sum;
    
    scanf(""%d"", &n);
    sum = 0;
    for (i = 0; i < n; i++) {
        int d;
        
        scanf(""%d%d"", &aa[i], &d);
        sum += d;
    }
    for (j = 0; j < n; j++) {
        i = rand_(j + 1);
        tmp = aa[i], aa[i] = aa[j], aa[j] = tmp;
    }
    qsort(aa, n, sizeof *aa, compare);
    for (i = 0; i < n; i++)
        sum -= (long long) aa[i] * (n - i);
    printf(""%lld\n"", sum);
    return 0;
}
"
Towers,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int n;
vi x;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n;
    F0R(i,n) {
        int z; cin >> z;
        int lo = 0, hi = sz(x);
        while (lo < hi) {
            int mid = (lo+hi)/2;
            if (x[mid] > z) hi = mid;
            else lo = mid+1;
        }
        if (lo == sz(x)) x.pb(z);
        else x[lo] = z;
    }
    cout << sz(x);
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Towers,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

template<class I> vi lis(vector<I> S) {
    vi prev(sz(S));
    typedef pair<I, int> p;
    vector<p> res;
    rep(i,0,sz(S)) {
        p el { S[i], i };
        //S[i]+1 for non-decreasing
        auto it = lower_bound(all(res), p { S[i]+1, 0 });
        if (it == res.end()) res.push_back(el), it = --res.end();
        *it = el;
        prev[i] = it==res.begin() ?0:(it-1)->second;
    }
    int L = sz(res), cur = res.back().second;
    vi ans(L);
    while (L--) ans[L] = cur, cur = prev[cur];
    return ans;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vi x(n);
    rep(i, 0, n) cin >> x[i];
    cout << sz(lis(x)) << '\n';
    return 0;
}
"
Towers,Java,"// https://cses.fi/problemset/task/1073
// Towers
import java.io.*;
import java.util.*;

public class CSES1073 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        TreeMap<Integer, Integer> mp = new TreeMap<>();
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            int a = Integer.parseInt(st.nextToken());
            Map.Entry<Integer, Integer> entry = mp.higherEntry(a);
            if (entry == null)
                cnt++;
            else {
                int key = entry.getKey();
                int val = entry.getValue();
                if (val == 1)
                    mp.remove(key);
                else
                    mp.put(key, val - 1);
            }
            mp.put(a, mp.getOrDefault(a, 0) + 1);
        }
        System.out.println(cnt);
    }
}
"
Towers,C++,"/*
 https://cses.fi/problemset/task/1073
 Towers
 */
#include <iostream>
#include <map>

using namespace std;

int main() {
    int n;
    scanf(""%d"", &n);
    map<int, int> mp;
    int k = 0;
    for (int i = 0; i < n; i++) {
        int a;
        scanf(""%d"", &a);
        auto it = mp.upper_bound(a);
        if (it == mp.end())
            k++;
        else if (--it->second == 0)
            mp.erase(it);
        mp[a]++;
    }
    printf(""%d\n"", k);
    return 0;
}
"
Traffic Lights,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

multiset<int> len, pos;
int n, k;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> k;
    pos.insert(0), pos.insert(n), len.insert(n);
    F0R(i,k) {
        int x; cin >> x;
        pos.insert(x); auto it = pos.find(x);
        int a = *prev(it), b = *next(it);
        len.erase(len.find(b-a));
        len.insert(x-a), len.insert(b-x);
        cout << *len.rbegin() << "" "";
    }
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Traffic Lights,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int x, n;
    cin >> x >> n;
    set<int> p{{0, x}};
    multiset<int> w{{x}};
    vi ans(n);
    rep(i, 0, n) {
        int M;
        cin >> M;
        auto z=p.lower_bound(M);
        int L=*prev(z), R=*z;
        p.insert(M);
        w.erase(w.find(R-L));
        w.insert(M-L);
        w.insert(R-M);
        ans[i]=*w.rbegin();
    }
    rep(i, 0, n)
    cout << ans[i] << "" \n""[i==n-1];
    return 0;
}
"
Traffic Lights,Java,"// practice with rainboy
// https://cses.fi/problemset/task/1163
// Traffic Lights
import java.io.*;
import java.util.*;

public class CSES1163 {
    static int[] gap, dsu;
    static int find(int i) {
        return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));
    }
    static int join(int i, int j) {
        i = find(i);
        j = find(j);
        if (i != j) {
            if (dsu[i] > dsu[j]) {
                dsu[i] = j;
                gap[j] += gap[i];
                i = j;
            } else {
                if (dsu[i] == dsu[j])
                    dsu[i]--;
                dsu[j] = i;
                gap[i] += gap[j];
            }
        }
        return gap[i];
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int x = sc.nextInt();
        int n = sc.nextInt();
        int[] pp = new int[1 + n + 1];
        pp[0] = 0;
        for (int i = 1; i <= n; i++)
            pp[i] = sc.nextInt();
        pp[n + 1] = x;
        Integer[] ii = new Integer[1 + n + 1];
        for (int i = 0; i < 1 + n + 1; i++)
            ii[i] = i;
        Arrays.sort(ii, (i, j) -> pp[i] - pp[j]);
        gap = new int[1 + n];
        for (int i = 0; i <= n; i++)
            gap[i] = pp[ii[i + 1]] - pp[ii[i]];
        dsu = new int[1 + n];
        Arrays.fill(dsu, -1);
        for (int i = 0; i < 1 + n + 1; i++)
            pp[ii[i]] = i;
        int ans = 0;
        for (int i = 0; i <= n; i++)
            ans = Math.max(ans, gap[i]);
        int[] aa = new int[n];
        aa[n - 1] = ans;
        for (int i = n; i >= 2; i--)
            aa[i - 2] = ans = Math.max(ans, join(pp[i] - 1, pp[i]));
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++)
            sb.append(aa[i] + "" "");
        System.out.println(sb);
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb); //if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        String next() throws IOException {
            StringBuilder sb = new StringBuilder();
            for (byte b = skip(); b > 32; b = getc())
                sb.append((char) b);
            return sb.toString();
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Traffic Lights,Java,"// practice with rainboy
// https://cses.fi/problemset/task/1163
// Traffic Lights
import java.io.*;
import java.util.*;

public class CSES1163 {
    static int[] gap, dsu;
    static int find(int i) {
        return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));
    }
    static int join(int i, int j) {
        i = find(i);
        j = find(j);
        if (i != j) {
            if (dsu[i] > dsu[j]) {
                dsu[i] = j;
                gap[j] += gap[i];
                i = j;
            } else {
                if (dsu[i] == dsu[j])
                    dsu[i]--;
                dsu[j] = i;
                gap[i] += gap[j];
            }
        }
        return gap[i];
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int x = sc.nextInt();
        int n = sc.nextInt();
        int[] pp = new int[1 + n + 1];
        pp[0] = 0;
        for (int i = 1; i <= n; i++)
            pp[i] = sc.nextInt();
        pp[n + 1] = x;
        Integer[] ii = new Integer[1 + n + 1];
        for (int i = 0; i < 1 + n + 1; i++)
            ii[i] = i;
        Arrays.sort(ii, (i, j) -> pp[i] - pp[j]);
        gap = new int[1 + n];
        for (int i = 0; i <= n; i++)
            gap[i] = pp[ii[i + 1]] - pp[ii[i]];
        dsu = new int[1 + n];
        Arrays.fill(dsu, -1);
        for (int i = 0; i < 1 + n + 1; i++)
            pp[ii[i]] = i;
        int ans = 0;
        for (int i = 0; i <= n; i++)
            ans = Math.max(ans, gap[i]);
        int[] aa = new int[n];
        aa[n - 1] = ans;
        for (int i = n; i >= 2; i--)
            aa[i - 2] = ans = Math.max(ans, join(pp[i] - 1, pp[i]));
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++)
            sb.append(aa[i] + "" "");
        System.out.println(sb);
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Traffic Lights,C++,"/*
 practice with Dukkha
 https://cses.fi/problemset/task/1163
 Traffic Lights
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define N    200000

int pp[1 + N + 1], ii[1 + N + 1];
int gap[1 + N], dsu[1 + N];

int max(int a, int b) {
    return a > b ? a : b;
}

int compare(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return pp[i] - pp[j];
}

int find(int i) {
    return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));
}

int join(int i, int j) {
    i = find(i);
    j = find(j);
    if (i != j) {
        if (dsu[i] > dsu[j]) {
            dsu[i] = j;
            gap[j] += gap[i];
            i = j;
        } else {
            if (dsu[i] == dsu[j])
                dsu[i]--;
            dsu[j] = i;
            gap[i] += gap[j];
        }
    }
    return gap[i];
}

int main() {
    static int aa[N];
    int n, x, i, ans;
    
    scanf(""%d%d"", &x, &n);
    pp[0] = 0;
    for (i = 1; i <= n; i++)
        scanf(""%d"", &pp[i]);
    pp[n + 1] = x;
    for (i = 0; i < 1 + n + 1; i++)
        ii[i] = i;
    qsort(ii, 1 + n + 1, sizeof *ii, compare);
    for (i = 0; i <= n; i++)
        gap[i] = pp[ii[i + 1]] - pp[ii[i]];
    memset(dsu, -1, sizeof dsu);
    for (i = 0; i < 1 + n + 1; i++)
        pp[ii[i]] = i;
    ans = 0;
    for (i = 0; i <= n; i++)
        ans = max(ans, gap[i]);
    aa[n - 1] = ans;
    for (i = n; i >= 2; i--)
        aa[i - 2] = ans = max(ans, join(pp[i] - 1, pp[i]));
    for (i = 0; i < n; i++)
        printf(""%d "", aa[i]);
    printf(""\n"");
    return 0;
}
"
Finding Borders,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

vi z(string s) {
    int N = sz(s); s += '#';
    vi ans(N); ans[0] = N; if (N == 1) return ans;
    while (s[1+ans[1]] == s[ans[1]]) ans[1] ++;
    int L = 1, R = ans[1];
    FOR(i,2,N) {
        if (i <= R) ans[i] = min(R-i+1,ans[i-L]);
        while (s[i+ans[i]] == s[ans[i]]) ans[i] ++;
        if (i+ans[i]-1 > R) L = i, R = i+ans[i]-1;
    }
    return ans;
}

vi getPrefix(string a, string b) { // find prefixes of a in b
    vi t = z(a+b), T(sz(b));
    F0R(i,sz(T)) T[i] = min(t[i+sz(a)],sz(a));
    return T;
}

string a,b;

int main() {
    setIO(); re(a);
    auto v = z(a);
    FORd(i,1,sz(a)) if (v[i] == sz(a)-i) pr(sz(a)-i,' ');
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Finding Borders,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vi Z(string S) {
    vi z(sz(S));
    int l = -1, r = -1;
    rep(i,1,sz(S)) {
        z[i] = i >= r ? 0 : min(r - i, z[i - l]);
        while (i + z[i] < sz(S) && S[i + z[i]] == S[z[i]])
            z[i]++;
        if (i + z[i] > r)
            l = i, r = i + z[i];
    }
    return z;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    string s;
    cin >> s;
    vi z=Z(s), ans;
    int n=sz(s);
    rep(i, 1, n+1) if (z[n-i]==i)
        ans.push_back(i);
    rep(i, 0, sz(ans))
    cout << ans[i] << "" \n""[i==sz(ans)-1];
    return 0;
}
"
Finding Borders,Java,"// https://cses.fi/problemset/task/1732
// Finding Borders
// practice with rainboy
import java.io.*;

public class CSES1732 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        byte[] cc = br.readLine().getBytes();
        int n = cc.length;
        int[] zz = new int[n];
        for (int i = 1, l = 0, r = 0; i < n; i++)
            if (zz[i - l] < r - i)
                zz[i] = zz[i - l];
            else {
                l = i;
                if (r < l)
                    r = l;
                while (r < n && cc[r] == cc[r - l])
                    r++;
                zz[i] = r - l;
            }
        PrintWriter pw = new PrintWriter(System.out);
        for (int i = n - 1; i > 0; i--)
            if (zz[i] == n - i)
                pw.print(zz[i] + "" "");
        pw.println();
        pw.close();
    }
}
"
Finding Borders,C++,"/*
 https://cses.fi/problemset/task/1732
 Finding Borders
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    1000000

int main() {
    static char cc[N + 1];
    static int zz[N];
    int n, i, l, r;
    
    scanf(""%s"", cc);
    n = strlen(cc);
    for (i = 1, l = r = 0; i < n; i++)
        if (zz[i - l] < r - i)
            zz[i] = zz[i - l];
        else {
            l = i;
            if (r < l)
                r = l;
            while (r < n && cc[r] == cc[r - l])
                r++;
            zz[i] = r - l;
        }
    for (i = n - 1; i > 0; i--)
        if (zz[i] == n - i)
            printf(""%d "", n - i);
    printf(""\n"");
    return 0;
}
"
Finding Periods,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

vi z(string s) {
    int N = sz(s); s += '#';
    vi ans(N); ans[0] = N; if (N == 1) return ans;
    while (s[1+ans[1]] == s[ans[1]]) ans[1] ++;
    int L = 1, R = ans[1];
    FOR(i,2,N) {
        if (i <= R) ans[i] = min(R-i+1,ans[i-L]);
        while (s[i+ans[i]] == s[ans[i]]) ans[i] ++;
        if (i+ans[i]-1 > R) L = i, R = i+ans[i]-1;
    }
    return ans;
}

vi getPrefix(string a, string b) { // find prefixes of a in b
    vi t = z(a+b), T(sz(b));
    F0R(i,sz(T)) T[i] = min(t[i+sz(a)],sz(a));
    return T;
}

string a,b;

int main() {
    setIO(); re(a);
    auto v = z(a);
    FOR(i,1,sz(a)) if (v[i] == sz(a)-i) pr(i,' ');
    pr(sz(a));
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Finding Periods,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vi Z(string S) {
    vi z(sz(S));
    int l = -1, r = -1;
    rep(i,1,sz(S)) {
        z[i] = i >= r ? 0 : min(r - i, z[i - l]);
        while (i + z[i] < sz(S) && S[i + z[i]] == S[z[i]])
            z[i]++;
        if (i + z[i] > r)
            l = i, r = i + z[i];
    }
    return z;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    string s;
    cin >> s;
    int n=sz(s);
    vi z=Z(s), ans;
    rep(i, 1, n) if (z[i]==n-i)
        ans.push_back(i);
    trav(i, ans) cout << i << "" "";
    cout << n << '\n';
    return 0;
}
"
Finding Periods,Java,"// https://cses.fi/problemset/task/1733
// Finding Periods
// practice with rainboy
import java.io.*;

public class CSES1733 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        byte[] cc = br.readLine().getBytes();
        int n = cc.length;
        int[] zz = new int[n];
        for (int i = 1, l = 0, r = 0; i < n; i++)
            if (zz[i - l] < r - i)
                zz[i] = zz[i - l];
            else {
                l = i;
                if (r < l)
                    r = l;
                while (r < n && cc[r] == cc[r - l])
                    r++;
                zz[i] = r - l;
            }
        PrintWriter pw = new PrintWriter(System.out);
        for (int i = 1; i < n; i++)
            if (zz[i] == n - i)
                pw.print(i + "" "");
        pw.println(n);
        pw.close();
    }
}
"
Finding Periods,C++,"/*
 https://cses.fi/problemset/task/1733
 Finding Periods
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    1000000

int main() {
    static char cc[N + 1];
    static int zz[N];
    int n, i, l, r;
    
    scanf(""%s"", cc);
    n = strlen(cc);
    for (i = 1, l = r = 0; i < n; i++)
        if (zz[i - l] < r - i)
            zz[i] = zz[i - l];
        else {
            l = i;
            if (r < l)
                r = l;
            while (r < n && cc[r] == cc[r - l])
                r++;
            zz[i] = r - l;
        }
    for (i = 1; i < n; i++)
        if (zz[i] == n - i)
            printf(""%d "", i);
    printf(""%d\n"", n);
    return 0;
}
"
Longest Palindrome,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

vi manacher(string s) {
    string s1 = ""@"";
    for (char c: s) s1 += c, s1 += ""#"";
    s1[s1.length()-1] = '&';
    
    vi ans(s1.length()-1);
    int lo = 0, hi = 0;
    FOR(i,1,s1.length()-1) {
        ans[i] = min(hi-i,ans[hi-i+lo]);
        while (s1[i-ans[i]-1] == s1[i+ans[i]+1]) ans[i] ++;
        if (i+ans[i] > hi) lo = i-ans[i], hi = i+ans[i];
    }
    
    ans.erase(ans.begin());
    F0R(i,sz(ans)) if ((i&1) == (ans[i]&1)) ans[i] ++; // adjust lengths
    return ans;
}

int main() {
    string s; cin >> s;
    vi t = manacher(s);
    pii ans = {-1,-1};
    F0R(i,sz(t)) ans = max(ans,{t[i],i});
    cout << s.substr((ans.s+1)/2-ans.f/2,ans.f);
}
"
Longest Palindrome,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

array<vi, 2> manacher(const string& s) {
    int n = sz(s);
    array<vi,2> p = {vi(n+1), vi(n)};
    rep(z,0,2) for (int i=0,l=0,r=0; i < n; i++) {
        int t = r-i+!z;
        if (i<r) p[z][i] = min(t, p[z][l+t]);
        int L = i-p[z][i], R = i+p[z][i]-!z;
        while (L>=1 && R+1<n && s[L-1] == s[R+1])
            p[z][i]++, L--, R++;
        if (R>r) l=L, r=R;
    }
    return p;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    string s;
    cin >> s;
    auto p=manacher(s);
    int i0=max_element(all(p[0]))-begin(p[0]);
    int i1=max_element(all(p[1]))-begin(p[1]);
    if (2*p[0][i0]>2*p[1][i1]+1)
        cout << s.substr(i0-p[0][i0], 2*p[0][i0]) << '\n';
    else
        cout << s.substr(i1-p[1][i1], 2*p[1][i1]+1) << '\n';
    return 0;
}
"
Longest Palindrome,Java,"// https://cses.fi/problemset/task/1111
// Longest Palindrome
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1111 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        char[] cc = br.readLine().toCharArray();
        int n = cc.length;
        int m = n * 2 + 1;
        char[] aa = new char[m];
        Arrays.fill(aa, '_');
        for (int i = 0; i < n; i++)
            aa[i * 2 + 1] = cc[i];
        int[] rr = new int[m];
        int o = 0, x = 1;
        rr[0] = x - o;
        for (int i = 1; i < m; i++)
            if (o + o - i >= 0 && rr[o + o - i] < x - i)
                rr[i] = rr[o + o - i];
            else {
                o = i;
                if (x < i + 1)
                    x = i + 1;
                while (x < m && o + o - x >= 0 && aa[o + o - x] == aa[x])
                    x++;
                rr[i] = x - o;
            }
        int i_ = 0;
        for (int i = 1; i < m; i++)
            if (rr[i_] < rr[i])
                i_ = i;
        int r_ = rr[i_];
        StringBuilder sb = new StringBuilder();
        for (int i = i_ - r_ + 2; i <= i_ + r_ - 2; i += 2)
            sb.append(aa[i]);
        System.out.println(sb);
    }
}
"
Longest Palindrome,C++,"/*
 https://cses.fi/problemset/task/1111
 Longest Palindrome
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    1000000
#define M    (N * 2 + 1)

int main() {
    static char cc[N + 1], aa[M + 1], s[N + 1];
    static int rr[M];
    int n, m, i, i_, o, x, r_, k;
    
    scanf(""%s"", cc);
    n = strlen(cc);
    m = n * 2 + 1;
    memset(aa, '_', m);
    for (i = 0; i < n; i++)
        aa[i * 2 + 1] = cc[i];
    o = 0, x = 1;
    rr[0] = x - o;
    for (i = 1; i < m; i++)
        if (o + o - i >= 0 && rr[o + o - i] < x - i)
            rr[i] = rr[o + o - i];
        else {
            o = i;
            if (x < i + 1)
                x = i + 1;
            while (x < m && o + o - x >= 0 && aa[o + o - x] == aa[x])
                x++;
            rr[i] = x - o;
        }
    i_ = 0;
    for (i = 1; i < m; i++)
        if (rr[i_] < rr[i])
            i_ = i;
    r_ = rr[i_];
    k = 0;
    for (i = i_ - r_ + 2; i <= i_ + r_ - 2; i += 2)
        s[k++] = aa[i];
    printf(""%s\n"", s);
    return 0;
}
"
Minimal Rotation,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;


int min_rotation(string s) {
    int a=0, N=sz(s); s += s;
    F0R(b,N) F0R(i,N) {
        if (a+i == b || s[a+i] < s[b+i]) {b += max(0, i-1); break;}
        if (s[a+i] > s[b+i]) { a = b; break; }
    }
    return a;
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    string s; cin >> s;
    int x = min_rotation(s);
    cout << s.substr(x,s.length()-x)+s.substr(0,x);
}
"
Minimal Rotation,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int min_rotation(string s) {
    int a=0, N=sz(s); s += s;
    rep(b,0,N) rep(i,0,N) {
        if (a+i == b || s[a+i] < s[b+i]) {b += max(0, i-1); break;}
        if (s[a+i] > s[b+i]) { a = b; break; }
    }
    return a;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    string s;
    cin >>  s;
    rotate(begin(s), begin(s)+min_rotation(s), end(s));
    cout << s << '\n';
    return 0;
}
"
Minimal Rotation,Java,"// https://cses.fi/problemset/task/1110
// Minimal Rotation
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1110 {
    // https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation
    static String booth(char[] bb) {
        int n = bb.length;
        bb = Arrays.copyOf(bb, n + n);
        for (int i = 0; i < n; i++)
            bb[n + i] = bb[i];
        int[] ff = new int[n + n];
        Arrays.fill(ff, -1);
        int k = 0;
        for (int j = 1; j < n + n; j++) {
            int i = ff[j - k - 1] + 1;
            while (bb[j] != bb[i + k]) {
                if (bb[j] < bb[i + k])
                    k = j - i;
                if (i == 0) {
                    i--;
                    break;
                }
                i = ff[i - 1] + 1;
            }
            ff[j - k] = i;
        }
        return new String(bb, k, n);
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        char[] cc = br.readLine().toCharArray();
        System.out.println(booth(cc));
    }
}
"
Minimal Rotation,C++,"/*
 https://cses.fi/problemset/task/1110/
 Minimal Rotation
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    1000000

/* https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation */

char bb[N + N + 1];
int ff[N + N];

char *booth() {
    int n, i, j, k;
    
    n = strlen(bb);
    for (i = 0; i < n; i++)
        bb[i + n] = bb[i];
    memset(ff, -1, sizeof ff);
    k = 0;
    for (j = 1; j < n + n; j++) {
        i = ff[j - k - 1] + 1;
        while (bb[j] != bb[i + k]) {
            if (bb[j] < bb[i + k])
                k = j - i;
            if (i == 0) {
                i--;
                break;
            }
            i = ff[i - 1] + 1;
        }
        ff[j - k] = i;
    }
    bb[n + k] = '\0';
    return bb + k;
}

int main() {
    scanf(""%s"", bb);
    printf(""%s\n"", booth());
    return 0;
}
"
Minimal Rotation,C++,"/*
 https://cses.fi/problemset/task/1110/
 Minimal Rotation
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    1000000

/* https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation */

char bb[N + N + 1];
int ff[N + N];

char *booth() {
    int n, i, j, k;
    
    n = strlen(bb);
    for (i = 0; i < n; i++)
        bb[i + n] = bb[i];
    memset(ff, -1, sizeof ff);
    k = 0;
    for (j = 1; j < n + n; j++) {
        i = ff[j - k - 1] + 1;
        while (bb[j] != bb[i + k]) {
            if (bb[j] < bb[i + k])
                k = j - i;
            if (i == 0) {
                i--;
                break;
            }
            i = ff[i - 1] + 1;
        }
        ff[j - k] = i;
    }
    bb[n + k] = '\0';
    return bb + k;
}

int main() {
    scanf(""%s"", bb);
    printf(""%s\n"", booth());
    return 0;
}
"
Required Substring,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

int n;
string s;
int nex[100][26];
array<int,101> dp;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> s;
    F0R(i,sz(s)) {
        string t = s.substr(0,i);
        F0R(j,26) {
            string T = t+char('A'+j);
            while (T != s.substr(0,sz(T))) T = T.substr(1,sz(T)-1);
            nex[i][j] = sz(T);
        }
    }
    dp[0] = 1;
    F0R(i,n) {
        array<int,101> DP = array<int,101>();
        F0R(j,sz(s)) F0R(k,26) DP[nex[j][k]] = (DP[nex[j][k]]+dp[j]) % MOD;
        DP[sz(s)] = 0;
        dp = DP;
    }
    ll ans = 1; F0R(i,n) ans = 26*ans % MOD;
    F0R(i,sz(s)) ans = (ans+MOD-dp[i]) % MOD;
    cout << ans;
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Required Substring,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

constexpr int P=1e9+7;

vi pi(const string& s) {
    vi p(sz(s));
    rep(i,1,sz(s)) {
        int g = p[i-1];
        while (g && s[i] != s[g]) g = p[g-1];
        p[i] = g + (s[i] == s[g]);
    }
    return p;
}

void add(int &x, int y) {
    x+=y;
    if (x>=P) x-=P;
}

ll modpow(ll b, ll e) {
    ll ans = 1;
    for (; e; b = b * b % P, e /= 2)
        if (e & 1) ans = ans * b % P;
    return ans;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int A=26;
    int n;
    string s;
    cin >> n >> s;
    int m=sz(s);
    vi p=pi(s);
    vector<vi> T(m, vi(A));
    rep(i, 0, m) T[i][s[0]-'A']=1;
    rep(i, 1, m) {
        for(int j=i; j>0; j=p[j-1]) {
            int &t=T[i][s[j]-'A'];
            t=max(t, j+1);
        }
    }
    vector<vi> dp(n+1, vi(m+1));
    dp[0][0]=1;
    rep(i, 0, n) rep(j, 0, m) rep(k, 0, A)
    add(dp[i+1][T[j][k]], dp[i][j]);
    int ans=0;
    rep(i, 0, m) add(ans, dp[n][i]);
    cout << (modpow(A, n)+P-ans)%P << '\n';
    return 0;
}
"
Required Substring,Java,"// https://cses.fi/problemset/task/1112
// Substrings
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1112 {
    static final int C = 26, MD = 1000000007;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        char[] cc = br.readLine().toCharArray();
        int m = cc.length;
        int[] ff = new int[m];
        ff[0] = -1;
        for (int j = 1; j < m; j++) {
            int i = ff[j - 1] + 1;
            while (cc[i] != cc[j]) {
                if (i == 0) {
                    i--;
                    break;
                }
                i = ff[i - 1] + 1;
            }
            ff[j] = i;
        }
        int[][] delta = new int[m][C];
        for (int j = 0; j < m; j++)
            for (int c = 0; c < C; c++) {
                int i = j;
                while (cc[i] != c + 'A') {
                    if (i == 0) {
                        i--;
                        break;
                    }
                    i = ff[i - 1] + 1;
                }
                delta[j][c] = i + 1;
            }
        int[][] dp = new int[n + 1][m + 1];
        dp[0][0] = 1;
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++) {
                int x = dp[i][j];
                if (x == 0)
                    continue;
                for (int c = 0; c < C; c++) {
                    int j_ = delta[j][c];
                    dp[i + 1][j_] = (dp[i + 1][j_] + x) % MD;
                }
            }
        long ans = 0, q = 1;
        for (int i = n; i >= m; i--) {
            ans = (ans + dp[i][m] * q) % MD;
            q = q * 26 % MD;
        }
        System.out.println(ans);
    }
}
"
Required Substring,C++,"/*
 https://cses.fi/problemset/task/1112
 Substrings
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    1000
#define M    100
#define C    26
#define MD    1000000007

int main() {
    static char cc[M + 1];
    static int ff[M], delta[M][C], dp[N + 1][M + 1];
    int n, m, i, j, j_, c, x;
    long long ans, q;
    
    scanf(""%d%s"", &n, cc);
    m = strlen(cc);
    ff[0] = -1;
    for (j = 1; j < m; j++) {
        i = ff[j - 1] + 1;
        while (cc[i] != cc[j]) {
            if (i == 0) {
                i--;
                break;
            }
            i = ff[i - 1] + 1;
        }
        ff[j] = i;
    }
    for (j = 0; j < m; j++)
        for (c = 0; c < C; c++) {
            i = j;
            while (cc[i] != c + 'A') {
                if (i == 0) {
                    i--;
                    break;
                }
                i = ff[i - 1] + 1;
            }
            delta[j][c] = i + 1;
        }
    dp[0][0] = 1;
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++) {
            if ((x = dp[i][j]) == 0)
                continue;
            for (c = 0; c < C; c++) {
                j_ = delta[j][c];
                dp[i + 1][j_] = (dp[i + 1][j_] + x) % MD;
            }
        }
    ans = 0;
    q = 1;
    for (i = n; i >= m; i--) {
        ans = (ans + dp[i][m] * q) % MD;
        q = q * 26 % MD;
    }
    printf(""%lld\n"", ans);
    return 0;
}
"
String Matching,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

vi z(string s) {
    int N = sz(s); s += '#';
    vi ans(N); ans[0] = N; if (N == 1) return ans;
    while (s[1+ans[1]] == s[ans[1]]) ans[1] ++;
    int L = 1, R = ans[1];
    FOR(i,2,N) {
        if (i <= R) ans[i] = min(R-i+1,ans[i-L]);
        while (s[i+ans[i]] == s[ans[i]]) ans[i] ++;
        if (i+ans[i]-1 > R) L = i, R = i+ans[i]-1;
    }
    return ans;
}

vi getPrefix(string a, string b) { // find prefixes of a in b
    vi t = z(a+b), T(sz(b));
    F0R(i,sz(T)) T[i] = min(t[i+sz(a)],sz(a));
    return T;
}

string a,b;

int main() {
    setIO(); re(a,b);
    auto v = getPrefix(b,a); // ps(v);
    int ret = 0;
    trav(t,v) if (t == sz(b)) ret ++;
    ps(ret);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
String Matching,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vi pi(const string& s) {
    vi p(sz(s));
    rep(i,1,sz(s)) {
        int g = p[i-1];
        while (g && s[i] != s[g]) g = p[g-1];
        p[i] = g + (s[i] == s[g]);
    }
    return p;
}

vi match(const string& s, const string& pat) {
    vi p = pi(pat + '\0' + s), res;
    rep(i,sz(p)-sz(s),sz(p))
    if (p[i] == sz(pat)) res.push_back(i - 2 * sz(pat));
    return res;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    string s, t;
    cin >> s >> t;
    cout << sz(match(s, t)) << '\n';
    return 0;
}
"
String Matching,Java,"// https://cses.fi/problemset/task/1753
// String Matching
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1753 extends PrintWriter {
    CSES1753() {
        super(System.out, true);
        try { _bb = System.in.readAllBytes(); } catch (IOException e) {}
    }
    byte[] _bb; int _i;
    byte[] scan() {
        int n = _bb.length;
        while (_i < n && _bb[_i] < 33) _i++; int i = _i;
        while (_i < n && _bb[_i] > 32) _i++;
        return Arrays.copyOfRange(_bb, i, _i);
    }
    public static void main(String[] __) { new CSES1753().main(); }
    
    final int A = 26;
    void main() {
        byte[] aa = scan();
        byte[] bb = scan();
        int n = aa.length;
        int m = bb.length;
        int[] ff = new int[m];
        ff[0] = -1;
        for (int j = 1; j < m; j++) {
            int i = ff[j - 1] + 1;
            while (bb[i] != bb[j]) {
                if (i == 0) {
                    i = -1;
                    break;
                }
                i = ff[i - 1] + 1;
            }
            ff[j] = i;
        }
        int[][] dd = new int[m + 1][A];
        for (int j = 0; j <= m; j++)
            for (int a = 0; a < A; a++)
                if (j < m && bb[j] == a + 'a')
                    dd[j][a] = j + 1;
                else
                    dd[j][a] = j == 0 ? 0 : dd[ff[j - 1] + 1][a];
        int cnt = 0;
        for (int i = 0, j = 0; i < n; i++) {
            int a = aa[i] - 'a';
            j = dd[j][a];
            if (j == m)
                cnt++;
        }
        println(cnt);
    }
}
"
String Matching,Java,"// https://cses.fi/problemset/task/1753
// String Matching
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1753 extends PrintWriter {
    CSES1753() {
        super(System.out, true);
        try { _bb = System.in.readAllBytes(); } catch (IOException e) {}
    }
    byte[] _bb; int _i;
    byte[] scan() {
        int n = _bb.length;
        while (_i < n && _bb[_i] < 33) _i++; int i = _i;
        while (_i < n && _bb[_i] > 32) _i++;
        return Arrays.copyOfRange(_bb, i, _i);
    }
    public static void main(String[] __) { new CSES1753().main(); }
    
    final int A = 26;
    void main() {
        byte[] aa = scan();
        byte[] bb = scan();
        int n = aa.length;
        int m = bb.length;
        byte[] cc = Arrays.copyOf(bb, m + 1 + n);
        for (int i = 0; i < n; i++)
            cc[m + 1 + i] = aa[i];
        int[] ff = new int[m + 1 + n];
        ff[0] = -1;
        int cnt = 0;
        for (int j = 1; j < m + 1 + n; j++) {
            int i = ff[j - 1] + 1;
            while (cc[i] != cc[j]) {
                if (i == 0) {
                    i = -1;
                    break;
                }
                i = ff[i - 1] + 1;
            }
            ff[j] = i;
            if (i + 1 == m)
                cnt++;
        }
        println(cnt);
    }
}
"
String Matching,C++,"/*
 https://cses.fi/problemset/task/1753
 String Matching
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    1000000
#define M    1000000
#define A    26

int main() {
    static char aa[N + 1], bb[M + 1];
    static int ff[M], dd[M + 1][A];
    int n, m, i, j, a, cnt;
    
    scanf(""%s%s"", aa, bb);
    n = strlen(aa);
    m = strlen(bb);
    ff[0] = -1;
    for (j = 1; j < m; j++) {
        i = ff[j - 1] + 1;
        while (bb[i] != bb[j]) {
            if (i == 0) {
                i = -1;
                break;
            }
            i = ff[i - 1] + 1;
        }
        ff[j] = i;
    }
    for (j = 0; j <= m; j++)
        for (a = 0; a < A; a++)
            if (j < m && bb[j] == a + 'a')
                dd[j][a] = j + 1;
            else
                dd[j][a] = j == 0 ? 0 : dd[ff[j - 1] + 1][a];
    cnt = 0;
    for (i = 0, j = 0; i < n; i++)
        if ((j = dd[j][aa[i] - 'a']) == m)
            cnt++;
    printf(""%d\n"", cnt);
    return 0;
}
"
String Matching,C++,"/*
 https://cses.fi/problemset/task/1753
 String Matching
 practice with Dukkha
 */
#include <stdio.h>
#include <string.h>

#define N    1000000
#define M    1000000

int main() {
    static char aa[N + 1], bb[M + 1], cc[M + 1 + N + 1];
    static int ff[M + 1 + N];
    int n, m, i, j, cnt;
    
    scanf(""%s%s"", aa, bb);
    n = strlen(aa);
    m = strlen(bb);
    for (j = 0; j < m; j++)
        cc[j] = bb[j];
    for (i = 0; i < n; i++)
        cc[m + 1 + i] = aa[i];
    ff[0] = -1;
    cnt = 0;
    for (j = 1; j < m + 1 + n; j++) {
        i = ff[j - 1] + 1;
        while (cc[i] != cc[j]) {
            if (i == 0) {
                i = -1;
                break;
            }
            i = ff[i - 1] + 1;
        }
        ff[j] = i;
        if (i + 1 == m)
            cnt++;
    }
    printf(""%d\n"", cnt);
    return 0;
}
"
Word Combinations,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;


template<int MX> struct Trie {
    int nex[MX][26], num = 0; // num is last node in trie
    bool en[MX];
    // change 2 to 26 for lowercase letters
    
    void ins(string x) {
        int cur = 0;
        trav(t,x) {
            if (!nex[cur][t-'a']) nex[cur][t-'a'] = ++num;
            cur = nex[cur][t-'a'];
        }
        en[cur] = 1;
    }
};

Trie<1000005> T;
string s;
int k;
mi ways[5001];

int main() {
    setIO(); re(s,k);
    F0R(i,k) {
        string t; re(t);
        T.ins(t);
    }
    ways[0] = 1;
    F0R(i,sz(s)) {
        int cur = 0;
        FOR(j,i,sz(s)) {
            cur = T.nex[cur][s[j]-'a'];
            if (!cur) break;
            if (T.en[cur]) {
                ways[j+1] += ways[i];
                // ps(i,j+1);
            }
        }
    }
    ps(ways[sz(s)]);
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Word Combinations,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

struct AhoCorasick {
    enum {alpha = 26, first = 'a'};
    struct Node {
        // (nmatches is optional)
        int back, next[alpha], start = -1, end = -1, nmatches = 0;
        Node(int v) { memset(next, v, sizeof(next)); }
    };
    vector<Node> N;
    vector<int> backp;
    void insert(string& s, int j) {
        assert(!s.empty());
        int n = 0;
        trav(c, s) {
            int& m = N[n].next[c - first];
            if (m == -1) { n = m = sz(N); N.emplace_back(-1); }
            else n = m;
        }
        if (N[n].end == -1) N[n].start = j;
        backp.push_back(N[n].end);
        N[n].end = j;
        N[n].nmatches++;
    }
    AhoCorasick(vector<string>& pat) {
        N.emplace_back(-1);
        rep(i,0,sz(pat)) insert(pat[i], i);
        N[0].back = sz(N);
        N.emplace_back(0);
        
        queue<int> q;
        for (q.push(0); !q.empty(); q.pop()) {
            int n = q.front(), prev = N[n].back;
            rep(i,0,alpha) {
                int &ed = N[n].next[i], y = N[prev].next[i];
                if (ed == -1) ed = y;
                else {
                    N[ed].back = y;
                    (N[ed].end == -1 ? N[ed].end : backp[N[ed].start])
                    = N[y].end;
                    N[ed].nmatches += N[y].nmatches;
                    q.push(ed);
                }
            }
        }
    }
    vi find(string word) {
        int n = 0;
        vi res; // ll count = 0;
        trav(c, word) {
            n = N[n].next[c - first];
            res.push_back(N[n].end);
            // count += N[n].nmatches;
        }
        return res;
    }
    vector<vi> findAll(vector<string>& pat, string word) {
        vi r = find(word);
        vector<vi> res(sz(word));
        rep(i,0,sz(word)) {
            int ind = r[i];
            while (ind != -1) {
                res[i - sz(pat[ind]) + 1].push_back(ind);
                ind = backp[ind];
            }
        }
        return res;
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    constexpr int P=1e9+7;
    string s;
    int n;
    cin >> s >> n;
    vector<string> p(n);
    rep(i, 0, n) cin >> p[i];
    AhoCorasick a(p);
    vector<vi> f=a.findAll(p, s);
    int m=sz(s);
    vi dp(m+1);
    dp[m]=1;
    rep(i, 1, m+1) trav(j, f[m-i]) {
        dp[m-i]+=dp[m-i+sz(p[j])];
        if (dp[m-i]>=P) dp[m-i]-=P;
    }
    cout << dp[0] << '\n';
    return 0;
}
"
Word Combinations,Java,"// https://cses.fi/problemset/task/1731
// Word Combinations
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1731 {
    static Random rand = new Random();
    static final int MD = 1000000007;
    static final int P = rand.nextInt(MD - 2) + 2;
    static final int Q = rand.nextInt(MD - 2) + 2;
    static long hash(byte[] cc, int n) {
        long x = 0, y = 0;
        for (int i = 0; i < n; i++) {
            x = (x * P + cc[i]) % MD;
            y = (y * Q + cc[i]) % MD;
        }
        return x * MD + y;
    }
    static int[] aa, bb, pp, qq;
    static long hash2(int i, int j) {
        long x = (aa[j] - (long) aa[i - 1] * pp[j - i + 1]) % MD;
        long y = (bb[j] - (long) bb[i - 1] * qq[j - i + 1]) % MD;
        if (x < 0)
            x += MD;
        if (y < 0)
            y += MD;
        return x * MD + y;
    }
    public static void main(String[] __) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        byte[] cc = br.readLine().getBytes();
        int n = cc.length;
        aa = new int[n + 1];
        bb = new int[n + 1];
        pp = new int[n + 1];
        qq = new int[n + 1];
        aa[0] = bb[0] = 0;
        pp[0] = qq[0] = 1;
        for (int i = 0; i < n; i++) {
            aa[i + 1] = (int) (((long) aa[i] * P + cc[i]) % MD);
            bb[i + 1] = (int) (((long) bb[i] * Q + cc[i]) % MD);
            pp[i + 1] = (int) ((long) pp[i] * P % MD);
            qq[i + 1] = (int) ((long) qq[i] * Q % MD);
        }
        StringTokenizer st = new StringTokenizer(br.readLine());
        HashSet<Integer> hl = new HashSet<>();
        HashSet<Long> hs = new HashSet<>();
        int k = Integer.parseInt(st.nextToken());
        while (k-- > 0) {
            cc = br.readLine().getBytes();
            int l = cc.length;
            if (l <= n) {
                hl.add(l);
                hs.add(hash(cc, l));
            }
        }
        int m = hl.size();
        int[] ll = new int[m];
        m = 0;
        for (Integer l : hl)
            ll[m++] = l;
        Arrays.sort(ll);
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 0, j; i < n; i++) {
            int x = dp[i];
            if (x == 0)
                continue;
            for (int h = 0; h < m && (j = i + ll[h]) <= n; h++)
                if (hs.contains(hash2(i + 1, j)))
                    dp[j] = (dp[j] + x) % MD;
        }
        pw.println(dp[n]);
        pw.close();
    }
}
"
Word Combinations,C++,"/*
 https://cses.fi/problemset/task/1731
 Word Combinations
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>

#define N    5000
#define M    200000
#define K    100000
#define MD    1000000007

void init_rand() {
    struct timeval tv;
    
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec ^ tv.tv_usec);
}

int P, Q;

long long hash(char *s, int n) {
    long long x, y;
    
    x = y = 0;
    while (n--) {
        x = (x * P + *s) % MD;
        y = (y * Q + *s) % MD;
        s++;
    }
    return x * MD + y;
}

int aa[N + 1], bb[N + 1], pp[N + 1], qq[N + 1];

long long hash2(int i, int j) {
    long long x = (aa[j] - (long long) aa[i - 1] * pp[j - i + 1] % MD) % MD;
    long long y = (bb[j] - (long long) bb[i - 1] * qq[j - i + 1] % MD) % MD;
    
    if (x < 0)
        x += MD;
    if (y < 0)
        y += MD;
    return x * MD + y;
}

struct L {
    struct L *next;
    long long key;
} hs[M];

struct L *new_L(long long key) {
    static struct L l91[K], *l = l91;
    
    l->key = key;
    return l++;
}

void hs_put(long long key) {
    struct L *l = new_L(key);
    int h = (key % M + M) % M;
    
    l->next = hs[h].next; hs[h].next = l;
}

int hs_contains(long long key) {
    struct L *l;
    int h = (key % M + M) % M;
    
    for (l = hs[h].next; l; l = l->next)
        if (key == l->key)
            return 1;
    return 0;
}

int compare(const void *a, const void *b) {
    int ia = *(int *) a;
    int ib = *(int *) b;
    
    return ia - ib;
}

int main() {
    static char cc[1048576], used[N + 1];
    static int ll[N + 1], dp[N + 1];
    int n, h, i, j, k, l, m, x;
    
    init_rand();
    P = (rand() * 45677LL + rand()) % (MD - 2) + 2;
    Q = (rand() * 45677LL + rand()) % (MD - 2) + 2;
    scanf(""%s"", cc);
    n = strlen(cc);
    aa[0] = bb[0] = 0;
    pp[0] = qq[0] = 1;
    for (i = 0; i < n; i++) {
        aa[i + 1] = ((long long) aa[i] * P + cc[i]) % MD;
        bb[i + 1] = ((long long) bb[i] * Q + cc[i]) % MD;
        pp[i + 1] = (long long) pp[i] * P % MD;
        qq[i + 1] = (long long) qq[i] * Q % MD;
    }
    scanf(""%d"", &k);
    m = 0;
    while (k--) {
        scanf(""%s"", cc);
        l = strlen(cc);
        if (l <= n && !used[l]) {
            ll[m++] = l;
            used[l] = 1;
        }
        hs_put(hash(cc, l));
    }
    qsort(ll, m, sizeof *ll, compare);
    dp[0] = 1;
    for (i = 0; i < n; i++) {
        x = dp[i];
        if (x == 0)
            continue;
        for (h = 0; h < m && (j = i + ll[h]) <= n; h++)
            if (hs_contains(hash2(i + 1, j)))
                dp[j] = (dp[j] + x) % MD;
    }
    printf(""%d\n"", dp[n]);
    return 0;
}
"
Company Queries I,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<int SZ> struct LCA {
    static const int BITS = 32-__builtin_clz(SZ);
    
    int N, R = 1; // vertices from 1 to N, R = root
    vi adj[SZ];
    int par[BITS][SZ], depth[SZ];
    
    // INITIALIZE
    
    void addEdge(int u, int v) { adj[u].pb(v), adj[v].pb(u); }
    
    void dfs(int u, int prev){
        par[0][u] = prev;
        depth[u] = depth[prev]+1;
        trav(v,adj[u]) if (v != prev) dfs(v, u);
    }
    
    void init(int _N) {
        N = _N; dfs(R, 0);
        FOR(k,1,BITS) FOR(i,1,N+1) par[k][i] = par[k-1][par[k-1][i]];
    }
    
    // QUERY
    
    int getPar(int a, int b) {
        F0Rd(k,BITS) if (b&(1<<k)) a = par[k][a];
        return a;
    }
    
    int lca(int u, int v){
        if (depth[u] < depth[v]) swap(u,v);
        u = getPar(u,depth[u]-depth[v]);
        F0Rd(k,BITS) if (par[k][u] != par[k][v]) u = par[k][u], v = par[k][v];
        return u == v ? u : par[0][u];
    }
    
    int dist(int u, int v) {
        return depth[u]+depth[v]-2*depth[lca(u,v)];
    }
};

LCA<MX> L;
int n,q;

int main() {
    setIO(); re(n,q);
    FOR(i,2,n+1) {
        int e; re(e);
        L.addEdge(i,e);
    }
    L.init(n);
    F0R(i,q) {
        int a,b; re(a,b);
        a = L.getPar(a,b);
        if (!a) ps(-1);
        else ps(a);
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Company Queries I,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vector<vi> treeJump(vi& P){
    int on = 1, d = 1;
    while(on < sz(P)) on *= 2, d++;
    vector<vi> jmp(d, P);
    rep(i,1,d) rep(j,0,sz(P))
    jmp[i][j] = jmp[i-1][jmp[i-1][j]];
    return jmp;
}

int jmp(vector<vi>& tbl, int nod, int steps){
    rep(i,0,sz(tbl))
    if(steps&(1<<i)) nod = tbl[i][nod];
    return nod;
}

int lca(vector<vi>& tbl, vi& depth, int a, int b) {
    if (depth[a] < depth[b]) swap(a, b);
    a = jmp(tbl, a, depth[a] - depth[b]);
    if (a == b) return a;
    for (int i = sz(tbl); i--;) {
        int c = tbl[i][a], d = tbl[i][b];
        if (c != d) a = c, b = d;
    }
    return tbl[0][a];
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    vi p(n+1);
    p[1]=1;
    rep(i, 2, n+1) cin >> p[i];
    vector<vi> tbl=treeJump(p);
    rep(i, 0, q) {
        int a, b;
        cin >> a >> b;
        if (jmp(tbl, a, b-1)==1)
            cout << -1 << '\n';
        else
            cout << jmp(tbl, a, b) << '\n';
    }
    return 0;
}
"
Company Queries I,Java,"// https://cses.fi/problemset/task/1687
// Company Queries I
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1687 {
    static ArrayList[] aa, hh;
    static int[] stack;
    static int cnt;
    static int[] kk, bb;
    static void dfs(int i) {
        ArrayList<Integer> que = hh[i];
        for (int h : que) {
            int k = kk[h];
            bb[h] = k <= cnt ? stack[cnt - k] + 1 : -1;
        }
        stack[cnt++] = i;
        ArrayList<Integer> adj = aa[i];
        for (int j : adj)
            dfs(j);
        cnt--;
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int q = sc.nextInt();
        aa = new ArrayList[n];
        hh = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            aa[i] = new ArrayList<Integer>();
            hh[i] = new ArrayList<Integer>();
        }
        for (int i = 1; i < n; i++) {
            int p = sc.nextInt() - 1;
            aa[p].add(i);
        }
        kk = new int[q];
        bb = new int[q];
        for (int h = 0; h < q; h++) {
            int i = sc.nextInt() - 1;
            kk[h] = sc.nextInt();
            hh[i].add(h);
        }
        stack = new int[n];
        dfs(0);
        for (int h = 0; h < q; h++)
            pw.println(bb[h]);
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Company Queries I,C++,"/*
 https://cses.fi/problemset/task/1687
 Company Queries I
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define Q    200000

struct L {
    struct L *next;
    int j;
} aa[N], hh[N];

int kk[Q], bb[Q];

void link(int i, int j) {
    static struct L l91[N], *l = l91;
    
    l->j = j;
    l->next = aa[i].next, aa[i].next = l++;
}

void link_(int i, int h) {
    static struct L l91[Q], *l = l91;
    
    l->j = h;
    l->next = hh[i].next, hh[i].next = l++;
}

int stack[N], cnt;

void dfs(int i) {
    struct L *l;
    
    for (l = hh[i].next; l; l = l->next) {
        int h = l->j, k = kk[h];
        
        bb[h] = k <= cnt ? stack[cnt - k] + 1 : -1;
    }
    stack[cnt++] = i;
    for (l = aa[i].next; l; l = l->next)
        dfs(l->j);
    cnt--;
}

int main() {
    int n, q, p, h, i;
    
    scanf(""%d%d"", &n, &q);
    for (i = 1; i < n; i++) {
        scanf(""%d"", &p), p--;
        link(p, i);
    }
    for (h = 0; h < q; h++) {
        scanf(""%d%d"", &i, &kk[h]), i--;
        link_(i, h);
    }
    dfs(0);
    for (h = 0; h < q; h++)
        printf(""%d\n"", bb[h]);
    return 0;
}
"
Company Queries II,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

template<int SZ> struct LCA {
    static const int BITS = 32-__builtin_clz(SZ);
    
    int N, R = 1; // vertices from 1 to N, R = root
    vi adj[SZ];
    int par[BITS][SZ], depth[SZ];
    
    // INITIALIZE
    
    void addEdge(int u, int v) { adj[u].pb(v), adj[v].pb(u); }
    
    void dfs(int u, int prev){
        par[0][u] = prev;
        depth[u] = depth[prev]+1;
        trav(v,adj[u]) if (v != prev) dfs(v, u);
    }
    
    void init(int _N) {
        N = _N; dfs(R, 0);
        FOR(k,1,BITS) FOR(i,1,N+1) par[k][i] = par[k-1][par[k-1][i]];
    }
    
    // QUERY
    
    int getPar(int a, int b) {
        F0Rd(k,BITS) if (b&(1<<k)) a = par[k][a];
        return a;
    }
    
    int lca(int u, int v){
        if (depth[u] < depth[v]) swap(u,v);
        u = getPar(u,depth[u]-depth[v]);
        F0Rd(k,BITS) if (par[k][u] != par[k][v]) u = par[k][u], v = par[k][v];
        return u == v ? u : par[0][u];
    }
    
    int dist(int u, int v) {
        return depth[u]+depth[v]-2*depth[lca(u,v)];
    }
};

LCA<MX> L;
int n,q;

int main() {
    setIO(); re(n,q);
    FOR(i,2,n+1) {
        int e; re(e);
        L.addEdge(i,e);
    }
    L.init(n);
    F0R(i,q) {
        int a,b; re(a,b);
        ps(L.lca(a,b));
    }
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Company Queries II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

typedef vector<pii> vpi;
typedef vector<vpi> graph;

template<class T>
struct RMQ {
    vector<vector<T>> jmp;
    
    RMQ(const vector<T>& V) {
        int N = sz(V), on = 1, depth = 1;
        while (on < N) on *= 2, depth++;
        jmp.assign(depth, V);
        rep(i,0,depth-1) rep(j,0,N)
        jmp[i+1][j] = min(jmp[i][j],
                          jmp[i][min(N - 1, j + (1 << i))]);
    }
    
    T query(int a, int b) {
        assert(a < b); // or return inf if a == b
        int dep = 31 - __builtin_clz(b - a);
        return min(jmp[dep][a], jmp[dep][b - (1 << dep)]);
    }
};

struct LCA {
    vi time;
    vector<ll> dist;
    RMQ<pii> rmq;
    
    LCA(graph& C) : time(sz(C), -99), dist(sz(C)), rmq(dfs(C)) {}
    
    vpi dfs(graph& C) {
        vector<tuple<int, int, int, ll>> q(1);
        vpi ret;
        int T = 0, v, p, d; ll di;
        while (!q.empty()) {
            tie(v, p, d, di) = q.back();
            q.pop_back();
            if (d) ret.emplace_back(d, p);
            time[v] = T++;
            dist[v] = di;
            trav(e, C[v]) if (e.first != p)
                q.emplace_back(e.first, v, d+1, di + e.second);
        }
        return ret;
    }
    
    int query(int a, int b) {
        if (a == b) return a;
        a = time[a], b = time[b];
        return rmq.query(min(a, b), max(a, b)).second;
    }
    ll distance(int a, int b) {
        int lca = query(a, b);
        return dist[a] + dist[b] - 2 * dist[lca];
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    graph g(n);
    rep(i, 1, n) {
        int a;
        cin >> a;
        a--;
        g[i].push_back({a, 1});
        g[a].push_back({i, 1});
    }
    LCA lca(g);
    while (q--) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        cout << lca.query(a, b)+1 << '\n';
    }
    return 0;
}
"
Company Queries II,Java,"// https://cses.fi/problemset/task/1688
// Company Queries II
// practice with rainboy
import java.io.*;

public class CSES1688 {
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int q = sc.nextInt();
        int ln = 0;
        while (1 << ln + 1 <= n - 1)
            ln++;
        int[][] pp = new int[ln + 1][n];
        int[] dd = new int[n];
        for (int i = 1; i < n; i++) {
            int p = sc.nextInt() - 1;
            dd[i] = dd[p] + 1;
            pp[0][i] = p;
        }
        for (int k = 1; k <= ln; k++)
            for (int i = 0; i < n; i++)
                pp[k][i] = pp[k - 1][pp[k - 1][i]];
        while (q-- > 0) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            if (dd[i] < dd[j]) {
                int tmp = i; i = j; j = tmp;
            }
            if (dd[i] != dd[j])
                for (int k = ln; k >= 0; k--)
                    if (1 << k <= dd[i] - dd[j])
                        i = pp[k][i];
            if (i != j) {
                for (int k = ln; k >= 0; k--)
                    if (1 << k <= dd[i] && pp[k][i] != pp[k][j]) {
                        i = pp[k][i];
                        j = pp[k][j];
                    }
                i = pp[0][i];
            }
            pw.println(i + 1);
        }
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Company Queries II,C++,"/*
 https://cses.fi/problemset/task/1688
 Company Queries II
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define LN    17    /* LN = floor(log2(N - 1)) */

int main() {
    static int dd[N], pp[LN + 1][N];
    int n, q, p, i, j, k, tmp;
    
    scanf(""%d%d"", &n, &q);
    for (i = 1; i < n; i++) {
        scanf(""%d"", &p), p--;
        dd[i] = dd[p] + 1;
        pp[0][i] = p;
    }
    for (k = 1; k <= LN; k++)
        for (i = 0; i < n; i++)
            pp[k][i] = pp[k - 1][pp[k - 1][i]];
    while (q--) {
        scanf(""%d%d"", &i, &j), i--, j--;
        if (dd[i] < dd[j])
            tmp = i, i = j, j = tmp;
        if (dd[i] != dd[j])
            for (k = LN; k >= 0; k--)
                if (1 << k <= dd[i] - dd[j])
                    i = pp[k][i];
        if (i != j) {
            for (k = LN; k >= 0; k--)
                if (1 << k <= dd[i] && pp[k][i] != pp[k][j]) {
                    i = pp[k][i];
                    j = pp[k][j];
                }
            i = pp[0][i];
        }
        printf(""%d\n"", i + 1);
    }
    return 0;
}
"
Counting Paths,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

const int MAXN = 200001, MAXK = 18;

struct LCA {
    int V, R;
    vi edges[MAXN];
    int parK[MAXK][MAXN];
    int depth[MAXN], tmp[MAXN];
    
    void addEdge(int u, int v) {
        edges[u].pb(v), edges[v].pb(u);
    }
    
    void dfs(int u, int prev){
        parK[0][u] = prev;
        depth[u] = depth[prev]+1;
        for (int v: edges[u]) if (v != prev) dfs(v, u);
    }
    
    void dfs1(int u, int prev) {
        for (int i: edges[u]) if (i != prev) dfs1(i,u);
        tmp[prev] += tmp[u];
    }
    
    void construct() {
        dfs(R, 0);
        FOR(k,1,MAXK) FOR(i,1,V+1)
        parK[k][i] = parK[k-1][parK[k-1][i]];
    }
    
    int lca(int u, int v){
        if (depth[u] < depth[v]) swap(u,v);
        
        F0Rd(k,MAXK)  if (depth[u] >= depth[v]+(1<<k))  u = parK[k][u];
        F0Rd(k,MAXK) if (parK[k][u] != parK[k][v]) u = parK[k][u], v = parK[k][v];
        
        if(u != v) u = parK[0][u], v = parK[0][v];
        return u;
    }
    
    int dist(int u, int v) {
        return depth[u]+depth[v]-2*depth[lca(u,v)];
    }
};

LCA L;
int m;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> L.V >> m; L.R = 1;
    F0R(i,L.V-1) {
        int a,b; cin >> a >> b;
        L.addEdge(a,b);
    }
    L.construct();
    F0R(i,m) {
        int a,b; cin >> a >> b;
        int x = L.lca(a,b);
        L.tmp[a] ++, L.tmp[b] ++, L.tmp[x] --, L.tmp[L.parK[0][x]] --;
    }
    L.dfs1(1,0);
    FOR(i,1,L.V+1) cout << L.tmp[i] << "" "";
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Counting Paths,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

typedef vector<pii> vpi;
typedef vector<vpi> graph;

template<class T>
struct RMQ {
    vector<vector<T>> jmp;
    
    RMQ(const vector<T>& V) {
        int N = sz(V), on = 1, depth = 1;
        while (on < N) on *= 2, depth++;
        jmp.assign(depth, V);
        rep(i,0,depth-1) rep(j,0,N)
        jmp[i+1][j] = min(jmp[i][j],
                          jmp[i][min(N - 1, j + (1 << i))]);
    }
    
    T query(int a, int b) {
        assert(a < b); // or return inf if a == b
        int dep = 31 - __builtin_clz(b - a);
        return min(jmp[dep][a], jmp[dep][b - (1 << dep)]);
    }
};

struct LCA {
    vi time;
    vector<ll> dist;
    RMQ<pii> rmq;
    
    LCA(graph& C) : time(sz(C), -99), dist(sz(C)), rmq(dfs(C)) {}
    
    vpi dfs(graph& C) {
        vector<tuple<int, int, int, ll>> q(1);
        vpi ret;
        int T = 0, v, p, d; ll di;
        while (!q.empty()) {
            tie(v, p, d, di) = q.back();
            q.pop_back();
            if (d) ret.emplace_back(d, p);
            time[v] = T++;
            dist[v] = di;
            trav(e, C[v]) if (e.first != p)
                q.emplace_back(e.first, v, d+1, di + e.second);
        }
        return ret;
    }
    
    int query(int a, int b) {
        if (a == b) return a;
        a = time[a], b = time[b];
        return rmq.query(min(a, b), max(a, b)).second;
    }
    ll distance(int a, int b) {
        int lca = query(a, b);
        return dist[a] + dist[b] - 2 * dist[lca];
    }
};

vi w, d;
graph g;

void dfs(int i, int p) {
    trav(c, g[i]) if (c.first!=p) {
        dfs(c.first, i);
        w[i]+=w[c.first];
    }
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, m;
    cin >> n >> m;
    g.resize(n);
    rep(i, 0, n-1) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        g[a].push_back({b, 1});
        g[b].push_back({a, 1});
    }
    LCA lca(g);
    w.resize(n);
    d.resize(n);
    while (m--) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        w[a]++, w[b]++;
        int c=lca.query(a, b);
        w[c]-=2, d[c]++;
    }
    dfs(0, -1);
    rep(i, 0, n) cout << w[i]+d[i] << "" \n""[i==n-1];
    return 0;
}
"
Counting Paths,C++,"// https://cses.fi/problemset/task/1136
// Counting Paths
// practice with rainboy
#include <iostream>
#include <vector>

using namespace std;

const int N = 200000, K = 17;

vector<int> aa[N];

int pp[N][K + 1], dd[N], ll[N], rr[N], cc[N];

void dfs1(int p, int i, int d) {
    dd[i] = d;
    pp[i][0] = p;
    for (int k = 1; 1 << k <= d; k++)
        pp[i][k] = pp[pp[i][k - 1]][k - 1];
    for (int j : aa[i])
        if (j != p)
            dfs1(i, j, d + 1);
}

int dfs2(int p, int i) {
    int c = cc[i];
    for (int j : aa[i])
        if (j != p)
            c += dfs2(i, j);
    cc[i] = c += ll[i];
    return c - rr[i];
}

int lca(int i, int j) {
    if (dd[i] < dd[j])
        return lca(j, i);
    for (int k = K; k >= 0; k--)
        if (1 << k <= dd[i] - dd[j])
            i = pp[i][k];
    if (i == j)
        return i;
    for (int k = K; k >= 0; k--)
        if (1 << k <= dd[i] && pp[i][k] != pp[j][k]) {
            i = pp[i][k];
            j = pp[j][k];
        }
    return pp[i][0];
}

int main() {
    int n, m;
    scanf(""%d%d"", &n, &m);
    for (int h = 0; h < n - 1; h++) {
        int i, j;
        scanf(""%d%d"", &i, &j);
        i--, j--;
        aa[i].push_back(j);
        aa[j].push_back(i);
    }
    dfs1(-1, 0, 0);
    while (m--) {
        int i, j;
        scanf(""%d%d"", &i, &j);
        i--, j--;
        int a = lca(i, j);
        if (i == a) {
            ll[j]++;
            rr[i]++;
        } else if (j == a) {
            ll[i]++;
            rr[j]++;
        } else {
            ll[i]++;
            ll[j]++;
            rr[a]++;
            cc[a]--;
        }
    }
    dfs2(-1, 0);
    for (int i = 0; i < n; i++)
        printf(""%d "", cc[i]);
    printf(""\n"");
    return 0;
}
"
Counting Paths,C++,"/*
 https://cses.fi/problemset/task/1136
 Counting Paths
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define K    17    /* K = floor(log2(N)) */

struct L {
    struct L *next;
    int j;
} aa[N];

int dd[N], pp[N][K + 1], ll[N], rr[N], cc[N];

void link(int i, int j) {
    static struct L ll_[N * 2], *l = ll_;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

void dfs(int p, int i, int d) {
    struct L *l;
    int k;
    
    dd[i] = d;
    pp[i][0] = p;
    for (k = 1; 1 << k <= d; k++)
        pp[i][k] = pp[pp[i][k - 1]][k - 1];
    for (l = aa[i].next; l; l = l->next)
        if (l->j != p)
            dfs(i, l->j, d + 1);
}

int lca(int i, int j) {
    int k;
    
    if (dd[i] < dd[j])
        return lca(j, i);
    for (k = K; k >= 0; k--)
        if (1 << k <= dd[i] - dd[j])
            i = pp[i][k];
    if (i == j)
        return i;
    for (k = K; k >= 0; k--)
        if (1 << k <= dd[i] && pp[i][k] != pp[j][k])
            i = pp[i][k], j = pp[j][k];
    return pp[i][0];
}

int dfs2(int p, int i) {
    struct L *l;
    int c = cc[i];
    
    for (l = aa[i].next; l; l = l->next)
        if (l->j != p)
            c += dfs2(i, l->j);
    cc[i] = c += ll[i];
    return c - rr[i];
}

int main() {
    int n, m, h, i, j;
    
    scanf(""%d%d"", &n, &m);
    for (h = 0; h < n - 1; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), link(j, i);
    }
    dfs(-1, 0, 0);
    while (m--) {
        int i, j, a;
        
        scanf(""%d%d"", &i, &j), i--, j--;
        a = lca(i, j);
        if (i == a) {
            ll[j]++;
            rr[i]++;
        } else if (j == a) {
            ll[i]++;
            rr[j]++;
        } else {
            ll[i]++;
            ll[j]++;
            rr[a]++;
            cc[a]--;
        }
    }
    dfs2(-1, 0);
    for (i = 0; i < n; i++)
        printf(""%d "", cc[i]);
    printf(""\n"");
    return 0;
}
"
Distance Queries,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

const int MAXN = 200001, MAXK = 18;

struct LCA {
    int V, R;
    vi edges[MAXN];
    int parK[MAXK][MAXN];
    int depth[MAXN];
    
    void addEdge(int u, int v) {
        edges[u].pb(v), edges[v].pb(u);
    }
    
    void dfs(int u, int prev){
        parK[0][u] = prev;
        depth[u] = depth[prev]+1;
        for (int v: edges[u]) if (v != prev) dfs(v, u);
    }
    
    void construct() {
        dfs(R, 0);
        FOR(k,1,MAXK) FOR(i,1,V+1)
        parK[k][i] = parK[k-1][parK[k-1][i]];
    }
    
    int lca(int u, int v){
        if (depth[u] < depth[v]) swap(u,v);
        
        F0Rd(k,MAXK)  if (depth[u] >= depth[v]+(1<<k))  u = parK[k][u];
        F0Rd(k,MAXK) if (parK[k][u] != parK[k][v]) u = parK[k][u], v = parK[k][v];
        
        if(u != v) u = parK[0][u], v = parK[0][v];
        return u;
    }
    
    int dist(int u, int v) {
        return depth[u]+depth[v]-2*depth[lca(u,v)];
    }
};

LCA L;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> L.V; L.R = 1;
    int Q; cin >> Q;
    F0R(i,L.V-1) {
        int a,b; cin >> a >> b;
        L.addEdge(a,b);
    }
    L.construct();
    F0R(i,Q) {
        int a,b; cin >> a >> b;
        cout << L.dist(a,b) << ""\n"";
    }
}
"
Distance Queries,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

typedef vector<pii> vpi;
typedef vector<vpi> graph;

template<class T>
struct RMQ {
    vector<vector<T>> jmp;
    
    RMQ(const vector<T>& V) {
        int N = sz(V), on = 1, depth = 1;
        while (on < N) on *= 2, depth++;
        jmp.assign(depth, V);
        rep(i,0,depth-1) rep(j,0,N)
        jmp[i+1][j] = min(jmp[i][j],
                          jmp[i][min(N - 1, j + (1 << i))]);
    }
    
    T query(int a, int b) {
        assert(a < b); // or return inf if a == b
        int dep = 31 - __builtin_clz(b - a);
        return min(jmp[dep][a], jmp[dep][b - (1 << dep)]);
    }
};

struct LCA {
    vi time;
    vector<ll> dist;
    RMQ<pii> rmq;
    
    LCA(graph& C) : time(sz(C), -99), dist(sz(C)), rmq(dfs(C)) {}
    
    vpi dfs(graph& C) {
        vector<tuple<int, int, int, ll>> q(1);
        vpi ret;
        int T = 0, v, p, d; ll di;
        while (!q.empty()) {
            tie(v, p, d, di) = q.back();
            q.pop_back();
            if (d) ret.emplace_back(d, p);
            time[v] = T++;
            dist[v] = di;
            trav(e, C[v]) if (e.first != p)
                q.emplace_back(e.first, v, d+1, di + e.second);
        }
        return ret;
    }
    
    int query(int a, int b) {
        if (a == b) return a;
        a = time[a], b = time[b];
        return rmq.query(min(a, b), max(a, b)).second;
    }
    ll distance(int a, int b) {
        int lca = query(a, b);
        return dist[a] + dist[b] - 2 * dist[lca];
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    graph g(n);
    rep(i, 0, n-1) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        g[a].push_back({b, 1});
        g[b].push_back({a, 1});
    }
    LCA x(g);
    while (q--) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        cout << x.distance(a, b) << '\n';
    }
    return 0;
}
"
Distance Queries,C++,"// https://cses.fi/problemset/task/1135
// Distance Queries
// practice with rainboy
#include <iostream>
#include <vector>

using namespace std;

const int N = 200000, K = 17;

vector<int> aa[N];
int dd[N];
int pp[N][K + 1];

void dfs(int p, int i, int d) {
    dd[i] = d;
    pp[i][0] = p;
    for (int k = 1; 1 << k <= d; k++)
        pp[i][k] = pp[pp[i][k - 1]][k - 1];
    for (int j : aa[i])
        if (j != p)
            dfs(i, j, d + 1);
}

int lca(int i, int j) {
    if (dd[i] < dd[j])
        return lca(j, i);
    for (int k = K; k >= 0; k--)
        if (1 << k <= dd[i] - dd[j])
            i = pp[i][k];
    if (i == j)
        return i;
    for (int k = K; k >= 0; k--)
        if (1 << k <= dd[i] && pp[i][k] != pp[j][k]) {
            i = pp[i][k];
            j = pp[j][k];
        }
    return pp[i][0];
}

int main() {
    int n, q;
    scanf(""%d%d"", &n, &q);
    for (int h = 0; h < n - 1; h++) {
        int i, j;
        scanf(""%d%d"", &i, &j);
        i--, j--;
        aa[i].push_back(j);
        aa[j].push_back(i);
    }
    dfs(-1, 0, 0);
    while (q--) {
        int i, j;
        scanf(""%d%d"", &i, &j);
        i--, j--;
        int a = lca(i, j);
        printf(""%d\n"", dd[i] + dd[j] - dd[a] * 2);
    }
    return 0;
}
"
Distance Queries,C++,"/*
 https://cses.fi/problemset/task/1135
 Distance Queries
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000
#define K    17    /* K = floor(log2(N - 1)) */

struct L {
    struct L *next;
    int j;
} aa[N];

int dd[N], pp[N][K + 1];

void link(int i, int j) {
    static struct L l91[N * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

void dfs(int p, int i, int d) {
    struct L *l;
    int k;
    
    dd[i] = d;
    pp[i][0] = p;
    for (k = 1; 1 << k <= d; k++)
        pp[i][k] = pp[pp[i][k - 1]][k - 1];
    for (l = aa[i].next; l; l = l->next)
        if (l->j != p)
            dfs(i, l->j, d + 1);
}

int lca(int i, int j) {
    int k;
    
    if (dd[i] < dd[j])
        return lca(j, i);
    for (k = K; k >= 0; k--)
        if (1 << k <= dd[i] - dd[j])
            i = pp[i][k];
    if (i == j)
        return i;
    for (k = K; k >= 0; k--)
        if (1 << k <= dd[i] && pp[i][k] != pp[j][k])
            i = pp[i][k], j = pp[j][k];
    return pp[i][0];
}

int main() {
    int n, q, h, i, j;
    
    scanf(""%d%d"", &n, &q);
    for (h = 0; h < n - 1; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), link(j, i);
    }
    dfs(-1, 0, 0);
    while (q--) {
        int i, j, a;
        
        scanf(""%d%d"", &i, &j), i--, j--;
        a = lca(i, j);
        printf(""%d\n"", dd[i] + dd[j] - dd[a] * 2);
    }
    return 0;
}
"
Distinct Colors,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
typedef pair<ll,ll> pll;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MX = 200001;

int n;

struct HeavyLightSet {
    int loc[MX], sub[MX], val[MX], ans[MX];
    vi child[MX];
    set<int> dat[MX];
    
    void comb(int a, int b) {
        int A = loc[a], B = loc[b];
        if (sz(dat[A]) < sz(dat[B])) swap(a,b), swap(A,B);
        for (int x: dat[B]) dat[A].insert(x);
        dat[B].clear(); loc[b] = A;
    }
    
    void process(int ind, int pre) {
        sub[ind] = 1; loc[ind] = ind; dat[ind].insert(val[ind]);
        for (int i: child[ind]) if (i != pre) {
            process(i,ind);
            comb(i,ind);
            sub[ind] += sub[i];
        }
        ans[ind] = sz(dat[loc[ind]]);
        // now do stuff with values
    }
};

HeavyLightSet H;

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n;
    FOR(i,1,n+1) cin >> H.val[i];
    F0R(i,n-1) {
        int a,b; cin >> a >> b;
        H.child[a].pb(b), H.child[b].pb(a);
    }
    H.process(1,0);
    FOR(i,1,n+1) cout << H.ans[i] << "" "";
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Distinct Colors,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vector<vi> g;
vector<set<int>> x;
vi c, ans;

void dfs(int i, int p) {
    x[i].insert(c[i]);
    trav(j, g[i]) if (j!=p) {
        dfs(j, i);
        if (sz(x[j])>sz(x[i]))
            swap(x[i], x[j]);
    }
    trav(j, g[i]) if (j!=p)
        trav(k, x[j]) x[i].insert(k);
    ans[i]=sz(x[i]);
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    c.resize(n+1);
    rep(i, 1, n+1) cin >> c[i];
    g.resize(n+1);
    rep(i, 0, n-1) {
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    x.resize(n+1);
    ans.resize(n+1);
    dfs(1, 0);
    rep(i, 1, n+1)
    cout << ans[i] << "" \n""[i==n];
    return 0;
}
"
Distinct Colors,C++,"// https://cses.fi/problemset/task/1139
// Distinct Colors
// practice with rainboy
#include <algorithm>
#include <iostream>
#include <vector>

using namespace std;

const int N = 500000;

vector<int> aa[N];

int cc[N], ii[N], jj[N], ll[N], rr[N], tt[N];

void dfs(int p, int i) {
    static int t;
    ll[i] = t++;
    for (int j : aa[i])
        if (j != p)
            dfs(i, j);
    rr[i] = t;
}

void update(int i, int n, int x) {
    while (i < n) {
        tt[i] += x;
        i |= i + 1;
    }
}

int query(int i) {
    int cnt = 0;
    while (i >= 0) {
        cnt += tt[i];
        i &= i + 1;
        i--;
    }
    return cnt;
}

int main() {
    int n;
    scanf(""%d"", &n);
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &cc[i]);
        ii[i] = i;
    }
    sort(ii, ii + n, [] (int i, int j) { return cc[i] < cc[j]; });
    int m = 0;
    for (int i = 0; i < n; i++)
        cc[ii[i]] = i + 1 == n || cc[ii[i]] != cc[ii[i + 1]] ? m++ : m;
    for (int h = 0; h < n - 1; h++) {
        int i, j;
        scanf(""%d%d"", &i, &j);
        i--, j--;
        aa[i].push_back(j);
        aa[j].push_back(i);
    }
    dfs(-1, 0);
    sort(ii, ii + n, [] (int i, int j) { return ll[i] > ll[j]; });
    fill_n(jj, m, -1);
    for (int i_ = 0; i_ < n; i_++) {
        int i = ii[i_], c = cc[i], j = jj[c];
        if (j != -1)
            update(ll[j], n, -1);
        update(ll[i], n, 1);
        jj[c] = i;
        cc[i] = query(rr[i] - 1);
    }
    for (int i = 0; i < n; i++)
        printf(""%d "", cc[i]);
    printf(""\n"");
    return 0;
}
"
Distinct Colors,C++,"/*
 Distinct Colors
 https://cses.fi/problemset/task/1139
 practice with Dukkha
 */
#include <stdio.h>
#include <stdlib.h>

#define N    500000

struct L {
    struct L *next;
    int j;
} aa[N];

int cc[N], ii[N], jj[N], ll[N], rr[N], tt[N];

int compare_c(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return cc[i] - cc[j];
}

int compare_l(const void *a, const void *b) {
    int i = *(int *) a;
    int j = *(int *) b;
    
    return ll[j] - ll[i];
}

void link(int i, int j) {
    static struct L l91[N * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

void dfs(int p, int i) {
    static int t;
    struct L *l;
    
    ll[i] = t++;
    for (l = aa[i].next; l; l = l->next)
        if (l->j != p)
            dfs(i, l->j);
    rr[i] = t;
}

void update(int i, int n, int x) {
    while (i < n) {
        tt[i] += x;
        i |= i + 1;
    }
}

int query(int i) {
    int ans = 0;
    
    while (i >= 0) {
        ans += tt[i];
        i &= i + 1;
        i--;
    }
    return ans;
}

int main() {
    int n, m, h, i, i_, j, c;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++) {
        scanf(""%d"", &cc[i]);
        ii[i] = i;
    }
    qsort(ii, n, sizeof *ii, compare_c);
    for (i = 0, m = 0; i < n; i++)
        cc[ii[i]] = i + 1 == n || cc[ii[i]] != cc[ii[i + 1]] ? m++ : m;
    for (h = 0; h < n - 1; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), link(j, i);
    }
    dfs(-1, 0);
    qsort(ii, n, sizeof *ii, compare_l);
    for (i = 0; i < m; i++)
        jj[i] = -1;
    for (i_ = 0; i_ < n; i_++) {
        i = ii[i_], c = cc[i], j = jj[c];
        if (j != -1)
            update(ll[j], n, -1);
        update(ll[i], n, 1);
        jj[c] = i;
        cc[i] = query(rr[i] - 1);
    }
    for (i = 0; i < n; i++)
        printf(""%d "", cc[i]);
    printf(""\n"");
    return 0;
}
"
Path Queries,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

vector<vi> graph;

template<class T, int SZ> struct BIT {
    T bit[SZ+1];
    
    BIT() { memset(bit,0,sizeof bit); }
    
    void upd(int k, T val) { // add val to index k
        for( ;k <= SZ; k += (k&-k)) bit[k] += val;
    }
    
    T query(int k) {
        T temp = 0;
        for (;k > 0;k -= (k&-k)) temp += bit[k];
        return temp;
    }
    T query(int l, int r) { return query(r)-query(l-1); } // range query [l,r]
};

template <int V> struct HeavyLight { // sum queries, sum updates
    int parent[V], heavy[V], depth[V];
    int root[V], treePos[V];
    BIT<ll,V> tree;
    
    void init() {
        int n = graph.size();
        FOR(i,1,n+1) heavy[i] = -1;
        parent[1] = -1, depth[1] = 0;
        dfs(1);
        for (int i = 1, currentPos = 0; i <= n; ++i)
            if (parent[i] == -1 || heavy[parent[i]] != i)
                for (int j = i; j != -1; j = heavy[j]) {
                    root[j] = i;
                    treePos[j] = ++currentPos;
                }
    }
    
    int dfs(int v) {
        int size = 1, maxSubtree = 0;
        for (auto u : graph[v]) if (u != parent[v]) {
            parent[u] = v;
            depth[u] = depth[v] + 1;
            int subtree = dfs(u);
            if (subtree > maxSubtree) heavy[v] = u, maxSubtree = subtree;
            size += subtree;
        }
        return size;
    }
    
    template <class BinaryOperation>
    void processPath(int u, int v, BinaryOperation op) {
        for (; root[u] != root[v]; v = parent[root[v]]) {
            if (depth[root[u]] > depth[root[v]]) swap(u, v);
            op(treePos[root[v]], treePos[v]);
        }
        if (depth[u] > depth[v]) swap(u, v);
        op(treePos[u], treePos[v]); // assumes values are stored in edges, not vertices
    }
    
    void modifyPath(int u, int value) {
        u = treePos[u];
        tree.upd(u,value-tree.query(u,u));
    }
    
    ll queryPath(int u, int v) {
        ll res = 0;
        processPath(u, v, [this, &res](int l, int r) { res += tree.query(l, r); });
        return res;
    }
};

HeavyLight<1<<18> H;
int N,Q, v[1<<18];

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> N >> Q;
    FOR(i,1,N+1) cin >> v[i];
    graph.resize(N+1);
    F0R(i,N-1) {
        int a,b; cin >> a >> b;
        graph[a].pb(b), graph[b].pb(a);
    }
    H.init();
    FOR(i,1,N+1) H.modifyPath(i,v[i]);
    F0R(i,Q) {
        int t; cin >> t;
        if (t == 1) {
            int s,x; cin >> s >> x;
            H.modifyPath(s,x);
        } else {
            int s; cin >> s;
            cout << H.queryPath(1,s) << ""\n"";
        }
    }
}
"
Path Queries,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

struct Tree {
    typedef ll T;
    static constexpr T unit = 0;
    T f(T a, T b) { return a+b; } // (any associative fn)
    vector<T> s; int n;
    Tree(int n = 0, T def = unit) : s(2*n, def), n(n) {}
    void update(int pos, T val) {
        for (s[pos += n] = val; pos /= 2;)
            s[pos] = f(s[pos * 2], s[pos * 2 + 1]);
    }
    T query(int b, int e) { // query [b, e)
        T ra = unit, rb = unit;
        for (b += n, e += n; b < e; b /= 2, e /= 2) {
            if (b % 2) ra = f(ra, s[b++]);
            if (e % 2) rb = f(s[--e], rb);
        }
        return f(ra, rb);
    }
};

typedef vector<pii> vpi;

struct Node {
    int d, par, val, chain = -1, pos = -1;
};

struct Chain {
    int par, val;
    vector<int> nodes;
    Tree tree;
};

struct HLD {
    typedef ll T;
    const T LOW = 0;
    void f(T& a, T b) { a += b; }
    
    vector<Node> V;
    vector<Chain> C;
    
    HLD(vector<vpi>& g) : V(sz(g)) {
        dfs(0, -1, g, 0);
        trav(c, C) {
            c.tree = {sz(c.nodes), 0};
            for (int ni : c.nodes)
                c.tree.update(V[ni].pos, V[ni].val);
        }
    }
    
    void update(int node, T val) {
        Node& n = V[node]; n.val = val;
        if (n.chain != -1) C[n.chain].tree.update(n.pos, val);
    }
    
    int pard(Node& nod) {
        if (nod.par == -1) return -1;
        return V[nod.chain == -1 ? nod.par : C[nod.chain].par].d;
    }
    
    // query all *edges* between n1, n2
    pair<T, int> query(int i1, int i2) {
        T ans = LOW;
        while(i1 != i2) {
            Node n1 = V[i1], n2 = V[i2];
            if (n1.chain != -1 && n1.chain == n2.chain) {
                int lo = n1.pos, hi = n2.pos;
                if (lo > hi) swap(lo, hi);
                f(ans, C[n1.chain].tree.query(lo, hi));
                i1 = i2 = C[n1.chain].nodes[hi];
            } else {
                if (pard(n1) < pard(n2))
                    n1 = n2, swap(i1, i2);
                if (n1.chain == -1)
                    f(ans, n1.val), i1 = n1.par;
                else {
                    Chain& c = C[n1.chain];
                    f(ans, n1.pos ? c.tree.query(n1.pos, sz(c.nodes))
                      : c.tree.s[1]);
                    i1 = c.par;
                }
            }
        }
        return make_pair(ans, i1);
    }
    
    // query all *nodes* between n1, n2
    pair<T, int> query2(int i1, int i2) {
        pair<T, int> ans = query(i1, i2);
        f(ans.first, V[ans.second].val);
        return ans;
    }
    
    pii dfs(int at, int par, vector<vpi>& g, int d) {
        V[at].d = d; V[at].par = par;
        int sum = 1, ch, nod, sz;
        tuple<int,int,int> mx(-1,-1,-1);
        trav(e, g[at]){
            if (e.first == par) continue;
            tie(sz, ch) = dfs(e.first, at, g, d+1);
            V[e.first].val = e.second;
            sum += sz;
            mx = max(mx, make_tuple(sz, e.first, ch));
        }
        tie(sz, nod, ch) = mx;
        if (2*sz < sum) return pii(sum, -1);
        if (ch == -1) { ch = sz(C); C.emplace_back(); }
        V[nod].pos = sz(C[ch].nodes);
        V[nod].chain = ch;
        C[ch].par = at;
        C[ch].nodes.push_back(nod);
        return pii(sum, ch);
    }
};

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    vi v(n);
    rep(i, 0, n) cin >> v[i];
    vector<vpi> g(n);
    rep(i, 0, n-1) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        g[a].push_back({b, 0});
        g[b].push_back({a, 0});
    }
    HLD hld(g);
    rep(i, 0, n) hld.update(i, v[i]);
    while (q--) {
        int type, a, b;
        cin >> type >> a;
        a--;
        if (type==1) {
            cin >> b;
            hld.update(a, v[a]=b);
        }
        else cout << hld.query2(a, 0).first << '\n';
    }
    return 0;
}
"
Path Queries,C++,"/*
 https://cses.fi/problemset/task/1138
 Path Queries
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000

struct L {
    struct L *next;
    int j;
} aa[N];

int xx[N], ll[N], rr[N];
long long tt[N];

void link(int i, int j) {
    static struct L ll_[N * 2], *l = ll_;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

void dfs(int p, int i) {
    static int t;
    struct L *l;
    
    ll[i] = t++;
    for (l = aa[i].next; l; l = l->next)
        if (l->j != p)
            dfs(i, l->j);
    rr[i] = t;
}

void update(int i, int n, int x) {
    while (i < n) {
        tt[i] += x;
        i |= i + 1;
    }
}

long long query(int i) {
    long long sum = 0;
    
    while (i >= 0) {
        sum += tt[i];
        i &= i + 1;
        i--;
    }
    return sum;
}

int main() {
    static int xx[N];
    int n, q, h, i, j;
    
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++)
        scanf(""%d"", &xx[i]);
    for (h = 0; h < n - 1; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), link(j, i);
    }
    dfs(-1, 0);
    for (i = 0; i < n; i++) {
        update(ll[i], n, xx[i]);
        update(rr[i], n, -xx[i]);
    }
    while (q--) {
        int t, i, x;
        
        scanf(""%d%d"", &t, &i), i--;
        if (t == 1) {
            scanf(""%d"", &x);
            update(ll[i], n, x - xx[i]);
            update(rr[i], n, xx[i] - x);
            xx[i] = x;
        } else
            printf(""%lld\n"", query(ll[i]));
    }
    return 0;
}
"
Path Queries,C++,"/*
 https://cses.fi/problemset/task/1138
 Path Queries
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000

struct L {
    struct L *next;
    int j;
} aa[N];

int xx[N], ll[N], rr[N];
long long tt[N];

void link(int i, int j) {
    static struct L ll_[N * 2], *l = ll_;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

void dfs(int p, int i) {
    static int t;
    struct L *l;
    
    ll[i] = t++;
    for (l = aa[i].next; l; l = l->next)
        if (l->j != p)
            dfs(i, l->j);
    rr[i] = t;
}

void update(int i, int n, int x) {
    while (i < n) {
        tt[i] += x;
        i |= i + 1;
    }
}

long long query(int i) {
    long long sum = 0;
    
    while (i >= 0) {
        sum += tt[i];
        i &= i + 1;
        i--;
    }
    return sum;
}

int main() {
    static int xx[N];
    int n, q, h, i, j;
    
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++)
        scanf(""%d"", &xx[i]);
    for (h = 0; h < n - 1; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), link(j, i);
    }
    dfs(-1, 0);
    for (i = 0; i < n; i++) {
        update(ll[i], n, xx[i]);
        update(rr[i], n, -xx[i]);
    }
    while (q--) {
        int t, i, x;
        
        scanf(""%d%d"", &t, &i), i--;
        if (t == 1) {
            scanf(""%d"", &x);
            update(ll[i], n, x - xx[i]);
            update(rr[i], n, xx[i] - x);
            xx[i] = x;
        } else
            printf(""%lld\n"", query(ll[i]));
    }
    return 0;
}
"
Subordinates,C++,"/*
 ID: bqi3431
 PROG: ~
 LANG: C++11
 */

#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>

using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;

typedef long long ll;
typedef long double ld;
typedef complex<ld> cd;

typedef pair<int, int> pi;
typedef pair<ll,ll> pl;
typedef pair<ld,ld> pd;

typedef vector<int> vi;
typedef vector<ld> vd;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<cd> vcd;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound

#define sz(x) (int)x.size()
#define beg(x) x.begin()
#define en(x) x.end()
#define all(x) beg(x), en(x)
#define resz resize

const int MOD = 1000000007; // 998244353
const ll INF = 1e18;
const int MX = 200005;
const ld PI = 4*atan((ld)1);

template<class T> void ckmin(T &a, T b) { a = min(a, b); }
template<class T> void ckmax(T &a, T b) { a = max(a, b); }

namespace input {
    template<class T> void re(complex<T>& x);
    template<class T1, class T2> void re(pair<T1,T2>& p);
    template<class T> void re(vector<T>& a);
    template<class T, size_t SZ> void re(array<T,SZ>& a);
    
    template<class T> void re(T& x) { cin >> x; }
    void re(double& x) { string t; re(t); x = stod(t); }
    void re(ld& x) { string t; re(t); x = stold(t); }
    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {
        re(first); re(rest...);
    }
    
    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }
    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }
    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }
    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }
}

using namespace input;

namespace output {
    template<class T1, class T2> void pr(const pair<T1,T2>& x);
    template<class T, size_t SZ> void pr(const array<T,SZ>& x);
    template<class T> void pr(const vector<T>& x);
    template<class T> void pr(const set<T>& x);
    template<class T1, class T2> void pr(const map<T1,T2>& x);
    
    template<class T> void pr(const T& x) { cout << x; }
    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {
        pr(first); pr(rest...);
    }
    
    template<class T1, class T2> void pr(const pair<T1,T2>& x) {
        pr(""{"",x.f,"", "",x.s,""}"");
    }
    template<class T> void prContain(const T& x) {
        pr(""{"");
        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>
        pr(""}"");
    }
    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }
    template<class T> void pr(const vector<T>& x) { prContain(x); }
    template<class T> void pr(const set<T>& x) { prContain(x); }
    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }
    
    void ps() { pr(""\n""); }
    template<class Arg> void ps(const Arg& first) {
        pr(first); ps(); // no space at end of line
    }
    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {
        pr(first,"" ""); ps(rest...); // print w/ spaces
    }
}

using namespace output;

namespace io {
    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
    void setIO(string s = """") {
        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O
        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
    }
}

using namespace io;

template<class T> T invGeneral(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = invGeneral(b,a);
    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;
}

template<class T> struct modular {
    T val;
    explicit operator T() const { return val; }
    modular() { val = 0; }
    template<class U> modular(const U& v) {
        val = (-MOD <= v && v <= MOD) ? v : v % MOD;
        if (val < 0) val += MOD;
    }
    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }
    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }
    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }
    
    modular operator-() const { return modular(-val); }
    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }
    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }
    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }
    friend modular exp(modular a, ll p) {
        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); }
    // inv is equivalent to return exp(b,b.mod-2) if prime
    modular& operator/=(const modular& m) { return (*this) *= inv(m); }
    
    friend modular operator+(modular a, const modular& b) { return a += b; }
    friend modular operator-(modular a, const modular& b) { return a -= b; }
    friend modular operator*(modular a, const modular& b) { return a *= b; }
    
    friend modular operator/(modular a, const modular& b) { return a /= b; }
};

typedef modular<int> mi;
typedef pair<mi,mi> pmi;
typedef vector<mi> vmi;
typedef vector<pmi> vpmi;

int n,p[MX],ans[MX];
vi child[MX];

void dfs(int x) {
    ans[x] = 1;
    trav(t,child[x]) {
        dfs(t);
        ans[x] += ans[t];
    }
}

int main() {
    setIO(); re(n);
    FOR(i,2,n+1) {
        re(p[i]);
        child[p[i]].pb(i);
    }
    dfs(1);
    FOR(i,1,n+1) pr(ans[i]-1,' ');
    // you should actually read the stuff at the bottom
}

/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?), set tle
 * do smth instead of nothing and stay organized
 */
"
Subordinates,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vi s;
vector<vi> g;

void dfs(int i, int p) {
    s[i]++;
    trav(j, g[i]) if (j!=p) {
        dfs(j, i);
        s[i]+=s[j];
    }
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    g.resize(n+1);
    s.resize(n+1);
    rep(i, 2, n+1) {
        int a;
        cin >> a;
        g[a].push_back(i);
        g[i].push_back(a);
    }
    dfs(1, 0);
    rep(i, 1, n+1)
    cout << s[i]-1 << "" \n""[i==n];
    return 0;
}
"
Subordinates,Java,"// https://cses.fi/problemset/task/1674
// Subordinates
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1674 {
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = sc.nextInt();
        int[] pp = new int[n + 1];
        int[] dd = new int[n + 1];
        for (int i = 2; i <= n; i++) {
            int p = sc.nextInt();
            pp[i] = p;
            dd[p]++;
        }
        int[] qq = new int[n + 1];
        int head = 0, cnt = 0;
        for (int i = 1; i <= n; i++)
            if (dd[i] == 0)
                qq[head + cnt++] = i;
        int[] aa = new int[n + 1];
        Arrays.fill(aa, 1);
        while (cnt > 0) {
            int i = qq[head++]; cnt--;
            int p = pp[i];
            aa[p] += aa[i];
            if (--dd[p] == 0)
                qq[head + cnt++] = p;
        }
        for (int i = 1; i <= n; i++)
            pw.print(aa[i] - 1 + "" "");
        pw.println();
        pw.close();
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Subordinates,C++,"/*
 https://cses.fi/problemset/task/1674
 Subordinates
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000

int main() {
    static int pp[N + 1], dd[N + 1], qq[N + 1], aa[N + 1];
    int n, p, i, head, cnt;
    
    scanf(""%d"", &n);
    for (i = 2; i <= n; i++) {
        scanf(""%d"", &p);
        pp[i] = p;
        dd[p]++;
    }
    head = cnt = 0;
    for (i = 1; i <= n; i++)
        if (dd[i] == 0)
            qq[head + cnt++] = i;
    for (i = 1; i <= n; i++)
        aa[i] = 1;
    while (cnt) {
        i = qq[cnt--, head++];
        p = pp[i];
        aa[p] += aa[i];
        if (--dd[p] == 0)
            qq[head + cnt++] = p;
    }
    for (i = 1; i <= n; i++)
        printf(""%d "", aa[i] - 1);
    printf(""\n"");
    return 0;
}
"
Subtree Queries,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;

template<class T, int SZ> struct Seg {
    T seg[2*SZ], MN = 0;
    
    Seg() {
        memset(seg,0,sizeof seg);
    }
    
    T comb(T a, T b) { return a+b; } // easily change this to min or max
    
    void upd(int p, T value) {  // set value at position p
        for (seg[p += SZ] = value; p > 1; p >>= 1){
            //be careful here: some updates are noncommutative!
            if (p < (p^1)){
                seg[p>>1] = comb(seg[p],seg[p^1]);
            }
            else{
                seg[p>>1] = comb(seg[p^1], seg[p]);
            }
        }
    }
    
    void build() {
        F0Rd(i,SZ) seg[i] = comb(seg[2*i],seg[2*i+1]);
    }
    
    T query(int l, int r) {  // sum on interval [l, r]
        T res = MN; r++;
        for (l += SZ, r += SZ; l < r; l >>= 1, r >>= 1) {
            if (l&1) res = comb(res,seg[l++]);
            if (r&1) res = comb(res,seg[--r]);
        }
        return res;
    }
};

Seg<ll,1<<18> S;
vi adj[200001];
int n,q, nex, v[200001];
pii res[200001];

void dfs(int pre, int cur) {
    res[cur].f = nex++;
    for (int i: adj[cur]) if (i != pre) dfs(cur,i);
    res[cur].s = nex-1;
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> q;
    FOR(i,1,n+1) cin >> v[i];
    F0R(i,n-1) {
        int a,b; cin >> a >> b;
        adj[a].pb(b), adj[b].pb(a);
    }
    dfs(0,1);
    FOR(i,1,n+1) S.upd(res[i].f,v[i]);
    F0R(i,q) {
        int t; cin >> t;
        if (t == 1) {
            int s,x; cin >> s >> x;
            S.upd(res[s].f,x);
        } else {
            int s; cin >> s;
            cout << S.query(res[s].f,res[s].s) << ""\n"";
        }
    }
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Subtree Queries,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

struct Tree {
    typedef ll T;
    static constexpr T unit = 0;
    T f(T a, T b) { return a+b; } // (any associative fn)
    vector<T> s; int n;
    Tree(int n = 0, T def = unit) : s(2*n, def), n(n) {}
    void update(int pos, T val) {
        for (s[pos += n] = val; pos /= 2;)
            s[pos] = f(s[pos * 2], s[pos * 2 + 1]);
    }
    T query(int b, int e) { // query [b, e)
        T ra = unit, rb = unit;
        for (b += n, e += n; b < e; b /= 2, e /= 2) {
            if (b % 2) ra = f(ra, s[b++]);
            if (e % 2) rb = f(s[--e], rb);
        }
        return f(ra, rb);
    }
};

int ct=0;
vector<vi> g;
vi L, R;

void dfs(int i, int p) {
    L[i]=ct++;
    trav(j, g[i])
    if(j!=p) dfs(j, i);
    R[i]=ct;
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n, q;
    cin >> n >> q;
    vi v(n);
    rep(i, 0, n) cin >> v[i];
    g.resize(n);
    rep(i, 0, n-1) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    L.resize(n);
    R.resize(n);
    dfs(0, -1);
    Tree t(n);
    rep(i, 0, n) t.update(L[i], v[i]);
    while (q--) {
        int type;
        cin >> type;
        if (type==1) {
            int a, b;
            cin >> a >> b;
            a--;
            t.update(L[a], b);
        }
        else {
            int a;
            cin >> a;
            a--;
            cout << t.query(L[a], R[a]) << '\n';
        }
    }
    return 0;
}
"
Subtree Queries,C++,"// https://cses.fi/problemset/task/1137
// Subtree Queries
// practice with rainboy
#include <iostream>
#include <vector>

using namespace std;

const int N = 200000;

vector<int> aa[N];

int xx[N], ll[N], rr[N];
long long tt[N];

void dfs(int p, int i) {
    static int t;
    ll[i] = t++;
    for (int j : aa[i])
        if (j != p)
            dfs(i, j);
    rr[i] = t;
}

void update(int i, int n, long long x) {
    while (i < n) {
        tt[i] += x;
        i |= i + 1;
    }
}

long long query(int i) {
    long long sum = 0;
    while (i >= 0) {
        sum += tt[i];
        i &= i + 1;
        i--;
    }
    return sum;
}

int main() {
    int n, q;
    scanf(""%d%d"", &n, &q);
    for (int i = 0; i < n; i++)
        scanf(""%d"", &xx[i]);
    for (int h = 0; h < n - 1; h++) {
        int i, j;
        scanf(""%d%d"", &i, &j);
        i--, j--;
        aa[i].push_back(j);
        aa[j].push_back(i);
    }
    dfs(-1, 0);
    for (int i = 0; i < n; i++)
        update(ll[i], n, xx[i]);
    while (q--) {
        int t, i, x;
        scanf(""%d%d"", &t, &i);
        i--;
        if (t == 1) {
            scanf(""%d"", &x);
            update(ll[i], n, x - xx[i]);
            xx[i] = x;
        } else
            printf(""%lld\n"", query(rr[i] - 1) - query(ll[i] - 1));
    }
    return 0;
}
"
Subtree Queries,C++,"/*
 https://cses.fi/problemset/task/1137
 Subtree Queries
 practice with Dukkha
 */
#include <stdio.h>

#define N    200000

struct L {
    struct L *next;
    int j;
} aa[N];

int xx[N], ll[N], rr[N];
long long tt[N];

void link(int i, int j) {
    static struct L l91[N * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

void dfs(int p, int i) {
    static int t;
    struct L *l;
    
    ll[i] = t++;
    for (l = aa[i].next; l; l = l->next)
        if (l->j != p)
            dfs(i, l->j);
    rr[i] = t;
}

void update(int i, int n, long long x) {
    while (i < n) {
        tt[i] += x;
        i |= i + 1;
    }
}

long long query(int i) {
    long long sum = 0;
    
    while (i >= 0) {
        sum += tt[i];
        i &= i + 1;
        i--;
    }
    return sum;
}

int main() {
    int n, q, h, i, j;
    
    scanf(""%d%d"", &n, &q);
    for (i = 0; i < n; i++)
        scanf(""%d"", &xx[i]);
    for (h = 0; h < n - 1; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), link(j, i);
    }
    dfs(-1, 0);
    for (i = 0; i < n; i++)
        update(ll[i], n, xx[i]);
    while (q--) {
        int t, i, x;
        
        scanf(""%d%d"", &t, &i), i--;
        if (t == 1) {
            scanf(""%d"", &x);
            update(ll[i], n, x - xx[i]);
            xx[i] = x;
        } else
            printf(""%lld\n"", query(rr[i] - 1) - query(ll[i] - 1));
    }
    return 0;
}
"
Tree Diameter,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;
const int MX = 500001;

int n, dist[MX];
vi adj[MX];

void dfs(int cur, int pre) {
    for (int i: adj[cur]) if (i != pre) {
        dist[i] = dist[cur]+1;
        dfs(i,cur);
    }
}

void dfs(int cur) {
    memset(dist,0,sizeof dist);
    dfs(cur,-1);
}

int treeDiameter() {
    dfs(1);
    int bes = 0; FOR(i,1,n+1) if (dist[i] > dist[bes]) bes = i;
    dfs(bes); FOR(i,1,n+1) if (dist[i] > dist[bes]) bes = i;
    return dist[bes];
}

int main() {
    cin >> n;
    F0R(i,n-1) {
        int a, b; cin >> a >> b;
        adj[a].pb(b), adj[b].pb(a);
    }
    cout << treeDiameter();
}
"
Tree Diameter,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    vector<vi> g(n+1);
    rep(i, 0, n-1) {
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    vi d(n+1), deg(n+1);
    queue<int> q;
    rep(i, 1, n+1) if ((deg[i]=sz(g[i]))<=1)
        d[i]=1, q.push(i);
    for(; !q.empty(); q.pop())  {
        int i=q.front();
        trav(j, g[i]) if (--deg[j]==1)
            d[j]=d[i]+1, q.push(j);
    }
    int r=*max_element(all(d));
    int c=count(all(d), r);
    cout << 2*(r-1)+(c>1) << '\n';
    return 0;
}
"
Tree Diameter,Java,"// https://cses.fi/problemset/task/1131
// Tree Diameter
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1131 {
    static ArrayList[] aa;
    static int d_, i_;
    static void dfs(int p, int i, int d) {
        if (d_ < d) {
            d_ = d;
            i_ = i;
        }
        ArrayList<Integer> adj = aa[i];
        for (int j : adj)
            if (j != p)
                dfs(i, j, d + 1);
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        for (int h = 0; h < n - 1; h++) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            aa[i].add(j);
            aa[j].add(i);
        }
        dfs(-1, 0, 0);
        dfs(-1, i_, 0);
        System.out.println(d_);
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb); //if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        String next() throws IOException {
            StringBuilder sb = new StringBuilder();
            for (byte b = skip(); b > 32; b = getc())
                sb.append((char) b);
            return sb.toString();
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Tree Diameter,C++,"// https://cses.fi/problemset/task/1131
// Tree Diameter
// practice with rainboy
#include <iostream>
#include <vector>

using namespace std;

const int N = 500000;

vector<int> aa[N];

int d_, i_;

void dfs(int p, int i, int d) {
    if (d_ < d) {
        d_ = d;
        i_ = i;
    }
    auto &adj = aa[i];
    for (int j : adj)
        if (j != p)
            dfs(i, j, d + 1);
}

int main() {
    int n;
    scanf(""%d"", &n);
    for (int h = 0; h < n - 1; h++) {
        int i, j;
        scanf(""%d%d"", &i, &j);
        i--, j--;
        aa[i].push_back(j);
        aa[j].push_back(i);
    }
    dfs(-1, 0, 0);
    dfs(-1, i_, 0);
    printf(""%d\n"", d_);
}
"
Tree Diameter,Java,"// https://cses.fi/problemset/task/1131
// Tree Diameter
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1131 {
    static ArrayList[] aa;
    static int d_, i_;
    static void dfs(int p, int i, int d) {
        if (d_ < d) {
            d_ = d;
            i_ = i;
        }
        ArrayList<Integer> adj = aa[i];
        for (int j : adj)
            if (j != p)
                dfs(i, j, d + 1);
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        aa = new ArrayList[n];
        for (int i = 0; i < n; i++)
            aa[i] = new ArrayList<Integer>();
        for (int h = 0; h < n - 1; h++) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            aa[i].add(j);
            aa[j].add(i);
        }
        dfs(-1, 0, 0);
        dfs(-1, i_, 0);
        System.out.println(d_);
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Tree Diameter,C++,"/*
 https://cses.fi/problemset/task/1131
 Tree Diameter
 practice with Dukkha
 */
#include <stdio.h>

#define N    500000

struct L {
    struct L *next;
    int j;
};

struct V {
    struct L adj;
} vv[N];

void link(int i, int j) {
    static struct L l91[N * 2], *l = l91;
    
    l->j = j;
    l->next = vv[i].adj.next; vv[i].adj.next = l++;
}

int i_, d_;

void dfs(int p, int i, int d) {
    struct L *l;
    
    if (d_ < d)
        i_ = i, d_ = d;
    for (l = vv[i].adj.next; l; l = l->next)
        if (l->j != p)
            dfs(i, l->j, d + 1);
}

int main() {
    int n, h, i, j;
    
    scanf(""%d"", &n);
    for (h = 0; h < n - 1; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), link(j, i);
    }
    dfs(-1, 0, 0);
    dfs(-1, i_, 0);
    printf(""%d\n"", d_);
    return 0;
}
"
Tree Diameter,C++,"/*
 https://cses.fi/problemset/task/1131
 Tree Diameter
 practice with Dukkha
 */
#include <stdio.h>

#define N    500000

struct L {
    struct L *next;
    int j;
} aa[N];

void link(int i, int j) {
    static struct L l91[N * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

int i_, d_;

void dfs(int p, int i, int d) {
    struct L *l;
    
    if (d_ < d)
        i_ = i, d_ = d;
    for (l = aa[i].next; l; l = l->next)
        if (l->j != p)
            dfs(i, l->j, d + 1);
}

int main() {
    int n, h, i, j;
    
    scanf(""%d"", &n);
    for (h = 0; h < n - 1; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), link(j, i);
    }
    dfs(-1, 0, 0);
    dfs(-1, i_, 0);
    printf(""%d\n"", d_);
    return 0;
}
"
Tree Distances I,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;
const int MX = 500001;

int n, dist[MX], ans[MX];
vi adj[MX];

void dfs(int cur, int pre) {
    for (int i: adj[cur]) if (i != pre) {
        dist[i] = dist[cur]+1;
        dfs(i,cur);
    }
}

void dfs(int cur) {
    memset(dist,0,sizeof dist);
    dfs(cur,-1);
}

void treeDiameter() {
    dfs(1);
    int bes = 0; FOR(i,1,n+1) if (dist[i] > dist[bes]) bes = i;
    dfs(bes); FOR(i,1,n+1) ans[i] = dist[i];
    FOR(i,1,n+1) if (dist[i] > dist[bes]) bes = i;
    dfs(bes); FOR(i,1,n+1) ans[i] = max(ans[i],dist[i]);
}

int main() {
    cin >> n;
    F0R(i,n-1) {
        int a, b; cin >> a >> b;
        adj[a].pb(b), adj[b].pb(a);
    }
    treeDiameter();
    FOR(i,1,n+1) cout << ans[i] << "" "";
}
"
Tree Distances I,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;
const int MX = 500001;

int n, dist[MX], ans[MX];
vi adj[MX];

void dfs(int cur, int pre) {
    for (int i: adj[cur]) if (i != pre) {
        dist[i] = dist[cur]+1;
        dfs(i,cur);
    }
}

void dfs(int cur) {
    memset(dist,0,sizeof dist);
    dfs(cur,-1);
}

void treeDiameter() {
    dfs(1);
    int bes = 0; FOR(i,1,n+1) if (dist[i] > dist[bes]) bes = i;
    dfs(bes); FOR(i,1,n+1) ans[i] = dist[i];
    FOR(i,1,n+1) if (dist[i] > dist[bes]) bes = i;
    dfs(bes); FOR(i,1,n+1) ans[i] = max(ans[i],dist[i]);
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n;
    F0R(i,n-1) {
        int a, b; cin >> a >> b;
        adj[a].pb(b), adj[b].pb(a);
    }
    treeDiameter();
    FOR(i,1,n+1) cout << ans[i] << "" "";
}
"
Tree Distances I,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vector<vi> g;
vector<pii> d1, d2;
vi ans;

void dfs1(int i, int p) {
    trav(j, g[i]) if (j!=p) {
        dfs1(j, i);
        d2[i]=max(d2[i], {1+d1[j].first, j});
        if (d2[i]>d1[i]) swap(d1[i], d2[i]);
    }
}

void dfs2(int i, int p, int d) {
    ans[i]=max(d1[i].first, d);
    trav(j, g[i]) if (j!=p) {
        if (j==d1[i].second)
            dfs2(j, i, 1+max(d2[i].first, d));
        else dfs2(j, i, 1+ans[i]);
    }
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    g.resize(n+1);
    d1.resize(n+1);
    d2.resize(n+1);
    ans.resize(n+1);
    rep(i, 0, n-1) {
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    dfs1(1, 0);
    dfs2(1, 0, 0);
    rep(i, 1, n+1)
    cout << ans[i] << "" \n""[i==n];
    return 0;
}
"
Tree Distances I,C++,"// https://cses.fi/problemset/task/1132
// Tree Distances
// practice with rainboy
#include <iostream>
#include <vector>

using namespace std;

const int N = 500000;

struct V {
    vector<int> adj;
    int d1, d2;
} vv[N];

void dfs1(int p, int i) {
    V &u = vv[i];
    int d1 = -1, d2 = -1;
    for (int j : u.adj)
        if (j != p) {
            dfs1(i, j);
            int d = vv[j].d1;
            if (d1 < d) {
                d2 = d1; d1 = d;
            } else if (d2 < d)
                d2 = d;
        }
    u.d1 = d1 + 1;
    u.d2 = d2 + 1;
}

void dfs2(int p, int i, int d_) {
    V &u = vv[i];
    int d1_ = max(d_, u.d1);
    int d2_ = max(d_, u.d2);
    for (int j : u.adj)
        if (j != p) {
            V &v = vv[j];
            dfs2(i, j, (v.d1 + 1 == u.d1 ? d2_ : d1_) + 1);
        }
    u.d1 = d1_;
}

int main() {
    int n;
    scanf(""%d"", &n);
    for (int h = 0; h < n - 1; h++) {
        int i, j;
        scanf(""%d%d"", &i, &j); i--, j--;
        vv[i].adj.push_back(j);
        vv[j].adj.push_back(i);
    }
    dfs1(-1, 0);
    dfs2(-1, 0, 0);
    for (int i = 0; i < n; i++)
        printf(""%d "", vv[i].d1);
    printf(""\n"");
}
"
Tree Distances I,Java,"// https://cses.fi/problemset/task/1132
// Tree Distances
// practice with rainboy
import java.io.*;
import java.util.*;

public class CSES1132 {
    static class V {
        ArrayList<Integer> adj = new ArrayList<>();
        int d1, d2;
    }
    static V[] vv;
    static void dfs1(int p, int i) {
        V u = vv[i];
        int d1 = -1, d2 = -1;
        for (int j : u.adj)
            if (j != p) {
                dfs1(i, j);
                int d = vv[j].d1;
                if (d1 < d) {
                    d2 = d1; d1 = d;
                } else if (d2 < d)
                    d2 = d;
            }
        u.d1 = d1 + 1;
        u.d2 = d2 + 1;
    }
    static void dfs2(int p, int i, int d_) {
        V u = vv[i];
        int d1_ = Math.max(d_, u.d1);
        int d2_ = Math.max(d_, u.d2);
        for (int j : u.adj)
            if (j != p) {
                V v = vv[j];
                dfs2(i, j, (v.d1 + 1 == u.d1 ? d2_ : d1_) + 1);
            }
        u.d1 = d1_;
    }
    public static void main(String[] args) throws IOException {
        _Scanner sc = new _Scanner(System.in);
        int n = sc.nextInt();
        vv = new V[n];
        for (int i = 0; i < n; i++)
            vv[i] = new V();
        for (int h = 0; h < n - 1; h++) {
            int i = sc.nextInt() - 1;
            int j = sc.nextInt() - 1;
            vv[i].adj.add(j);
            vv[j].adj.add(i);
        }
        dfs1(-1, 0);
        dfs2(-1, 0, 0);
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++)
            sb.append(vv[i].d1 + "" "");
        System.out.println(sb);
    }
    static class _Scanner {
        InputStream is;
        _Scanner(InputStream is) {
            this.is = is;
        }
        byte[] bb = new byte[1 << 15];
        int k, l;
        byte getc() throws IOException {
            if (k >= l) {
                k = 0;
                l = is.read(bb);
                if (l < 0) return -1;
            }
            return bb[k++];
        }
        byte skip() throws IOException {
            byte b;
            while ((b = getc()) <= 32)
                ;
            return b;
        }
        int nextInt() throws IOException {
            int n = 0;
            for (byte b = skip(); b > 32; b = getc())
                n = n * 10 + b - '0';
            return n;
        }
    }
}
"
Tree Distances I,C++,"/*
 https://cses.fi/problemset/task/1132
 Tree Distances
 practice with Dukkha
 */
#include <stdio.h>

#define N    500000

int max(int a, int b) { return a > b ? a : b; }

struct L {
    struct L *next;
    int j;
};

struct V {
    struct L adj;
    int d1, d2;
} vv[N];

void link(int i, int j) {
    static struct L l91[N * 2], *l = l91;
    
    l->j = j;
    l->next = vv[i].adj.next; vv[i].adj.next = l++;
}

void dfs1(int p, int i) {
    struct V *u = &vv[i], *v;
    struct L *l;
    int d1, d2;
    
    d1 = d2 = -1;
    for (l = u->adj.next; l; l = l->next)
        if (l->j != p) {
            dfs1(i, l->j);
            v = &vv[l->j];
            if (d1 < v->d1)
                d2 = d1, d1 = v->d1;
            else if (d2 < v->d1)
                d2 = v->d1;
        }
    u->d1 = d1 + 1;
    u->d2 = d2 + 1;
}

void dfs2(int p, int i, int d_) {
    struct V *u = &vv[i], *v;
    struct L *l;
    int d1_, d2_;
    
    d1_ = max(d_, u->d1);
    d2_ = max(d_, u->d2);
    for (l = u->adj.next; l; l = l->next)
        if (l->j != p) {
            v = &vv[l->j];
            dfs2(i, l->j, (u->d1 == v->d1 + 1 ? d2_ : d1_) + 1);
        }
    u->d1 = d1_;
}

int main() {
    int n, h, i, j;
    
    scanf(""%d"", &n);
    for (h = 0; h < n - 1; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), link(j, i);
    }
    dfs1(-1, 0);
    dfs2(-1, 0, 0);
    for (i = 0; i < n; i++)
        printf(""%d "", vv[i].d1);
    printf(""\n"");
    return 0;
}
"
Tree Distances II,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;
const int MX = 500001;

int n, par[MX], sub[MX];
ll ans[MX];
vi adj[MX];

void dfs(int x) {
    sub[x] = 1;
    for (int i: adj[x]) if (i != par[x]) {
        par[i] = x;
        dfs(i);
        sub[x] += sub[i];
    }
}

void dfs2(int x, int dis = 0) {
    ans[1] += dis;
    for (int i: adj[x]) if (i != par[x]) dfs2(i,dis+1);
}

void dfs3(int x) {
    for (int i: adj[x]) if (i != par[x]) {
        ans[i] = ans[x]+(n-sub[i])-sub[i];
        dfs3(i);
    }
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n;
    F0R(i,n-1) {
        int a,b; cin >> a >> b;
        adj[a].pb(b), adj[b].pb(a);
    }
    dfs(1);
    dfs2(1);
    dfs3(1);
    FOR(i,1,n+1) cout << ans[i] << ""\n"";
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Tree Distances II,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

int n;
vector<vi> g;
vector<ll> s, d;

ll dfs1(int i, int p) {
    ll cd=0;
    s[i]++;
    trav(j, g[i]) if (j!=p) {
        cd+=dfs1(j, i)+s[j];
        s[i]+=s[j];
    }
    return cd;
}

void dfs2(int i, int p, ll cd) {
    d[i]=cd;
    trav(j, g[i]) if (j!=p)
        dfs2(j, i, cd+n-2*s[j]);
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    cin >> n;
    g.resize(n+1);
    rep(i, 0, n-1) {
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    s.resize(n+1);
    d.resize(n+1);
    ll d1=dfs1(1, 0);
    dfs2(1, 0, d1);
    rep(i, 1, n+1)
    cout << d[i] << "" \n""[i==n];
    return 0;
}
"
Tree Distances II,C++,"// https://cses.fi/problemset/task/1133
// Tree Distances II
// practice with rainboy
#include <iostream>
#include <vector>

using namespace std;

const int N = 500000;

vector<int> aa[N];
int kk[N], n;
long long dd[N];

void dfs1(int p, int i) {
    long long d = 0;
    int k = 0;
    for (int j : aa[i])
        if (j != p) {
            dfs1(i, j);
            d += dd[j];
            k += kk[j];
        }
    dd[i] = d + k;
    kk[i] = k + 1;
}

void dfs2(int p, int i, long long d) {
    dd[i] = d;
    for (int j : aa[i])
        if (j != p)
            dfs2(i, j, dd[i] - kk[j] + n - kk[j]);
}

int main() {
    scanf(""%d"", &n);
    for (int h = 0; h < n - 1; h++) {
        int i, j;
        scanf(""%d%d"", &i, &j);
        i--, j--;
        aa[i].push_back(j);
        aa[j].push_back(i);
    }
    dfs1(-1, 0);
    dfs2(-1, 0, dd[0]);
    for (int i = 0; i < n; i++)
        printf(""%lld "", dd[i]);
    printf(""\n"");
    return 0;
}
"
Tree Distances II,C++,"/*
 https://cses.fi/problemset/task/1133
 Tree Distances II
 practice with Dukkha
 */
#include <stdio.h>

#define N    500000

int n;

struct L {
    struct L *next;
    int j;
} aa[N];

int kk[N];
long long dd[N];

void link(int i, int j) {
    static struct L l91[N * 2], *l = l91;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

void dfs1(int p, int i) {
    struct L *l;
    long long d;
    int j, k;
    
    d = 0;
    k = 0;
    for (l = aa[i].next; l; l = l->next)
        if ((j = l->j) != p) {
            dfs1(i, j);
            d += dd[j];
            k += kk[j];
        }
    dd[i] = d + k;
    kk[i] = k + 1;
}

void dfs2(int p, int i, long long d) {
    struct L *l;
    int j;
    
    dd[i] = d;
    for (l = aa[i].next; l; l = l->next)
        if ((j = l->j) != p)
            dfs2(i, j, dd[i] - kk[j] + n - kk[j]);
}

int main() {
    int h, i, j;
    
    scanf(""%d"", &n);
    for (h = 0; h < n - 1; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), link(j, i);
    }
    dfs1(-1, 0);
    dfs2(-1, 0, dd[0]);
    for (i = 0; i < n; i++)
        printf(""%lld "", dd[i]);
    printf(""\n"");
    return 0;
}
"
Tree Matching,C++,"#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

#define FOR(i, a, b) for (int i=a; i<(b); i++)
#define F0R(i, a) for (int i=0; i<(a); i++)
#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)
#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)

#define sz(x) (int)(x).size()
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()

const int MOD = 1000000007;
const int MX = 500001;

int n;
vi adj[MX];
int dp[MX][2];

void dfs(int pre, int cur) {
    for (int i: adj[cur]) if (i != pre) {
        dfs(cur,i);
        dp[cur][0] += max(dp[i][0],dp[i][1]);
    }
    for (int i: adj[cur]) if (i != pre)
        dp[cur][1] = max(dp[cur][1],dp[cur][0]-max(dp[i][0],dp[i][1])+dp[i][0]+1);
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n;
    F0R(i,n-1) {
        int a,b; cin >> a >> b;
        adj[a].pb(b), adj[b].pb(a);
    }
    dfs(0,1);
    cout << max(dp[1][0],dp[1][1]);
}

// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!
// ll vs. int!
"
Tree Matching,C++,"#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

vector<vi> g;
vi u;

void dfs(int i, int p) {
    u[i]=1;
    trav(j, g[i]) if (j!=p) {
        dfs(j, i);
        u[i]&=!u[j];
    }
}

int main() {
    cin.sync_with_stdio(0); cin.tie(0);
    cin.exceptions(cin.failbit);
    
    int n;
    cin >> n;
    g.resize(n+1);
    rep(i, 0, n-1) {
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    u.resize(n+1);
    dfs(1, 0);
    cout << n-accumulate(all(u), 0) << '\n';
    return 0;
}
"
Tree Matching,C++,"// https://cses.fi/problemset/task/1130
// Tree Matching
// practice with rainboy
#include <iostream>
#include <vector>

using namespace std;

const int N = 500000;

vector<int> aa[N];

int dp[N], dp1[N];

void dfs(int p, int i) {
    int x0 = 0, x1 = 1;
    auto &adj = aa[i];
    for (int j : adj)
        if (j != p) {
            dfs(i, j);
            x0 += dp1[j];
            x1 += dp[j];
        }
    dp1[i] = x1;
    dp[i] = min(x0, x1);
}
int main() {
    int n;
    scanf(""%d"", &n);
    for (int h = 0; h < n - 1; h++) {
        int i, j;
        scanf(""%d%d"", &i, &j);
        i--, j--;
        aa[i].push_back(j);
        aa[j].push_back(i);
    }
    dfs(-1, 0);
    printf(""%d\n"", dp[0]);
}
"
Tree Matching,C++,"/*
 https://cses.fi/problemset/task/1130
 Tree Matching
 practice with Dukkha
 */
#include <stdio.h>

#define N    500000

struct L {
    struct L *next;
    int j;
} aa[N];

int dp[N], dp1[N];

void link(int i, int j) {
    static struct L ll_[N * 2], *l = ll_;
    
    l->j = j;
    l->next = aa[i].next; aa[i].next = l++;
}

void dfs(int p, int i) {
    struct L *l;
    int x0, x1;
    
    x0 = 0, x1 = 1;
    for (l = aa[i].next; l; l = l->next)
        if (l->j != p) {
            dfs(i, l->j);
            x0 += dp1[l->j];
            x1 += dp[l->j];
        }
    dp1[i] = x1;
    dp[i] = x0 < x1 ? x0 : x1;
}

int main() {
    int n, h, i, j;
    
    scanf(""%d"", &n);
    for (h = 0; h < n - 1; h++) {
        scanf(""%d%d"", &i, &j), i--, j--;
        link(i, j), link(j, i);
    }
    dfs(-1, 0);
    printf(""%d\n"", dp[0]);
    return 0;
}
"
